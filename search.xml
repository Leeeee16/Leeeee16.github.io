<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指Offer46-把数字翻译成字符串</title>
      <link href="/2022/05/31/%E5%89%91%E6%8C%87Offer46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/05/31/%E5%89%91%E6%8C%87Offer46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-Offer-46-把数字翻译成字符串"><a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h4><p>题目：给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p>样例：</p><blockquote><p>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, “bwfi”, “bczi”, “mcfi&quot;和&quot;mzi”</p><p>其中：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>&lt;</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">0 \leq num &lt; 2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span></span></span></span></p></blockquote><p>思路：动态规划题的核心是找到状态转移方程，以及定义好初始状态。</p><p>定义：dp[i]表示第i个数字结尾的方案数，那么转移方程有两种情况：</p><ol><li>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>两个数字可以被翻译，即在[10, 25]区间内，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i - 1] + dp[i - 2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></li><li>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>两个数字不能被翻译，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></li></ol><p>可以看到dp[i]的值仅和前两个dp值有关，因此可以优化空间数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">char</span>[] c = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">dp1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dp2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (c[i - <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (c[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            ans = <span class="number">10</span> &lt;= a &amp;&amp; a &lt;= <span class="number">25</span> ? dp1 + dp2 : dp2;</span><br><span class="line">            dp1 = dp2;</span><br><span class="line">            dp2 = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习随笔</title>
      <link href="/2020/08/10/JVM_Note/"/>
      <url>/2020/08/10/JVM_Note/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM的架构模型">JVM的架构模型</h2><p>JAVA编译器输入的指令流基本是一种基于<strong>栈的指令集架构</strong>，另一种架构是基于寄存器的。<br>两者的区别：</p><ul><li><strong>基于栈式架构的特点</strong><ul><li>设计和实现更简单，适用于资源受限的系统，比如嵌入式。</li><li>避开了寄存器的分配难题：采用零地址指令方式分配。（零地址就是只有操作码，没有地址字段，因为栈的话只对栈顶进行操作，就不需要地址）</li><li>指令流中的指令大部分是零地址指令，执行过程依赖操作栈。<strong>指令集更小</strong>，编译器容易实现。</li><li>不需要硬件支持，可移植性更好，更好实现<strong>跨平台</strong></li></ul></li><li><strong>基于寄存器架构的特点</strong><ul><li>指令集完全依赖于硬件，可移植性差。</li><li>性能优秀、执行高效</li><li>花费更少的指令来完成一项操作</li><li>在大部分情况下，采用一地址指令、二地址指令和在地址指令为主。</li></ul></li></ul><h2 id="JVM的生命周期">JVM的生命周期</h2><ul><li>虚拟机的启动：Java虚拟机的启动时通过引导类加载器(bootstrap class loader)创建一个初始类(initial calss)来完成的，这个类是由虚拟机的具体实现指定的。</li><li>虚拟机的执行：<ul><li>任务：执行Java程序</li><li>程序开始执行时它才运行，程序结束它就停止</li><li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</li></ul></li><li>虚拟机的退出：<ul><li>程序正常执行结束</li><li>程序碰到异常或错误而异常终止</li><li>由于操作系统出错而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或者System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作</li><li>除此之外，JNI(Java Native Interface)规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况</li></ul></li></ul><h2 id="JVM整体结构">JVM整体结构</h2><p><img src="https://cdn.jsdelivr.net/gh/Leeeee16/blog_picBed@master/JVM_jiegou.jpg" alt=""></p><h2 id="类加载器子系统">类加载器子系统</h2><p><img src="https://cdn.jsdelivr.net/gh/Leeeee16/blog_picBed@master/JVM_leijiazaiqi.jpg" alt=""></p><ul><li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</li><li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</li><li>加载的类信息存放在一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分信息是Class文件中常量池部分的内存映射）</li></ul><h3 id="类的加载阶段">类的加载阶段</h3><ol><li>加载：<ol><li>通过一个类的全限定名定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的<strong>java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口。</li></ol></li><li>链接：<ol><li>验证：<ul><li>目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性</li><li>主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证</li></ul></li><li>准备：<ul><li>为类变量分配内存并且设置类变量为默认初始值，即零值</li><li>这里不包含final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化</li><li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li></ul></li><li>解析：<ul><li>将常量池内的符号引用转换为直接引用的过程。</li><li>解析操作往往会伴随着JVM在执行完初始化之后再执行。</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。</li></ul></li></ol></li><li>初始化：<ul><li>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程。</li><li>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和<strong>静态代码块</strong>中的语句合并而来的。</li><li>&lt;clinit&gt;()不同于类的构造器。(构造器是虚拟机视角下的&lt;init&gt;())</li><li>若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类&lt;clinit&gt;()已经执行完毕。</li><li>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。</li></ul></li></ol><h3 id="类加载器的分类">类加载器的分类</h3><ul><li>JVM支持两种类型的类加载器：<strong>引导类加载器(Bootstrap ClassLoader)</strong> 和<strong>自定义类加载器(User-Defined ClassLoader)</strong></li><li>从概念上讲，自定义类加载器一般指程序中由程序员自定义的一类类加载器，但Java虚拟机规范指出，将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</li><li>无论定义咋分，最常见的三个类加载器如下图：<br>（引导类加载器、扩展类加载器和系统类加载器）<br><img src="https://cdn.jsdelivr.net/gh/Leeeee16/blog_picBed@master/JVM_leijiazaiqifenlei.jpg" alt=""><br><strong>这里的四者之间的关系是包含关系。不是上下层关系，也不是父类的继承关系。</strong><br>Demo:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 获取系统类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader); <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 获取其上层：扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader); <span class="comment">// sun.misc.Launcher$ExtClassLoader@1b6d3586</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 获取其上层：获取不到引导类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader); <span class="comment">// null</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader); <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// String类使用引导类加载器进行加载 ---&gt; Java的核心类库都是使用引导类加载器进行加载</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1); <span class="comment">// null</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="启动类加载器-引导类加载器，Bootstrap-ClassLoader">启动类加载器(引导类加载器，Bootstrap ClassLoader)</h3><ul><li>这个类加载器使用C/C++语言实现的，嵌套在JVM内部</li><li>它用来加载Java的核心库(JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容)，用于提供JVM自身需要的类</li><li>并不继承自java.lang.ClassLoader，没有父加载器</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</li><li>处于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><h3 id="扩展类加载器-Extension-ClassLoader">扩展类加载器(Extension ClassLoader)</h3><ul><li>Java编写</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录jre/lib/ext子目录(扩展目录)下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li></ul><h3 id="应用程序类加载器-系统加载器，AppClassLoader">应用程序类加载器(系统加载器，AppClassLoader)</h3><ul><li>Java编写</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它完成加载的</li><li>通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************启动类加载器*************&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取BootstrapClassLoader能够加载的api路径</span></span><br><span class="line">        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span>(URL element : urls)&#123;</span><br><span class="line">            System.out.println(element.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            *************启动类加载器*************</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/resources.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/rt.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/sunrsasign.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/jsse.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/jce.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/charsets.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/jfr.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/classes</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;**************扩展类加载器**************&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">extDirs</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String path : extDirs.split(<span class="string">&quot;;&quot;</span>))&#123;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            **************扩展类加载器**************</span></span><br><span class="line"><span class="comment">            E:\Java\jdk8\jdk1.8.0_251\jre\lib\ext</span></span><br><span class="line"><span class="comment">            C:\Windows\Sun\Java\lib\ext</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户自定义类加载器">用户自定义类加载器</h3><ul><li>在Java的日常应用程序开发中，类的加载几乎是由上述三种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，类定制类的加载方式。</li><li>目的：<ul><li>隔离加载器</li><li>修改类加载器</li><li>扩展加载源</li><li>防止源码泄露</li></ul></li></ul><h3 id="获取ClassLoader的方式">获取ClassLoader的方式</h3><ol><li><code>class.getClassLoader()</code>：获取当前类的ClassLoader</li><li><code>Thread.currentThread().getContextClassLoader()</code>：获取当前线程上下文的ClassLoader</li><li><code>ClassLoader.getSystemClassLoader()</code>：获取系统的ClassLoader</li><li><code>DriverManager.getCallerClassLoader()</code>：获取调用者的ClassLoader</li></ol><h3 id="双亲委派机制">双亲委派机制</h3><ul><li>Java虚拟机对class文件采用按需加载的方式，加载时采用双亲委派记至，即把请求交由父类处理，它是一种任务委派模式。</li><li>原理：<ol><li>如果一个类加载器收到了类加载请求，它不会先自己加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上层委托，以此类推，直到请求最终达到顶层的启动类加载器；</li><li>如果父类加载器可以完成加载任务，就成功返回，倘若父类加载器无法完成此次加载任务，子加载器才会尝试自己去加载<br><img src="https://cdn.jsdelivr.net/gh/Leeeee16/blog_picBed@master/shuangqinweipai.jpg" alt=""></li></ol></li><li>优势：<ol><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改</li></ol></li></ul><h3 id="沙箱安全机制">沙箱安全机制</h3><ul><li>将Java代码限定在JVM特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证代码的有效隔离，防止对本地系统造成破坏。</li><li>如果我们自定义一个类名为String的类，并且包为java.lang。如果没有沙箱安全机制，可能会污染到原本jdk中的String类。根据双亲委派机制，委托到顶层的启动类加载器，就可以完成String的加载，避免了代码污染。</li></ul><h3 id="线程">线程</h3><ul><li>JVM允许多线程并行执行</li><li>在Hotspot JVM中，每个线程都与操作系统的本地线程直接映射。当一个Java线程准备好执行后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li><li>操作系统负责所有线程的安排调度到任何一个CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</li></ul><h2 id="运行时数据区">运行时数据区</h2><p><img src="https://cdn.jsdelivr.net/gh/Leeeee16/blog_picBed@master/yunxingshishujuqu.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/Leeeee16/blog_picBed@master/yunxingshishujuqu2.jpg" alt=""></p><ul><li>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机的退出而销毁。另外一些则是与线程一一对应，这些与线程对应的数据区会随着线程开始和结束而创建和销毁。</li><li>上面第一张图中，红色区域(方法区和堆)为一个进程共享的区域，而灰色部分(PC寄存器、本地方法栈和虚拟机栈)则为一个线程一份。</li><li>每个JVM只有一个Runtime实例。即为运行时环境。</li></ul><h3 id="程序计数器-PC寄存器，Program-Counter-Register">程序计数器(PC寄存器，Program Counter Register)</h3><h4 id="概述">概述</h4><ul><li>存储指令相关的现场信息，CPU只有把数据装载到寄存器才能够运行。</li><li>这里的PC寄存器只是JVM对物理PC寄存器的一种抽象模拟，并不是物理寄存器。</li><li>作用：PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码，由执行引擎读取下一条指令。(和计组学的那个功能类似。。)</li><li>它是一块很小的内存空间，运行速度最快的存储区域</li><li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值(undefined)</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖它来完成。</li><li>字节码解释器工作时是通过改变程序计数器的值来选取下一条需要执行的字节码指令。</li><li>它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</li></ul><h4 id="问题">问题</h4><ol><li>使用PC寄存器存储字节码指令地址有什么用？(为什么使用PC寄存器记录当前线程的执行地址呢？)<br>因为CPU需要不停地切换各个线程，这时候切换回来以后，就需要知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</li><li>PC寄存器为什么会被设定为线程私有？<br>多线程就是在一个特定的时间内只会执行其中某一个线程，CPU会不停地做任务切换，因此就会涉及到中断和恢复。为了能够准确地记录每个线程正在执行的当前字节码指令地址，就必须为每个线程分配一个PC寄存器。</li></ol><h3 id="虚拟机栈">虚拟机栈</h3><h4 id="概述-2">概述</h4><ul><li>栈是运行时的单位，堆是存储的单位</li><li>生命周期与线程一致。即每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame)，对应着一次次的Java方法调用。是线程私有的。</li><li>作用：管Java程序的运行，保存方法的局部变量、部分结果。并参与方法的调用和返回。</li><li>对于栈来说，不存在垃圾回收问题。</li><li>栈中可能出现的异常：<ul><li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出<strong>StackOverflowError</strong>异常。</li><li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存区创建对应的虚拟机栈，那Java虚拟机将会抛出一个<strong>OutOfMemoryError</strong>异常。</li></ul></li><li>设置栈内存大小：<code>-Xss</code></li></ul><h4 id="栈的存储单位">栈的存储单位</h4><ul><li>每个线程都有自己的栈，栈中的数据都是以**栈帧(Stack Frame)**的格式存在</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li><li>JVM对Java栈的操作：压栈和出栈</li><li>当前执行的方法的栈帧：当前栈帧-&gt;当前方法-&gt;当前类</li><li>不同线程中所包含的栈帧是不允许存在互相引用的</li><li>Java方法的两种返回方式：一是正常放回，return；另一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</li></ul><h4 id="栈帧的内部结构">栈帧的内部结构</h4><ul><li>局部变量表(Local Variables)</li><li>操作数栈(Operand Stack)(或表达式栈)</li><li>动态链接(Dynamic Linking)(或指向运行时常量池的方法引用)</li><li>方法返回地址(Return Address)(或方法正常退出或者异常退出的定义)</li><li>一些附加信息<br>PS：方法返回地址、动态链接和一些附加信息也称作帧数据区</li></ul><h5 id="局部变量表-Local-Variables">局部变量表(Local Variables)</h5><ul><li><p>也称局部变量数组或本地变量表</p></li><li><p>定义一个<strong>数字数组</strong>，主要用于存储方法参数和定义在方法体内的局部变量(各类基本数据类型、对象引用(reference)、returnAddress类型)</p></li><li><p>局部变量表建立在线程的栈上，是线程私有的数据，因此不存在数据安全问题</p></li><li><p>局部变量表所需的容量大小是在<strong>编译期</strong>确定的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p></li><li><p>方法嵌套调用的次数由栈的大小决定。站越大，方法嵌套调用次数越多。</p></li><li><p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p></li><li><p>Slot:</p><ul><li>局部变量表，最基本的存储单元是Slot(变量槽)</li><li>32位以内的类型只占用一个slot(包括returnAddress类型)；64位的类型(long和double)占用两个slot<blockquote><p>byte、short、char在存储前被转换为int，boolean也被转换为int(0为false，1为true)</p></blockquote></li><li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可访问到局部变量表中指定的局部变量值</li><li>局部变量按照声明的顺序被复制到局部变量表的每一个Slot上</li><li>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列</li></ul><p>Demo:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVariablesTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();</span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9.6</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">        test.add(a, b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;a + b = &quot;</span> + (a + b));</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Leeeee16/blog_picBed@master/jububianliangbiao.jpg" alt=""></p><ul><li>栈帧中的局部变量表中的槽位是可以重复利用的。如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很可能会服用过期局部变量的槽位，从而节省资源</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        b = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上述方法有四个变量，但是局部变量表的槽位只有三个。变量b在出了括号后，过了其作用域。因此之后声明的变量c占了之前b的slot的位置。这样就节省了资源。<br><img src="https://cdn.jsdelivr.net/gh/Leeeee16/blog_picBed@master/JVM_jububianliangbiao2.jpg" alt=""></p></li></ul><p>变量的分类：</p><ul><li>按照数据类型分：1. 基本数据类型 2. 引用数据类型</li><li>按照在类中声明的位置分：<ol><li>成员变量：在使用前，都经历过默认初始化赋值<ul><li>类变量：linking的prepare阶段：给类变量默认赋值 —&gt; initial阶段：给类变量显式赋值即静态代码块赋值</li><li>实例变量：随着对象的创建，会在对空间中分配实例变量空间，并进行默认赋值</li></ul></li><li>局部变量：在使用前，必须进行显式赋值。否则编译不通过</li></ol></li></ul><ol><li>在栈帧中，与性能调优关系最密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。如果局部变量表中的变量不存在了，指向堆空间的指针也就不存在了，那么堆中垃圾就需要被回收</li><li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</li></ol><h5 id="操作数栈-Operand-Stack">操作数栈(Operand Stack)</h5><ul><li>每个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈，也可以成为表达式栈。</li><li>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</li><li>如果被调用的方法带有返回值，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器下一条需要执行的字节码指令。</li><li>一个方法刚开始执行时，栈帧被创建，随之这个方法的操作数栈也被创建，但为空。且最大深度在编译期就定义好了。</li><li>操作数栈<strong>并非采用访问索引的方式来进行数据访问</strong>，只能通过push和pop来操作，因为它是个<strong>栈</strong>，但是它是由数组实现的。</li><li>Java虚拟机的届时引擎是基于栈的执行引擎，其中栈指的就是操作数栈。</li></ul><h4 id="栈顶缓存技术-ToS-Top-of-Stack-Cashing">栈顶缓存技术(ToS, Top-of-Stack Cashing)</h4><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈操作，使得需要更多的指令分派次数和内存读写此时。<br>HotSpot JVM提出栈顶缓存技术(ToS, Top-of-Stack Cashing)，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率</strong>。</p><h4 id="动态链接">动态链接</h4><ul><li>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中<strong>该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现<strong>动态链接(Dynamic Linking)</strong>。比如invokedynamic指令</li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(Symbolic Reference)保存在class文件的常量池里。比如：描述一个方法调用另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong>。<br><img src="https://cdn.jsdelivr.net/gh/Leeeee16/blog_picBed/dataDynamicLinking.jpg" alt=""></li></ul><h4 id="方法的调用">方法的调用</h4><p>在JVM中，将<strong>符号引用</strong>转换为调用方法的<strong>直接引用</strong>与方法的绑定机制相关。</p><ul><li>静态链接：<br>当一个字节码文件被装进JVM内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程，称之为静态链接。</li><li>动态链接：<br>如果<strong>被调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期间将方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此称之为动态链接。</li></ul><hr><p>对应的方法的绑定机制为：早期绑定(Early Binding)和晚期绑定(Late Binding)。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><ul><li>早期绑定：<br>就是指被调用的<strong>目标方法如果在编译期可知，且运行时保持不变</strong>时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此就可以使用静态链接的方式将符号引用转换为直接引用。</li><li>晚期绑定：<br>如果<strong>被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称为晚期绑定。</li></ul><h4 id="虚方法与非虚方法">虚方法与非虚方法</h4><ul><li>非虚方法：<ul><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。</li><li>静态方法、私有方法、final方法、实例构造器、父类方法等</li><li>其他方法称为虚方法</li></ul></li><li>子类对象的多态性的使用前提：1. 类的继承关系 2. 方法的重写</li><li>虚拟机中提供了一下几条方法调用指令：<ul><li>普通调用指令：<ol><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ol></li><li>动态调用指令：<br>5. invokedynamic：动态解析出需要调用的方法，然后执行</li><li>前四条指令固化在虚拟机内部，方法的调用执行不可认为干预，而invokedynamic指令则支持由用户确定方法版本，其中invokestatic指令和invokespecial指令调用的方法称为虚方法，其余的（final修饰的除外）称为虚方法。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2020/07/08/Java_Basic/"/>
      <url>/2020/07/08/Java_Basic/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>重新看看Java基础<br>顺便随便记一些基础的东西。。:smiley:</p></blockquote><hr><h2 id="数据类型">数据类型</h2><p>基本类型：4种整型、两种浮点类型、1中用于表示Unicode编码的字符型char和boolean型</p><ol><li>整型：int、short、long、byte</li><li>浮点型：float、double<blockquote><p>注意：浮点型存在舍入误差，有些小数无法精确表示，如果在数值计算时不允许有误差，可以考虑使用BigDecimal类</p></blockquote></li><li>char类型：用单引号括起来</li><li>boolean：两个值：true和false<blockquote><p>在c++中，可以使用数值0表示布尔值false，非0相当于布尔值true；但Java中不行，编译不能通过</p></blockquote></li></ol><h2 id="final">final</h2><ol><li>关键字final指示常量。</li><li>final表示这个变量只能被赋值一次。一旦被赋值后，就不能改变。</li><li>常量名一般使用全大写。</li><li>类常量可以使用<code>static final</code>来设置，定义位于main方法外，同一个类中的方法都可以使用。</li></ol><h2 id="枚举类型">枚举类型</h2><h2 id="Scanner类">Scanner类</h2><p>从键盘输入数据。</p><ol><li>导包：<code>import java.util.Scanner</code></li><li>创建对象：<code>Scanner sc = new Scanner(System.in)</code></li><li>使用：参数类型 变量名 = sc.成员方法名<code>   从键盘获取一个int：</code>int num = sc.nextInt()<code>    从键盘获取一个String：</code>String str = sc.next()`</li></ol><h2 id="ArrayList">ArrayList</h2><ol><li>创建：<code>ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();</code>。E表示泛型。</li><li><code>System.out.print(list)</code>打印的是list的内容，不是地址。</li><li>public boolean add(E e)：向集合添加元素，参数类型与创建集合的泛型一致。</li><li>public int size()：获取list长度。</li><li>public E remove(int index)：从集合删除索引为index的元素，返回被删除的元素。</li><li>public E get(int index)：获取下标为index的元素，并返回该元素。</li><li>泛型只能为引用类型，不能为基本类型。必须使用基本类型的包装类。</li></ol><table><thead><tr><th style="text-align:center">基本类型</th><th style="text-align:center">包装类</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">Byte</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">Integer</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">Short</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">Long</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">Float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">Double</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">Character</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">Boolean</td></tr></tbody></table><h2 id="String">String</h2><ol><li><p>字符串的构造方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;第一个字符串:&quot;</span> + str1);   <span class="comment">// 第一个字符串:</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] c = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二个字符串：&quot;</span> + str2);   <span class="comment">// 第二个字符串：ABC</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] b = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b);</span><br><span class="line">        System.out.println(<span class="string">&quot;第三个字符串：&quot;</span> + str3);   <span class="comment">// 第三个字符串：abc</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;第四个字符串：&quot;</span> + str4);   <span class="comment">// 第四个字符串：Hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串常量池<br>程序中直接用双引号表示的字符串，就在字符串池中。<br>字符串常量池存在堆中。因为引号表示的字符串，是不能更改的，相当于一个常量。而通过字符数组（或者字节数组）创建的字符串的内容，根据字符数组的改变而改变，它存的地址是数组地址。</p><blockquote><p>对于基本类型来说，== 是进行<em><strong>数值</strong></em>的比较；<br>对于引用类型来说，== 是进行<em><strong>地址值</strong></em>的比较。</p></blockquote> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStringPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] c = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line"></span><br><span class="line">        System.out.println(str1 == str2);   <span class="comment">//true</span></span><br><span class="line">        System.out.println(str1 == str3);   <span class="comment">//false</span></span><br><span class="line">        System.out.println(str3 == str2);   <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串常用方法</p></li></ol><ul><li><p>equals<br><code>public boolean equals(object obj)</code>：参数可以是任意对象，只有参数为字符串并且内容想到才返回true，否则返回false。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStringEquals</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;LeLe&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;LeLe&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] c = &#123;<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;lele&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(str1.equals(str2));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(str2.equals(str3));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(str1.equals(str3));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(str1.equals(str4));  <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>equalsIgnoreCase<br><code>public boolean equalsIgnoreCase(String str)</code>：忽略大小写，比较内容。<br>上面的例子中：<br><code>System.out.println(str1.equalsIgnoreCase(str4));    // true</code></p></li><li><p>length<br><code>str1.length()</code>：获取字符串字符个数。</p></li><li><p>concat<br><code>public String concat(String str)</code>：将当前字符串和参数字符串拼接，并返回新的字符串。</p></li><li><p>charAt<br><code>public char charAt(int index)</code>：获取指定索引位置的单个字符。索引从0开始。</p></li><li><p>indexOf<br><code>public int indexOf(String str)</code>：查找参数字符串在本字符串当中首次出现的索引位置，如果没有，返回-1。<br><strong>上面四个方法的示例如下：</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStringGet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;LeLe&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;str1的长度为：&quot;</span> + str1.length());    <span class="comment">// str1的长度为：4</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;str1 + str2为：&quot;</span> + str1.concat(str2));    <span class="comment">// str1 + str2为：LeLeHello</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;str2的第3个字符为：&quot;</span> + str2.charAt(<span class="number">1</span>));    <span class="comment">// str2的第3个字符为：e</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Le在str1中首次出现的索引为:&quot;</span> + str1.indexOf(<span class="string">&quot;Le&quot;</span>));   <span class="comment">// Le在str1中首次出现的索引为:0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>substring<br><code>public String substring(int index):</code>：截取从参数位置一直到字符串结尾。返回新字符串。<br><code>public String substring(int begin, int end)</code>：截取从begin到end中间的字符串。<strong>左闭右开[begin,end)</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSubString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello,LeLe&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(str1.substring(<span class="number">6</span>));  <span class="comment">// LeLe</span></span><br><span class="line">        System.out.println(str1.substring(<span class="number">0</span>,<span class="number">5</span>));    <span class="comment">// Hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>toCharArray<br><code>public char[] toCharArray()</code>：将当前字符串拆分成字符数组作为返回值。</p></li><li><p>getBytes<br><code>public byte[] getBytes()</code>：获取当前字符串底层的字节数组。</p></li><li><p>replace<br><code>public String replace(CharSequence oldString,CharSequence newString)</code>：将所有出现的老字符串替换成新的字符串，返回替换之后的新的字符串。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStringConvert</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;LeLe&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] c = str1.toCharArray();</span><br><span class="line">        System.out.println(c[<span class="number">1</span>]);   <span class="comment">// e</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] b = str1.getBytes();</span><br><span class="line">        System.out.println(b[<span class="number">2</span>]);   <span class="comment">// 76</span></span><br><span class="line"></span><br><span class="line">        System.out.println(str1.replace(<span class="string">&quot;Le&quot;</span>, <span class="string">&quot;Ba&quot;</span>));</span><br><span class="line">        <span class="comment">// BaBa</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>split<br><code>public String[] split(String regex)</code>：按照参数的规则，将字符串切分成若干部分。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStringSplit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello,LeLe,HaHa,Zhang San&quot;</span>;</span><br><span class="line">        String[] array1 = str1.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array1.length; i++) &#123;</span><br><span class="line">            System.out.println(array1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Hello</span></span><br><span class="line">        <span class="comment">// LeLe</span></span><br><span class="line">        <span class="comment">// HaHa</span></span><br><span class="line">        <span class="comment">// Zhang San</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：split方法的参数其实是一个<strong>正则表达式</strong>。需要注意转义。如按照英文句点&quot;.“来切分，必须写” \\. &quot;</p></blockquote></li></ul><ol start="4"><li>拼接：<ul><li>可以直接使用 “+”号 将两个字符串进行拼接；</li><li>字符串与非字符串用“+”号拼接时，非字符会被转成字符串，输出中常用</li><li>多个字符串拼接可以使用join方法：<code>String s = String.join(&quot;/&quot;,&quot;good&quot;,&quot;bad&quot;,&quot;haha&quot;) // good/bad/haha</code></li></ul></li><li>不可变字符串：String类没有提供修改字符串的方法，在Java中，字符串相当于存放在一个公共的存储池中，字符串变量指向存储池中相应的位置，编译期可以让字符串共享。当字符串变量不使用后，Java会进行垃圾回收。</li><li>空串与null：空串是长度为0，内容为空的字符串，判断字符串是否为空：<code>if(str.length() == 0)</code>或者<code>if(str.equals(&quot;&quot;))</code>；null表示没有任何对象与该变量关联，判断一个字符串是否为null：<code>if(str == null)</code></li><li>字符串的构建：由较短的字符串构建字符串时，采用字符串连接的方式效率比较地下。每次连接字符串，都会创建一个新的String对象，耗时耗空间。因此可以使用StringBuilder类。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> String <span class="title function_">implicit</span><span class="params">(String[] fields)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            res += fields[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">explicit</span><span class="params">(String[] fields)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            res.append(fields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面两个方法各自实现了字符串的拼接，我们通过编译，得到字节码，如下图：<br><img src="https://cdn.jsdelivr.net/gh/Leeeee16/blog_picBed/datastringBuilderTest01.jpg" alt=""><br>字节码的8-35行构成一个循环体，循环体内new了一个StringBuilder对象，也就是说每次循环都会创建一个新的StringBuilder对象。<br><img src="https://cdn.jsdelivr.net/gh/Leeeee16/blog_picBed/datastringBuilderTest02.jpg" alt=""><br>而第二个方法，它只创建了一个StringBuilder对象。</p><h2 id="switch语句">switch语句</h2><ol><li>用法：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(choice) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>switch语句将从与选项值匹配的case标签处开始执行，直到碰到break语句，或者一直执行到switch语句的结束处。如果没有匹配的case，并有default语句，就执行default语句</li></ol><blockquote><p><strong>注意</strong>：如果case结尾没有break，程序会继续执行下一个case分支语句</p></blockquote><ol start="3"><li>case的标签可以是：char、byte、short、int的常量表达式，也可以为枚举或者字符串字面量</li><li>switch使用枚举时,不必在每个标签中指明枚举名：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Size</span> <span class="variable">sz</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="keyword">switch</span>(sz) &#123;</span><br><span class="line">    <span class="keyword">case</span> SMALL: <span class="comment">// no need to use Size.SMALL</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大数值">大数值</h2><ol><li>java.math包中的：BigInteger和BigDecimal。这两个类可以处理包含任意长度数字序列的数值，前者实现了任意精度的整数运算，后者则实现了任意精度的浮点数计算。</li><li>可以使用valueOf方法将普通数值转换为大数值：<code>BigInteger num = BigInteger.valueOf(100)</code></li><li>大数值的运算不能使用算数运算符，需要使用大数值类中的add、subtract、multiply、divide、mod方法</li><li>大数值的divide方法需要给出舍入方式，RoundingMode.HALF_UP为四舍五入</li></ol><h2 id="Arrays-sort">Arrays.sort()</h2><ol><li>默认为升序排序</li><li>采用了双基准快排(DualPivotQuicksort)。快排采用分治的思想，用一个pivot将原数组分成两个子数组，然后递归。双基准快排则是采用两个pivot，将原数组分成三部分（x &lt; pivot1 ; pivot1 &lt;= x &lt;= pivot2 ; x &gt; pivot3）,然后递归。</li><li>Arrays.sort()采用了很多排序方法，不同的情况则使用不同的排序方法。我们假设原数组长度为length<ul><li>length &lt;= 47 ：使用插入排序</li><li>47 &lt; length &lt;= 286 ：使用快速排序</li><li>length &gt; 286 并且 数组高度结构化(基本有序) ：归并排序</li><li>length &gt; 286 并且 基本无序或逆序 ： 快速排序</li></ul></li><li>双基准快排的细节：<ul><li>在选取pivot时，首先通过位运算，获取数组长度的1/7左右</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inexpensive approximation of length / 7</span></span><br><span class="line"><span class="type">int</span> <span class="variable">seventh</span> <span class="operator">=</span> (length &gt;&gt; <span class="number">3</span>) + (length &gt;&gt; <span class="number">6</span>) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>然后选取数组的中间位置e3,以及e3左右1/7、2/7的位置，分别为e1、e2和e4、e5</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Sort five evenly spaced elements around (and including) the</span></span><br><span class="line"><span class="comment"> * center element in the range. These elements will be used for</span></span><br><span class="line"><span class="comment"> * pivot selection as described below. The choice for spacing</span></span><br><span class="line"><span class="comment"> * these elements was empirically determined to work well on</span></span><br><span class="line"><span class="comment"> * a wide variety of inputs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">e3</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// The midpoint</span></span><br><span class="line"><span class="type">int</span> <span class="variable">e2</span> <span class="operator">=</span> e3 - seventh;</span><br><span class="line"><span class="type">int</span> <span class="variable">e1</span> <span class="operator">=</span> e2 - seventh;</span><br><span class="line"><span class="type">int</span> <span class="variable">e4</span> <span class="operator">=</span> e3 + seventh;</span><br><span class="line"><span class="type">int</span> <span class="variable">e5</span> <span class="operator">=</span> e4 + seventh;</span><br></pre></td></tr></table></figure><ul><li>然后对5个索引进行排序，这里用的是插入排序。排完后放回5个位置中</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sort these elements using insertion sort</span></span><br><span class="line"><span class="keyword">if</span> (a[e2] &lt; a[e1]) &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[e2]; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (a[e3] &lt; a[e2]) &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[e3]; a[e3] = a[e2]; a[e2] = t;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[e4] &lt; a[e3]) &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[e4]; a[e4] = a[e3]; a[e3] = t;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; a[e2]) &#123; a[e3] = a[e2]; a[e2] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[e5] &lt; a[e4]) &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[e5]; a[e5] = a[e4]; a[e4] = t;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; a[e3]) &#123; a[e4] = a[e3]; a[e3] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; a[e2]) &#123; a[e3] = a[e2]; a[e2] = t;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Pointers</span></span><br><span class="line"><span class="type">int</span> <span class="variable">less</span>  <span class="operator">=</span> left;  <span class="comment">// The index of the first element of center part</span></span><br><span class="line"><span class="type">int</span> <span class="variable">great</span> <span class="operator">=</span> right; <span class="comment">// The index before the first element of right part</span></span><br></pre></td></tr></table></figure><ul><li>如果5个元素都不相同，则e2为pivot1，e4为pivot3，然后继续双基准快排</li><li>如果5个元素存在相同的，则以e3为pivot进行普通快排</li></ul></li></ol><h2 id=""></h2><h2 id="HashMap（待补充）">HashMap（待补充）</h2><ol><li>底层？<ul><li>初始大小16，默认负载因子0.75（可自定义），12时扩容，扩容一倍即32</li><li>HashMap存的是Node节点，Node节点里包含key和value</li><li>HashMap由数组+单向链表</li></ul></li></ol><h2 id="Java内存结构概述">Java内存结构概述</h2><ol><li>栈(Stack): 存放方法中的局部变量。一旦超出作用域，java会自动释放它的内存空间。</li><li>堆(Heap): 凡是new出来的东东（对象、数组等等），都存放在堆中。<br>堆中的东西都有一个内存地址值（16进制），且都有一个默认初始值。规则如下：<br>int默认为0；double默认为0.0；字符默认为’\u0000’；布尔默认为false；引用类型默认为null。<br>实体不再被使用后，会在不确定的时间内被垃圾回收器回收。</li><li>方法区(Method Area)：包含class和static变量。</li><li>本地方法栈(Native Method Stack)：与操作系统相关。</li><li>寄存器(pc Register)：CPU相关。CPU访问寄存器执行速度远大于在主存上的执行速度。</li></ol><h2 id="面向对象三大特征">面向对象三大特征</h2><ol><li><p>封装：将实现的细节隐藏，对外界不可见。需要的时候直接调用即可，不需要知道实现细节。<br>（1） 方法就是一种封装<br>（2） 关键字private也是一种封装：使用private修饰后，只能在类的内部进行访问。在本类范围外则不能直接访问，不能对其进行修改。间接访问static成员变量，可以定义一组getter/setter方法。</p></li><li><p>继承：将共性提取到父类中。继承是多态的前提。<br>Java是<strong>单继承</strong>的。可以<strong>多级继承</strong>。</p></li><li><p>多态：</p></li></ol><h2 id="this关键字">this关键字</h2><p>方法的局部变量和类的成员变量重名时，会就近使用方法的局部变量。如果要访问类的成员变量，需要使用this。格式：this.成员变量名。</p><blockquote><p>ps：谁调用的方法，谁就是this。也就是当前的对象。</p></blockquote><h2 id="构造方法">构造方法</h2><p>构造方法是用来创建对象的方法。一般通过new关键字来创建对象时调用的。格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 类名称(参数类型 参数名称, ...)&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>构造方法的名称必须和类名称完全一样。</li><li>构造方法无返回值。</li><li>如果无构造方法，默认一个无参构造方法，方法体啥都不做。</li><li>构造方法可以重载（方法名相同，参数列表不同）。</li></ol><h2 id="static">static</h2><ol><li>使用static关键字修饰的成员变量，不再属于对象自己，而是属于类的。所有的对象共享同一份。</li><li>使用static关键字修饰的成员方法，就是静态方法，它不再属于对象，而是属于类的。</li><li>如果没有static关键字，必须先创建对象，然后通过对象来使用。<br>如果有static关键字，可以直接通过类名称来使用。<br>无论是成员变量还是成员方法，如果有了static关键字修饰，都推荐使用类名称进行使用。</li><li>静态代码块：当第一次用到本类时，静态代码快执行唯一的一次。<br>静态内容总是优先于非静态，所以静态代码快比构造方法先执行。<br>一般用来一次性对静态成员变量进行赋值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名称&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 静态代码块的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>静态不能直接访问非静态。因为内存中是先有的静态内容，后有的非静态内容。</li><li>静态方法中不能使用this。this代表当前对象。</li><li>静态变量存在内存中的方法区里的静态区中。根据类名称访问静态成员变量的时候，和对象（存在内存的堆中）没关系，只和类有关系。</li></ol></blockquote><p>Demo01</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">idCounter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String room;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = ++idCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStaticField</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        Student.room = <span class="string">&quot;Room 101&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span> + one.getId() + <span class="string">&quot;,name:&quot;</span> + one.getName()</span><br><span class="line">                + <span class="string">&quot;,age:&quot;</span> + one.getAge() + <span class="string">&quot;,room:&quot;</span> + Student.room);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">two</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;呆子&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span> + two.getId() + <span class="string">&quot;,name:&quot;</span> + two.getName()</span><br><span class="line">                + <span class="string">&quot;,age:&quot;</span> + two.getAge() + <span class="string">&quot;,room:&quot;</span> + Student.room);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output:</span></span><br><span class="line">    <span class="comment">//  id:1,name:张三,age:20,room:Room 101</span></span><br><span class="line">    <span class="comment">//  id:2,name:呆子,age:10,room:Room 101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo02</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">numStatic</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一个普通的成员方法。&quot;</span>);</span><br><span class="line">        <span class="comment">// 成员方法可以访问成员变量，也可以访问静态变量</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(numStatic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodStatic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个static方法。&quot;</span>);</span><br><span class="line">        <span class="comment">// 静态方法只能访问静态变量</span></span><br><span class="line">        System.out.println(numStatic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01StaticField</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        obj.method();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态方法可以使用对象名来调用，也可以直接通过类名称来调用</span></span><br><span class="line">        obj.methodStatic(); <span class="comment">// 不推荐，这种写法编译后仍会被翻译成“类名称.静态方法名”</span></span><br><span class="line">        MyClass.methodStatic();  <span class="comment">// 推荐</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重写">重写</h2><ol><li>重写：在继承关系中，方法名一样，参数一样。<br>重载：方法名一样，参数不一样。</li><li>@override写在方法前，检测是否是有效的正确的重写。</li></ol><h2 id="父子类构造方法的访问">父子类构造方法的访问</h2><ol><li>子类构造方法中，默认一个<code>super();</code>调用，必须先调用父类构造，再调用子类构造。</li><li>子类构造可以通过super关键字来调用父类重载构造。</li><li>super的父类构造调用必须是子类构造方法中的第一个语句，且只能有一个super调用。</li></ol><h2 id="super关键字">super关键字</h2><ol><li>在子类成员方法中访问父类的成员变量。<code>super.xxx</code></li><li>在子类的成员方法中访问父类的成员方法。<code>super.xxx()</code></li><li>在子类的构造方法中访问父类的构造方法。<code>super()</code></li></ol><h2 id="this关键字-2">this关键字</h2><ol><li>在本类的成员方法中，访问本类的成员变量。<code>this.xxx</code></li><li>在本类的成员方法中，访问本类的另一个成员方法。<code>this.xxx()</code></li><li>在本类的构造方法中，访问本类的另一个构造方法。<code>this(...)</code></li></ol><blockquote><p>注意：在第三种用法中，<code>this(...)</code>调用必须也是构造方法的第一个且唯一的语句。super和this两种构造调用，不能同时使用。</p></blockquote><h2 id="抽象类">抽象类</h2><ol><li>抽象类不能创建对象。</li><li>抽象类可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</li><li>抽象类不一定包含抽象方法，有抽象方法一定是抽象类。</li><li>抽象类的子类，必须重写抽象父类中所有的抽象方法。</li></ol><h2 id="接口">接口</h2><ul><li>接口没有静态代码块或者构造方法。</li><li>一个类的直接父类是唯一的，单一个类可以同时实现多个接口。</li><li>如果实现类所实现的多个接口中，存在重复的抽象方法，只需要覆盖重写一次即可。</li><li>如果实现类没有覆盖重写所有接口的所有抽象方法，那么实现类必须为一个抽象类。</li><li>如果实现类所实现的多个接口中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</li><li>一个类如果父类中的方法，和接口中的默认方法产生冲突，优先用父类当中的方法。</li></ul><h3 id="成员变量">成员变量</h3><p>格式： <code>[public] [static] [final] 数据类型 常量名称 = 数据值;</code></p><blockquote><p>常量必须进行赋值，一旦赋值，不能改变。<br>常量命名建议全大写，用下划线分隔。</p></blockquote><h3 id="接口中的抽象方法">接口中的抽象方法</h3><p>格式：  <code>[public] [abstract] 返回值类型 方法名称(参数列表);</code></p><blockquote><p>实现类必须覆盖重写接口所有的抽象方法，除非实现类也是抽象类。</p></blockquote><h3 id="接口的默认方法">接口的默认方法</h3><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="keyword">default</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>接口中的默认方法，可以解决接口升级的问题。如果接口需要添加一个新的抽象方法，但不能影响以及运行的实现类，则可以使用默认方法。</li><li>接口的默认方法，可以通过接口实现类的对象直接调用。</li><li>接口的默认方法，也可以被接口实现类进行覆盖重写。</li></ol></blockquote><h3 id="接口的静态方法">接口的静态方法</h3><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>静态方法不能通过接口实现类的对象来调用，必须通过接口名称来调用。<br>格式：接口名称.静态方法名(参数);</p></blockquote><h3 id="私有方法">私有方法</h3><p>（Java 9之后）格式：</p><ol><li>普通私有方法：<code>public 返回值类型 方法名称(参数列表) &#123; 方法体 &#125;</code></li><li>静态私有方法：<code>public static 返回值类型 方法名称(参数列表) &#123; 方法体 &#125;</code></li></ol><blockquote><p>private的方法只有接口自己使用。</p></blockquote><h2 id="Iterator迭代器">Iterator迭代器</h2><p>对集合进行遍历。两个常用方法：</p><ol><li>boolean hasNext():如果仍然有元素可以迭代，则返回true；判断集合是否还有下一个元素，有则返回true，无则返回false。</li><li>E next():返回迭代的下一个元素；取出集合中的下一个元素。<br>Iterator是一个接口，无法直接用，需要使用Iterator接口的实现类对象。<br>Collection接口中的iterator()方法，返回的就是迭代器的实现类对象<br><code>Iterator&lt;E&gt; iterator()</code> 返回在此collection的元素上进行迭代的迭代器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoIterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;马云&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for遍历">for遍历</h2><p>使用的Iterator迭代器，形式上是for。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:list) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型">泛型</h2><p>未知数据类型，当创建对象或者具体使用的时候，再确定泛型的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericClass</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> E name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(E name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFanxing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GenericClass&lt;Integer&gt; gc = <span class="keyword">new</span> <span class="title class_">GenericClass</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        gc.setName(<span class="number">6</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">gcName</span> <span class="operator">=</span> gc.getName();</span><br><span class="line">        System.out.println(gcName); <span class="comment">// 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射">反射</h2><ul><li>反射机制：将类的各个组成部分封装为其他<strong>对象</strong>。</li><li>java代码经历的三个阶段：<ul><li><p>Source源代码阶段(存在硬盘)：源码(xxx.java),编译后，字节码文件(xxx.class)。字节码文件存放成员变量、构造方法、成员方法等等。</p></li><li><p>Class类对象阶段：通过类加载器(ClassLoader)将字节码文件加载到内存中去。<br>在内存中如何表述字节码文件的内容？Class类对象。<br>Class类对象包括用来描述成员变量、构造方法、成员方法的若干对象。<br>如成员变量，使用<code>Field[] fields</code>这样一个数组来表示所有的成员变量。<br>如构造方法，使用<code>Constructor[] cons</code>来表示所有的构造器。<br>成员方法，使用<code>Method[] methods</code>来表示所有成员方法。<br>之后可以通过Class类对象的行为，来new对象啊。。等等</p></li><li><p>Runtime运行时阶段:xxx对象，new xxx()。</p></li></ul></li></ul><h3 id="获取Class类对象的方式">获取Class类对象的方式</h3><ol><li><p>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象。</p><ul><li>多用于配置文件，将类名定义在配置文件中。读取文件，加载类。</li></ul></li><li><p>类名.class：通过类名的属性class获取。</p><ul><li>多用于参数的传递。</li></ul></li><li><p>对象.getClass()：getClass()方法在Object类中定义。</p><ul><li>多用于对象的获取字节码的方式。</li></ul><p>Demo：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 1. Class.forName(&quot;全类名&quot;)</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.demo.person.Person&quot;</span>);</span><br><span class="line">        System.out.println(cls1);   <span class="comment">// class com.demo.person.Person</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 2. 类名.class</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls2</span> <span class="operator">=</span> Person.class;</span><br><span class="line">        System.out.println(cls2);   <span class="comment">// class com.demo.person.Person</span></span><br><span class="line">        <span class="comment">// 3. 对象.getClass();</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls3</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">        System.out.println(cls3);   <span class="comment">// class com.demo.person.Person</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// ==比较三个对象</span></span><br><span class="line">        System.out.println(cls1==cls2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(cls1==cls3); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>结论：同一个字节码文件(*.class)在一次程序运行过程中，只被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</li></ul><h3 id="Class对象的功能">Class对象的功能</h3><ul><li>获取功能：<ol><li><p>获取成员变量</p><ul><li>Field[] getFields()：获取所有<strong>public</strong>修饰的成员变量</li><li>Field getField(String name)：获取指定名称的<strong>public</strong>修饰的成员变量</li><li>Field[] getDeclaredFields():获取所有的成员变量，不考虑修饰符</li><li>Field getDeclaredFields(String name)</li><li>Field操作：<ol><li>设置值：<code>void set(object obj, boject value)</code></li><li>获取值：<code>get(object obj)</code></li><li>忽略访问权限修饰符的安全检查(暴力反射)：setAccessible(true)</li></ol></li></ul><p>person类：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String public_a;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> protected_b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> private_d;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, public_a=&#x27;&quot;</span> + public_a + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, protected_b=&quot;</span> + protected_b +</span><br><span class="line">                <span class="string">&quot;, c=&quot;</span> + c +</span><br><span class="line">                <span class="string">&quot;, private_d=&quot;</span> + private_d +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eating...&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 0. 获取person.Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">personClass</span> <span class="operator">=</span> Person.class;</span><br><span class="line">        <span class="comment">// 1. Field[] getFields()</span></span><br><span class="line">        Field[] fields = personClass.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);  <span class="comment">// public int com.demo.classDemo.Person.public_a</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. Field getField(String name)</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">a</span> <span class="operator">=</span> personClass.getField(<span class="string">&quot;public_a&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取成员变量a的值</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> a.get(p);</span><br><span class="line">        System.out.println(value);  <span class="comment">// null</span></span><br><span class="line">        <span class="comment">// 设置值</span></span><br><span class="line">        a.set(p, <span class="string">&quot;张三&quot;</span>); <span class="comment">// Person&#123;name=&#x27;null&#x27;, age=0, public_a=&#x27;张三&#x27;, protected_b=0, c=0, private_d=0&#125;</span></span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.Field[] getDeclaredFields()</span></span><br><span class="line">        Field[] declaredFields = personClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field declaredField : declaredFields)&#123;</span><br><span class="line">            System.out.println(declaredField);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        private java.lang.String com.demo.classDemo.Person.name</span></span><br><span class="line"><span class="comment">        private int com.demo.classDemo.Person.age</span></span><br><span class="line"><span class="comment">        ...共6个...</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 4. Field getDeclaredFields(String name)</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">d</span> <span class="operator">=</span> personClass.getDeclaredField(<span class="string">&quot;private_d&quot;</span>);</span><br><span class="line">        <span class="comment">// 忽略访问权限修饰符的安全检查，否则会报错</span></span><br><span class="line">        d.setAccessible(<span class="literal">true</span>);  <span class="comment">// 暴力反射</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value2</span> <span class="operator">=</span> d.get(p);</span><br><span class="line">        System.out.println(value2); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取构造方法</p><ul><li>Constructor&lt;?&gt;[] getConstructors()</li><li>Constructor&lt;T&gt; getConstructor(类&lt;?&gt;… parameterTypes)</li><li>Constructor&lt;T&gt; getDeclaredConstructors()</li><li>Constructor<?>[] getDeclaredConstructor(类<?>… parameterTypes)</li><li>Constructor:构造方法<ul><li>创建对象：<code>T newInstance(object... initargs)</code></li></ul></li></ul><p>Demo：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">personClass</span> <span class="operator">=</span> Person.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Constructor&lt;?&gt;[] getConstructors()</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> personClass.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        System.out.println(constructor1);  <span class="comment">// public com.demo.classDemo.Person(java.lang.String,int)</span></span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> constructor1.newInstance(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        System.out.println(person); <span class="comment">// Person&#123;name=&#x27;张三&#x27;, age=18, public_a=&#x27;null&#x27;, protected_b=0, c=0, private_d=0&#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取成员方法</p><ul><li>Method[] getMethods()</li><li>Method getMethod(String name, 类&lt;?&gt;… parameterTypes)</li><li>Method[] getDeclaredMethods()</li><li>Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes)</li><li>Method:方法对象<ul><li>执行方法:<code>object invoke(object obj, object...args)</code></li><li>获取方法名称:<code>String getName</code></li></ul></li></ul><p>Demo:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">personClass</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定名称的方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">eat_method</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        eat_method.invoke(p);   <span class="comment">// eating...</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">eat_method2</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;eat&quot;</span>, String.class);</span><br><span class="line">        eat_method2.invoke(p,<span class="string">&quot;apple&quot;</span>);  <span class="comment">// eating...apple</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有public修饰的方法</span></span><br><span class="line">        Method[] methods = personClass.getMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method method:methods)&#123;</span><br><span class="line">            System.out.println(method); <span class="comment">// 除了Person的方法，还有Object里的方法</span></span><br><span class="line">        <span class="comment">//method.setAccessible(true);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取类名</p><ul><li>String getName()</li></ul></li></ol></li></ul><h3 id="案例">案例</h3><ul><li>需求:可以创建任意类的对象，并且执行其中任意的方法。</li><li>实现：<ol><li>配置文件</li><li>反射</li></ol></li><li>步骤：<ol><li>将需要创建的对象的全类名和需要执行的方法定义在配置文件中</li><li>在程序中加载读取配置文件</li><li>使用反射技术来加载类文件进内存</li><li>创建对象</li><li>执行方法<br>配置文件（pro.properties）：注意：配置文件放在src目录下<br><code>className=com.demo.classDemo.Person</code><br><code>methodName=eat</code></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            前提：不能改变改类的任何代码，可以创建任意的对象，可以执行任意方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 1. 加载配置文件</span></span><br><span class="line">        <span class="comment">// 1.1 创建Properties对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 1.2 加载配置文件，转换为一个集合</span></span><br><span class="line">        <span class="comment">// 1.2.1 获取class目录下的配置文件</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ReflectTest.class.getClassLoader();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;pro.properties&quot;</span>);</span><br><span class="line">        pro.load(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取配置文件中定义的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.加载该类进内存</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">        <span class="comment">// 4.创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        <span class="comment">//5.获取方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//6.执行方法</span></span><br><span class="line">        method.invoke(obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解">注解</h2><ul><li><p>概念：说明程序的。给计算机看的。</p></li><li><p>使用：<code>@注解名称</code></p></li><li><p>分类：</p><ol><li>生成javadoc文档</li><li>编译检查（如<code>@Override</code>）</li><li>代码分析（用反射）</li></ol></li><li><p>JDK中预定义的一些注解</p><ul><li><code>@Override</code>:检测被该注解标注的方法是否继承自父类（接口）的</li><li><code>@Deprecated</code>：该注解标注的内容表示已过时</li><li><code>@SuppressWarnings(&quot;all&quot;)</code>：压制警告</li></ul></li><li><p>自定义注解</p><ul><li>格式：<ul><li>元注解</li><li><code>public @interface 注解名称&#123; 属性列表; &#125;</code></li></ul></li><li>本质：注解本质上是一个接口，该接口默认继承Annotation接口<br><code>public interface Myanno extends java.lang.annotation.Annotation &#123;&#125;</code></li><li>属性：接口中的抽象方法<ul><li>要求：<ol><li>属性的返回值类型有以下取值<ul><li>基本数据类型</li><li>字符串</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul></li><li>定义了属性，在使用时需要给属性赋值。<ul><li>定义属性时可以使用<strong>default</strong>设置默认值。</li><li>If只有一个属性需要赋值，并且属性的名称是<strong>value</strong>，则<strong>value</strong>可以省略。</li><li>数组赋值时，值使用{ }。如果数组中只有一个值，可省略{ }。</li></ul></li></ol></li></ul></li><li>元注解：用于描述注解的注解。<ul><li><code>@Target</code>：描述注解能够作用的位置<ul><li>ElementType取值：<ul><li>TYPE：可以作用于类上</li><li>METHOD：可以作用于方法上</li><li>FIELD：可以作用于成员变量上</li></ul></li></ul></li><li><code>@Retention</code>：描述注解被保留的阶段<ul><li><code>@Retention(RetentionPolicy.RUNTIME)</code>：当前被描述的注解，会保留到Class字节码文件中，并被JVM读取到。</li></ul></li><li><code>@Documented</code>：描述注解是否被抽取到API文档中</li><li><code>@Inherited</code>：描述注解是否被子类继承</li></ul></li></ul></li><li><p>在程序使用（解析）注解：获取注解中定义的属性值</p><ol><li>获取注解定义的位置（类、方法等等）的对象。（Class、Method、Field）</li><li>获取指定的注解。<code>getAnnotation(Class)</code></li><li>使用注解中的抽象方法获取配置的属性值。</li></ol><p>注解：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 描述需要执行的类名和方法名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span> <span class="comment">// 作用在类上面</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Pro &#123;</span><br><span class="line">    </span><br><span class="line">    String <span class="title function_">className</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">methodName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pro(className = &quot;com.demo.annotation.China&quot;,methodName = &quot;show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        前提：不能改变改类的任何代码，可以创建任意的对象，可以执行任意方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 1. 解析注解</span></span><br><span class="line">        <span class="comment">// 1.1 获取该类的字节码文件对象</span></span><br><span class="line">        Class&lt;ReflectTest&gt; reflectTestClass = ReflectTest.class;</span><br><span class="line">        <span class="comment">// 2. 获取上面的注解对象</span></span><br><span class="line">        <span class="comment">// 在内存中生成了一个该注解接口的子类实现对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public class ProImpl implements Pro&#123;</span></span><br><span class="line"><span class="comment">                public String className()&#123;</span></span><br><span class="line"><span class="comment">                    return &quot;com.demo.annotation.China&quot;;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                public String methodName()&#123;</span></span><br><span class="line"><span class="comment">                    return &quot;show&quot;;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Pro</span> <span class="variable">annotation</span> <span class="operator">=</span> reflectTestClass.getAnnotation(Pro.class);</span><br><span class="line">        <span class="comment">// 3. 调用注解对象中定义的抽象方法，获取返回值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> annotation.className();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> annotation.methodName();</span><br><span class="line">        System.out.println(className);  <span class="comment">// com.demo.annotation.China</span></span><br><span class="line">        System.out.println(methodName); <span class="comment">// show</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
