<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Gateway随笔</title>
      <link href="/2022/08/01/Gateway%E9%9A%8F%E7%AC%94/"/>
      <url>/2022/08/01/Gateway%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本地搭建SpringCloud Demo引入API Gateway模块，记录一些SpringCloud Gateway相关的知识。</p><h3 id="一、Gateway">一、Gateway</h3><p>首先看一下Spring官网的微服务架构图：</p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/微服务架构图.png" style="zoom:67%;" /><p>可以看待网关位于所有服务的上层，所有服务的调用都需要经过网关。</p><p>Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能，例如：熔断、限流、重试等。</p><p>Spring Cloud Gateway是基于异步非阻塞模型上进行开发，性能优秀，且具有动态路由、对路由指定Predicate和Filter、集成Hystrix的断路器功能、集成SpringCloud服务发现、请求限流、支持路由重写等特性。</p><blockquote><p>Zuul 1.x以及过时，且其基于阻塞I/O实现，性能较差，Zuul 2.x咕咕咕，且没有和SpringCloud进行整合…</p></blockquote><h3 id="二、Spring-Cloud-Gateway">二、Spring Cloud Gateway</h3><p>官方文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/</a></p><p>网关的工作流程如下：</p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/SpringCloud网关01.PNG" style="zoom:67%;" /><p>Clients make requests to Spring Cloud Gateway. If the Gateway Handler Mapping determines that a request matches a route, it is sent to the Gateway Web Handler. This handler runs the request through a filter chain that is specific to the request. The reason the filters are divided by the dotted line is that filters can run logic both before and after the proxy request is sent. All “pre” filter logic is executed. Then the proxy request is made. After the proxy request is made, the “post” filter logic is run.</p><p>首先客户端向网关发请求，网关根据路由映射匹配相应的路由，然后发给Gateway Web Handler，其通过指定的过滤器链将请求发到实际的服务执行逻辑，最后返回。其中的Filter过滤器可以在之前或之后执行，如<code>pre</code>过滤器可以进行参数校验、权限校验、流量监控、日志输出、协议转换等，<code>post</code>过滤器可以<strong>响应内容、响应头的修改，日志的输出，流量监控</strong>等。</p><h3 id="三、本地基础配置">三、本地基础配置</h3><p>路由的配置有两种方法，yml文件或者config配置类，下面是yml配置的方式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="comment"># ---------------------网关配置开始---------------------</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 动态路由，根据微服务名称</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_route</span> <span class="comment"># 路由id，唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment"># 匹配后的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span> <span class="comment"># 断言</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_route2</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span></span><br></pre></td></tr></table></figure><p>根据微服务的名称cloud-payment-service进行动态路由，通过这种方式可以实现对服务的负载均衡，如下图可以看到轮询访问8001和8002服务。</p><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.gif" alt=""></p><h3 id="四、网关熔断和限流">四、网关熔断和限流</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="comment"># ---------------------网关配置开始---------------------</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 动态路由，根据微服务名称</span></span><br><span class="line">          <span class="attr">lower-case-service-id:</span> <span class="literal">true</span> <span class="comment"># 服务名称转小写</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_route</span> <span class="comment"># 路由id，唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-provider-hystrix-payment</span> <span class="comment"># 匹配后的路由地址 CLOUD-PROVIDER-HYSTRIX-PAYMENT</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/hystrix/ok/**,</span> <span class="string">/payment/hystrix/timeout/**,</span> <span class="string">/payment/hystrix/error/</span> <span class="comment"># 断言</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="comment"># 重试机制</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Retry</span></span><br><span class="line">              <span class="attr">args:</span></span><br><span class="line">                <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line">                <span class="attr">series:</span> <span class="string">SERVER_ERROR</span></span><br><span class="line">                <span class="attr">methods:</span> <span class="string">GET,POST</span></span><br><span class="line">            <span class="comment"># 网关限流</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hystrix</span></span><br><span class="line">              <span class="attr">args:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">localfallback</span></span><br><span class="line">                <span class="attr">fallbackUri:</span> <span class="string">forward:/gateway/defaultfallback</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RequestRateLimiter</span></span><br><span class="line">              <span class="attr">args:</span></span><br><span class="line">                <span class="attr">key-resolver:</span> <span class="string">&#x27;#&#123;@remoteAddrKeyResolver&#125;&#x27;</span></span><br><span class="line">                <span class="attr">redis-rate-limiter.replenishRate:</span> <span class="number">1</span> <span class="comment">#令牌桶每秒填充平均速率</span></span><br><span class="line">                <span class="attr">redis-rate-limiter.burstCapacity:</span> <span class="number">3</span> <span class="comment">#令牌桶容量</span></span><br><span class="line">                <span class="attr">redis-rate-limiter.requestedTokens:</span> <span class="number">1</span> <span class="comment"># 每次消耗令牌个数</span></span><br><span class="line">    <span class="comment"># ---------------------网关配置结束---------------------</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>在本地添加对网关的熔断和限流。熔断使用的仍然是Hystrix，当下游服务宕机时，调用同一定义的处理逻辑defaultfallback。</p><p>网关的限流采用的Redis的令牌桶，并定义了用于限流的键的解析器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteAddrKeyResolver</span> <span class="keyword">implements</span> <span class="title class_">KeyResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">resolve</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据IP地址限流</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">hostAddress</span> <span class="operator">=</span> exchange.getRequest().getRemoteAddress().getAddress().getHostAddress();</span><br><span class="line">        log.info(<span class="string">&quot;hostAddress = &quot;</span> + hostAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据请求地址限流</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uriPath</span> <span class="operator">=</span> exchange.getRequest().getURI().getPath();</span><br><span class="line">        log.info(<span class="string">&quot;uriPath = &quot;</span> + uriPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据用户ID</span></span><br><span class="line">        <span class="comment">//String userId = exchange.getRequest().getQueryParams().getFirst(&quot;userId&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> Mono.just(hostAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hystrix服务熔断</title>
      <link href="/2022/07/30/Hystrix%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/"/>
      <url>/2022/07/30/Hystrix%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要记录在本地搭建SpringCloud Demo时，使用Hystrix模拟服务降级和服务熔断的相关知识点和配置。</p><h2 id="Hystrix断路器">Hystrix断路器</h2><h3 id="1-使用场景">1.使用场景</h3><p>在微服务架构中，服务调用的链路会随着业务的复杂边的越来越长，一旦其中某些服务节点挂掉，就会导致整体链路无法继续进行。</p><p>服务雪崩：是一种因“服务提供者的不可用”（原因）导致“服务调用者不可用”（结果），并将不可用逐渐放大的现象。</p><p>比如在一个调用连上，服务A调用服务B，服务B调用服务C，如果此时流量突然激增，服务A和服务B能抗住请求，但是服务C挂了，那么请求都阻塞在服务B上，服务B的线程资源会被逐步消耗完，进而导致服务B也不可用，同理，最终服务A也会不可用。</p><p>服务熔断则是解决服务雪崩的方案之一。</p><h3 id="2-服务降级">2.服务降级</h3><p>啥时服务降级？如果下游服务响应太慢，服务提供者会进行服务降级，如暂时停掉重要性低的服务来释放出服务器的资源，来保证主业务的可用性，增加服务响应速度；上游服务调用者发现下游服务响应速度太慢，可以在本地调用服务降级逻辑，直接返回给用户，给予用户友好提示，避免卡顿。</p><h3 id="3-服务熔断">3.服务熔断</h3><p>服务熔断是服务降级的一种方式。</p><p>当下游服务因为某种原因变得不可用或者响应过慢时，上游服务为了保证自身的可用性，不再继续调用下游服务，而是直接返回，快速释放线程资源。等待下游服务可用后，再逐步恢复调用。</p><h3 id="4-Hystrix">4.Hystrix</h3><p>Hystrix是一个用于处理分布式系统的延迟和容错的开源库。它提供了服务降级、服务熔断、监控等能力。</p><p>Hystrix的状态图如下图所示：</p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/Hystrix-01.PNG" style="zoom:50%;" /><p>断路器共三个状态，开启、关闭和半开。服务正常时处于关闭状态，当服务调用的错误率达到设定的阈值时，会转变为开启状态。此时会定义一个reset timeout时间计时，过了这个时间后转换为半开状态，然后尝试调用之前异常的服务，如果服务调用成功后，就会恢复服务；如果调用失败，则重新计时。</p><p>检测到服务节点可以正常响应后，就会自动恢复调用链路。</p><p>Hystrix的工作流程图如下(<a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works#Flow">官网地址</a>)：</p><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/Hystrix-02.PNG" alt=""></p><p>图中蓝色箭头表示调用路径，红色表示响应路径</p><ol><li>创建对象。首先创建HystrixCommand或者HystrixObserableCommand对象</li><li>执行命令。</li><li>查看缓存。如果当前请求开启了请求缓存，并且缓存命中，则将缓存结果以Observable对象的形式返回。</li><li>检查断路器状态。如果为打开，Hystrix直接转到Fallback处理逻辑，即第8步；如果状态为关闭，则检查服务的线程池或信号量状态。</li><li>检查服务的线程池或信号量状态。如果资源已经被占满，也会转到Fallback处理逻辑；如果有空闲的资源，则转到下一步。</li><li>根据第一步创建的对象，采取相应的方法去请求服务。HystrixCommand.run() ：返回一个单一的结果，或者抛出异常。HystrixObservableCommand.construct()： 返回一个Observable 对象来发射多个结果，或通过 onError 发送错误通知。</li><li>Hystrix会将调用的信息（成功、失败、拒绝超时等）反馈给断路器，断路器会维护一组计数器来统计这些信息。然后断路器根据这些信息来决定断路器的状态。</li><li>如果调用命令执行失败，断路器会进入fallback回退处理，即服务降级。从图中可以很容易看出，断路器打开状态、资源不足、服务调用失败和超时都会进入服务降级处理逻辑。</li><li>执行成功后，将处理结果直接返回或者以Observable的形式返回。</li></ol><h3 id="本地搭建相关配置">本地搭建相关配置</h3><p>首先在主函数上添加<code>@EnableHystrix</code>注解</p><p>服务的Service层的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------------ 服务熔断 -----------------------------------</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentCircuitBreakerFallback&quot;, commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;, value = &quot;true&quot;), // 是否开启断路器</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;), // 请求次数</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value = &quot;10000&quot;), // 时间窗口期</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;65&quot;), // 跳闸失败率阈值</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;id不能为负数哈...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serialNumber</span> <span class="operator">=</span> IdUtil.simpleUUID();</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;-----&gt; 调用成功，流水号：&quot;</span> + serialNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentCircuitBreakerFallback</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;paymentCircuitBreakerFallback -------&gt; 请稍后再试......&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里通过访问负数id来模拟服务的不可用，当服务调用失败率达到阈值65%时，就会开启服务熔断，进而调用paymentCircuitBreakerFallback方法。</p><p>本地的模拟效果如下，不断使用负数id进行调用，使得失败调用的比例上升，从而改变了断路器的状态，然后我们调用整数id，发现仍然进入了Fallback服务降级逻辑，因为此时断路器状态为open。</p><p>我们继续调用正确的id，当断路器经过休眠窗口计时，即10秒后，尝试再次调用服务，发现可以正常调用，则修改断路器的状态为close，之后服务能够正常调用。</p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/Hystrix服务熔断demo.gif" style="zoom:80%;" /><h3 id="Hystrix的监控Dashboard">Hystrix的监控Dashboard</h3><p>配置比较简单，我们在本地使用9001端口，使用<code>@EnableHystrixDashboard</code>注解，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixDashboardMain9001</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(HystrixDashboardMain9001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务端都需要添加坐标：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure><p>PS:这里在调试时可能检测不到(Unable to connect to Command Metric Stream/404)，需要在服务端的主方法中添加如下配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServletRegistrationBean因为springboot的默认路径不是&quot;/hystrix.stream&quot;，</span></span><br><span class="line"><span class="comment"> * 只要在自己的项目里配置上下面的servlet就可以了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ServletRegistrationBean <span class="title function_">getServlet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">HystrixMetricsStreamServlet</span> <span class="variable">streamServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HystrixMetricsStreamServlet</span>();</span><br><span class="line">    <span class="type">ServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>(streamServlet);</span><br><span class="line">    registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">    registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dashboard的首页如下，需要填写监控的地址：</p><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/Hystrix-Dashboard-01.PNG" alt=""></p><p>然后进入监控页面：</p><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/Hystrix-Dashboard-02.PNG" alt=""></p><p>可以看到上图的断路器处于Open状态，图中的80%表示最后10秒服务调用的失败率，折线表示请求的变化率，下面一半表示Hystrix的线程池状态。</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《被讨厌的勇气》书摘</title>
      <link href="/2022/07/26/%E3%80%8A%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%E3%80%8B%E9%9A%8F%E7%AC%94/"/>
      <url>/2022/07/26/%E3%80%8A%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%E3%80%8B%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>《被讨厌的勇气》书摘</h1><blockquote><p>最近在看这本书，觉得比较适合现在这个阶段去阅读，就记录一些书中的观点。</p></blockquote><p>本书通过青年与哲人对话的方式，向读者描述了阿德勒心理学的观点，因此看起来也不觉得枯燥无味。</p><h3 id="一、我们的不幸是谁的错">一、我们的不幸是谁的错</h3><p>如果我们一直依赖原因论，就会永远止步不前。</p><p>再怎么找“原因”，也没法改变一个人。决定我们自身的不是过去的经历，而是我们自己赋予经历的意义。</p><p>阿德勒心理学认为，生活方式是自己主动选择的结果。你之所以无法改变，是因为自己下了“不改变”的决心。即使人们有各种不满，但还是认为保持现状更加轻松、更能安心。阿德勒心理学就是勇气心理学。你之所以不幸并不是因为过去或者环境，更不是因为能力不足，你只不过是缺乏“勇气”，可以说是缺乏“获得幸福的勇气”。</p><p>阿德勒心理学的目的论是说：无论之前的人生发生过什么，都对今后的人生如何度过没有影响。</p><p>你的人生取决于“当下”。</p><h3 id="二、一切烦恼都来自人际关系">二、一切烦恼都来自人际关系</h3><p>为什么讨厌自己？你由于太惧怕人际关系所以才会变得讨厌自己，你是在通过自我厌弃来逃避人际关系。</p><p>自卑感来自主管的臆造。我们的自卑感不是“客观性的事实”而是“主观性的解释”。书中以身高为例，解释了问题在于我们如何看待这种身高以及赋予它什么样的价值。</p><p>“价值必须建立在社会意义之上。例如1美元的纸币，如果这个世界上只有我一个人，那我也许会把这1美元的纸币放入壁炉当燃料或者当卫生纸。同样的道理，我自然也就不会再为身高而苦恼。”价值问题最终可以追溯到人际关系上，这也与“一切烦恼皆源于人际关系”联系起来。</p><p>自卑情结只是一种借口。阿德勒承认自卑感人人皆有，自卑感本身并不是什么坏事。</p><p>人为了摆脱生存的无力感，都会“追求优越性”，即希望进步，追求理想状态。人都处于追求优越性这一希望进步的状态中，树立某些理想或目标并努力奋斗。同时，对于无法达成理想的自己就会产生一种自卑感。</p><p>无论是追求优越性还是自卑感，都不是病态，而是一种能够促进健康、正常的努力和成长的刺激。</p><p>“自卑感越强，人就会变得越消极，最终会认为自己一无是处。”这不是自卑感，而是自卑情结。</p><p>“我学历低所以更要付出加倍的努力。”这是自卑感正向的激励。</p><p>“我因为学历低所以无法成功。”、“我因为长得不好所以结不了婚。”这是自卑情结。</p><p>这种“因为有A，所以才做不到B。”阿德勒用“外部因果律”来说明：将原本没有任何因果关系的事情解释成似乎有重大因果关系一样。例如：“自己之所以始终无法结婚，就是因为儿时父母离婚的缘故。”从佛洛依德的原因论来说，父母离婚对其造成了极大的精神创伤，与自己的婚姻观有着很大的因果关系。但阿德勒从目的论的角度出发把这种论调成为“外部因果律”。</p><p>不是“不能成功”而是“不想成功”。害怕向前迈进或者是不想真正地努力。不愿意为了改变自我而牺牲目前所享受的乐趣——比如玩乐或休闲时间。也就是拿不出改变生活方式的“勇气”，即使有些不满或者不自由，也还是更愿意维持现状。</p><p>阿德勒指出“没有任何能够长期忍受自卑感。“拥有自卑感即感觉目前的”我“有所欠缺的状态。</p><p>如何弥补欠缺？刻苦学习、勤奋练习、努力工作等。但是没有这种勇气的人就会陷入自卑情结。</p><p>“如果有高学历自己也很容易成功，现在只不过是被学历低这个因素所埋没，真正的我其实非常优秀。“这种是由自卑情结发展成的另一种特殊的心理状态——”优越情结“。表现得好像自己很优秀，继而沉浸在一种虚假的优越感之中。阿德勒指出“如果有人骄傲自大，那一定是因为他有自卑感。”自卑情结和优越情结是密切相关滴~</p><p>还有一个关于自夸的复杂实例，通过把自卑感尖锐化来实现异常优越感的模式，即夸耀不幸。要借助不幸来显示自己“特别”，他们想要用不幸来压住别人，以自己的不幸为武器来支配对方。阿德勒甚至指出“在我们的文化中，弱势其实非常强大而且具有特权。”</p><p>人生不是与他人的比赛。在同一个平面上既有人走在前面又有人走在后面。不与任何人竞争，只要自己不断前进即可。健全的自卑感不是来自与别人的比较，而是来自与“理想的自己”的比较。价值在于不断超越自我。</p><p>在意你长相的只有你自己。如果人际关系中存在“竞争”，那人就不可能摆脱人际关系带来的烦恼，也就不可能摆脱不幸。如果意识到竞争或胜负，那么势必就会产生自卑感，常拿自己和别人比较就会产生“优于这个、输于那个”之类的想法，而自卑情结或优越情结就会随之产生。如果能够体会到“人人都是我的伙伴“，那么对世界的看法也会截然不同。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode146-LRU缓存</title>
      <link href="/2022/07/22/LeetCode146-LRU%E7%BC%93%E5%AD%98/"/>
      <url>/2022/07/22/LeetCode146-LRU%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="146-LRU-缓存"><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h4><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p><hr><p>面试比较高频，并且涵盖了很多知识点。这里手动实现了双向链表DoubleLink类。</p><p>需要注意各个情况下链表的处理，其实逻辑不难。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表节点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Node pre;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> key;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义双向链表</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DoubleLink</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Node head;</span><br><span class="line">        <span class="keyword">public</span> Node tail;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向链表头部插入一个元素</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">                head = node;</span><br><span class="line">                tail = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">oldHead</span> <span class="operator">=</span> head;</span><br><span class="line">                oldHead.pre = node;</span><br><span class="line">                node.next = oldHead;</span><br><span class="line">                head = node;</span><br><span class="line">            &#125;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除一个节点</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (head == node &amp;&amp; tail == node) &#123;</span><br><span class="line">                head = <span class="literal">null</span>;</span><br><span class="line">                tail = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == head) &#123;</span><br><span class="line">                node.next.pre = <span class="literal">null</span>;</span><br><span class="line">                head = node.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == tail) &#123;</span><br><span class="line">                node.pre.next = <span class="literal">null</span>;</span><br><span class="line">                tail = node.pre;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 中间节点</span></span><br><span class="line">                node.pre.next = node.next;</span><br><span class="line">                node.next.pre = node.pre;</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除链表末尾元素</span></span><br><span class="line">        <span class="keyword">public</span> Node <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> tail;</span><br><span class="line">            remove(tail);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> DoubleLink cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">DoubleLink</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> map.get(key).value;</span><br><span class="line">        put(key, val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">        <span class="comment">// 如果已经存在，则先删除原来的node，再在头部插入，并更新map</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            cache.remove(map.get(key));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cap == cache.size()) &#123;</span><br><span class="line">            <span class="comment">// 如果达到容量限制,删除链表末尾节点，即最不常用的节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> cache.removeLast();</span><br><span class="line">            <span class="comment">// map同步删除</span></span><br><span class="line">            map.remove(last.key);</span><br><span class="line">        &#125;</span><br><span class="line">        cache.addFirst(node);</span><br><span class="line">        map.put(key, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 双向链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud注册中心</title>
      <link href="/2022/07/18/SpringCloud%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
      <url>/2022/07/18/SpringCloud%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在学习SpringCloud框架，首先接触的应该就是注册中心，目前SpringCloud常用的几个注册中心包括：Eureka、Zookeeper、Nacos和Consul。</p><blockquote><p>目前我在本地搭建SpringCloud demo时主要使用Eureka进行调试，后期学习Nacos时，再添加Nacos相关知识~</p></blockquote><h2 id="一、服务注册中心">一、服务注册中心</h2><p>在微服务架构中，随着业务越来越复杂，系统中的服务节点会变得越俩越多，为了更好地管理架构中的服务节点，就需要服务注册中心。服务注册中心提供了服务注册、服务发现、服务管理、负载均衡等能力。</p><p>服务的提供方和服务的消费者都需要将自己的信息注册到服务注册中心中，服务注册中心会保存所有服务，当服务的消费者需要调用服务时，会根据服务列表，通过负载均衡算法，选择服务提供方的相应地址进行服务调用。</p><h3 id="Eureka">Eureka</h3><blockquote><p>官网目前已经停止更新了~</p></blockquote><h4 id="介绍">介绍</h4><p>Netflix开发的服务发现框架，基于REST的服务。</p><p>提供了两个组件：Eureka Server和Eureka Client，分别对应服务的provider和服务的consumer。Eureka的架构比较清晰和简单，如下图所示：</p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/Eureka架构图.PNG" alt="Eureka架构图" style="zoom:50%;" /><p>包含三个角色：Eureka服务中心、服务消费者和服务提供者。</p><p>Eureka服务中心可以进行集群部署，集群中各个节点属于平级关系。服务消费者和提供者启动时向Eureka Server注册服务，并保持心跳连接，默认为90秒。</p><p>Eureka的自我保护机制：当服务发生一些故障时，如网络分区故障，默认是15分钟内收到的续约低于原来的85%时，这个节点就会进入自我保护模式。一旦进入该模式，Eureka Server仍能接收新服务的注册和查询请求，但是不会同步到其他节点上；同时也会保护服务注册表中的信息，不再移除注册列表中因为长时间没收到心跳而应该过期的服务。当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。这样获取的数据的确有可能不是最新的，但Eureka的这种自我保护机制，极大地保证了Eureka的高可用特性。</p><p>下图是Eureka的前端界面，其中CLOUD-PROVIDER-HYSTRIX-PAYMENT是我本地注册的一个服务，如下图：</p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/Eureka界面.PNG" style="zoom:50%;" /><h4 id="本地搭建">本地搭建</h4><p>这里简单介绍下单机的主要配置。</p><h5 id="Eureka-Server">Eureka Server</h5><p>application.yml配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7001.com</span> <span class="comment"># 集群域名</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 集群</span></span><br><span class="line">      <span class="comment"># defaultZone: http://eureka7002.com:7002/eureka/</span></span><br><span class="line">      <span class="comment"># 单机</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/</span></span><br></pre></td></tr></table></figure><p>如果配置集群环境，则在server-url中配置集群其他节点的地址，可以理解为相互注册</p><p>在主方法中添加<code>@EnableEurekaServer</code>注解即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">// 表示当前是Eureka的服务注册中心</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaMain7001</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaMain7001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Service-Provider">Service Provider</h5><p>在注册服务时，application.yml可以如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span> <span class="comment"># 服务名称</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 表示将自己注册进EurekaServer，默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在主函数中添加<code>@EnableEurekaClient</code>注解</p><p>Service Consumer和Service Provider类似，就不描述了。</p><h3 id="Nacos">Nacos</h3><p>To be continue…</p><h2 id="二、注册中心选型">二、注册中心选型</h2><p>平时在学习相似的技术、框架或组件时，要考虑其之间的不同特性。在实际工作项目中，需要结合具体的业务场景去做综合全面的选择，比如是更看重系统的<strong>一致性</strong>，还是需要保证系统的<strong>高可用</strong>。</p><p>由于目前在本地学习时主要使用Eureka作为注册中心，下面参考了一篇总结注册中心选型的文章，做了一些整理，主要对比了Eureka、Zookeeper、Nacos以及Consul四个主流的注册中心。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMTY3NjY3MA==&amp;mid=2247484435&amp;idx=1&amp;sn=4128df73e607512e8cbb823b34913583&amp;chksm=96eb0602a19c8f149d73f1f29dde4f2b0381967449b92e18e1dfccdfd787f95678c2e2c12118&amp;scene=178&amp;cur_album_id=1620816867562930179#rd">参考链接</a></p><h3 id="1-集群结构">1.集群结构</h3><ul><li><p>Eureka的集群架构本身就是平级结构,集群各节点都是平起平坐的关系，数据是相互复制的，因此各个节点都是主人角色</p></li><li><p>zookeeper和consul则均为主从结构。集群角色包含leader、follower以及observer三类，具体来说是一主多从结构，就是有一个leader，多个follower，以及只负责读操作、不参与选举的observer</p></li><li><p>Nacos则支持平级关系和主从这两种集群架构，常用的是后者。包含leader、follower、candidate三类。Leader：负责Client交互和log复制，同一时刻系统中最多存在1个。Follower：被动响应请求RPC，从不主动发起请求RPC。接收到请求，会转发给leader处理。Candidate：一种临时的角色，只存在于leader的选举阶段。</p><p>某个节点想要变成leader，那么就发起投票请求，同时自己变成candidate，如果选举成功，则变为candidate，否则退回为follower</p></li></ul><h3 id="2-是否可以及时知道服务状态变化">2 是否可以及时知道服务状态变化</h3><p>由于zookeeper具有watcher机制，因此可以及时知道数据目录的状态变化，那么也就可以及时知道服务器节点以及所注册的实例的变化。我们可以通过这种监听机制，能够实时获取到某个服务器的故障或者我们比较关心的节点数据的更（zookeeper的节点znode包含服务器节点和数据节点）</p><p>其他三个注册中心没有这样的机制，只是可以通过管理端进行主动查看服务状态，并不能实时感知服务状态的变化</p><h3 id="3-一致性协议（CAP）">3 一致性协议（CAP）</h3><p>回顾一下CAP理论：</p><p>1）一致性（Consistency）注册中心的集群各个节点的数据信息完全一致</p><p>2）可用性（Availability）每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据</p><p>3）分区容错性（Partition tolerance）以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择</p><blockquote><p>任何一个分布式系统都不能同时实现上述三点，一般都会实现P即分区容错性，然后在A和P之前进行权衡和取舍。</p></blockquote><p>Eureka ：支持<strong>AP</strong>，即保障可用性和分区容错性</p><p>Zookeeper：支持<strong>CP</strong>,即保障一致性和分区容错性</p><p>consul：支持<strong>CP</strong>,即保障一致性和分区容错性</p><p>nacos：支持<strong>AP和CP两种模式</strong>。可以分别支持AP和CP两种场景</p><ul><li>一般来说，如果不需要存储服务级别的信息，且服务实例是通过Nacos-client注册，并能够保持心跳上报，那么就可以选择AP模式。AP模式为了服务的可用性而减弱了一致性，因此AP模式下只能注册临时实例</li><li>如果需要在服务级别编辑或存储配置信息，那么CP是必须，K8S服务和DNS服务则适用于CP服务，CP模式下则支持注册持久化实例，此时则是以Raft协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误</li></ul><h3 id="4-雪崩保护">4 雪崩保护</h3><ul><li>Eureka有雪崩保护。我们知道，当网络分区故障发生时，微服务与Eureka Server之间突然无法正常通信了，根据心跳机制，微服务将会被注销。那么这种心跳机制是不是就变得不太友好了？因为这种情况下微服务本身其实是健康的，本不应该注销这个微服务，因此Eureka就提供了一个自我保护机制，也就是雪崩保护机制</li><li>Zookeeper和consul没有雪崩保护</li><li>Nacos有雪崩保护。为了防止因过多实例 (Instance) 不健康导致流量全部流向健康实例 (Instance) ，继而造成流量压力把健康实例 (Instance) 压垮并形成雪崩效应，应将健康保护阈值定义为一个0到1之间的浮点数。当域名健康实例占总服务实例的比例小于该值时，无论实例是否健康，都会将这个实例返回给客户端。这样做虽然损失了一部分流量，但是保证了集群的剩余健康实例 (Instance) 能正常工作</li></ul><h3 id="5-负载均衡">5 负载均衡</h3><p>Eureka: 使用ribbon实现</p><p>Zookeeper: 一般可以直接采用RPC的负载均衡</p><p>Nacos: 采用权重/metadata/Selector</p><p>Consul: 使用Fabio</p><h3 id="小结：">小结：</h3><p>​需要结合业务场景来进行选择。比如说，对于金融类的业务场景，对于一致性要求更高，那么就会排除掉Eureka,然后根据易用性、性价比等其他方面再进行后续的选择；对于高可用比较注重的项目，如电商类项目，则可以选择Eurek或者Nacos，但再比较其他方面，Nacos不仅可以做注册中心，还可以作为架构中的配置中心，并且社区活跃度比较高，功能也日渐在完善，使用的人越来越多，因此综合来讲，就选择了Nacos<br>​具体选择的过程中，当然也会考虑这些因素之外的一些特点，包括人员的熟悉度等等，但肯定也是先考虑主要的特点，再去考虑这些不是那么重要的特点的。</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发随笔</title>
      <link href="/2022/07/14/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
      <url>/2022/07/14/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>在ImportNew公众号看到一篇高并发的文章，之前自己也写过一个简单的秒杀项目，这里记录一些文章中的知识点。</p><p><a href="https://mp.weixin.qq.com/s/KndeH1BbEH7OUpcjJ8oZUw">原文连接</a></p></blockquote><h2 id="如何理解高并发">如何理解高并发</h2><ol><li><p>不能只看数字，要看具体的业务场景。就是不能只看10WQPS、100WQPS或者并发量，需要根据具体的业务逻辑来衡量。</p></li><li><p>业务是慢慢做大的，业务量也是逐渐变为10倍、100倍的。要用高并发的处理方法去演进系统，从架构设计、编码实现、甚至产品方案等<strong>多维度</strong>去预防和解决高并发问题。</p></li><li><p>高并发有很多场景：如有读多写少的信息流场景、有读多写多的交易场景等。</p></li></ol><h2 id="高并发系统设计的目标是什么？"><strong>高并发系统设计的目标是什么？</strong></h2><h3 id="宏观目标">宏观目标</h3><ol><li>高性能：系统的并行处理能力；用户体验，降低服务的响应时间</li><li>高可用：系统可以正常服务的时间。隔三差五服务器就挂肯定会影响业务和用户体验。</li><li>高扩展：系统的扩展能力。流量高峰时能否在短时间内完成扩容，平稳承接峰值流量。如秒杀活动等。</li></ol><h3 id="微观目标">微观目标</h3><h4 id="性能指标">性能指标</h4><ol><li>平均响应时间：最常用，但是缺陷很明显，对于慢请求不敏感。</li><li>TP90、TP99等分位值：将响应时间按照从小到大排序，TP90表示排在第90分位的响应时间， 分位值越大，对慢请求越敏感。</li><li>吞吐量：和响应时间成反比，比如响应时间是1ms，则吞吐量为每秒1000次。</li></ol><p>​通常，设定性能目标时会兼顾吞吐量和响应时间，比如这样表述：在每秒1万次请求下，AVG控制在50ms以下，TP99控制在100ms以下。对于高并发系统，AVG和TP分位值必须同时要考虑。</p><p>​另外，从用户体验角度来看，200毫秒被认为是第一个分界点，用户感觉不到延迟，1秒是第二个分界点，用户能感受到延迟，但是可以接受。</p><h4 id="可用性指标">可用性指标</h4><p><code>可用性 = 正常运行时间 / 系统总运行时间</code></p><p>通常以几个9来描述。如3个9，表示99.9%，年故障时间就是8小时，平均日故障1.44分钟。</p><h4 id="可扩展性指标">可扩展性指标</h4><p>比如面对秒杀、热搜等突发流量，没时间改架构，因此最快的方式就是增加机器来线性提高系统的处理能力。</p><p>扩展性 = 性能提升比例 / 机器增加比例</p><p>理想的扩展能力是：资源增加几倍，性能提升几倍。</p><p>但是，服务的扩容会增大数据库的压力。因此，高扩展性需要考虑：服务集群、数据库、缓存和消息队列等中间件、负载均衡、带宽、依赖的第三方等。</p><h2 id="高并发的实践方案">高并发的实践方案</h2><h3 id="通用的设计方案">通用的设计方案</h3><h4 id="纵向扩展">纵向扩展</h4><p>它的目标是提升单机的处理能力：</p><ol><li>提升单机的硬件性能：加内存、加CPU核数、加存储等</li><li>提升单机的软件性能：用缓存减少IO次数，使用并发或者异步的方式增加吞吐量</li></ol><p>比如我们在秒杀项目中，使用Redis作为缓存</p><h4 id="横向扩展">横向扩展</h4><p>解决单机性能瓶颈，即集群部署来进一步提升并发能力。</p><ol><li><p>做好分层架构</p><p>比如秒杀系统，首先用Nginx做反向代理，负载均衡到多个业务服务器上，采用动静分离，引入CDN；使用Redis作为缓存等</p></li><li><p>各层进行水平扩展：无状态水平扩容，有状态做分片路由。业务集群通常能设计成无状态的，而数据库和缓存往往是有状态的，因此需要设计分区键做好存储分片，当然也可以通过主从同步、读写分离的方案提升读性能。</p></li></ol><h3 id="具体的实践方案">具体的实践方案</h3><blockquote><p>以下原文中的每一条方案，都值得深入的研究以及实际操作</p></blockquote><h4 id="高性能的实践方案"><strong>高性能的实践方案</strong></h4><p>1、集群部署，通过负载均衡减轻单机压力。</p><p>2、多级缓存，包括静态数据使用CDN、本地缓存、分布式缓存等，以及对缓存场景中的热点key、缓存穿透、缓存并发、数据一致性等问题的处理。</p><p>3、分库分表和索引优化，以及借助搜索引擎解决复杂查询问题。</p><p>4、考虑NoSQL数据库的使用，比如HBase、Redis等，但是团队必须熟悉这些组件，且有较强的运维能力。</p><p>5、异步化，将次要流程通过多线程、MQ、甚至延时任务进行异步处理。</p><p>6、限流，需要先考虑业务是否允许限流（比如秒杀场景是允许的），包括前端限流、Nginx接入层的限流、服务端的限流。</p><p>7、对流量进行削峰填谷，通过MQ承接流量。</p><p>8、并发处理，通过多线程将串行逻辑并行化。</p><p>9、预计算，比如抢红包场景，可以提前计算好红包金额缓存起来，发红包时直接使用即可。</p><p>10、缓存预热，通过异步任务提前预热数据到本地缓存或者分布式缓存中。</p><p>11、减少IO次数，比如数据库和缓存的批量读写、RPC的批量接口支持、或者通过冗余数据的方式干掉RPC调用。</p><p>12、减少IO时的数据包大小，包括采用轻量级的通信协议、合适的数据结构、去掉接口中的多余字段、减少缓存key的大小、压缩缓存value等。</p><p>13、程序逻辑优化，比如将大概率阻断执行流程的判断逻辑前置、For循环的计算逻辑优化，或者采用更高效的算法。</p><p>14、各种池化技术的使用和池大小的设置，包括HTTP请求池、线程池（考虑CPU密集型还是IO密集型设置核心参数）、数据库和Redis连接池等。</p><p>15、JVM优化，包括新生代和老年代的大小、GC算法的选择等，尽可能减少GC频率和耗时。</p><p>16、锁选择，读多写少的场景用乐观锁，或者考虑通过分段锁的方式减少锁冲突。上述方案无外乎从计算和 IO 两个维度考虑所有可能的优化点，需要有配套的监控系统实时了解当前的性能表现，并支撑你进行性能瓶颈分析，然后再遵循二八原则，抓主要矛盾进行优化。</p><h4 id="高可用的实践方案"><strong>高可用的实践方案</strong></h4><p>1、对等节点的故障转移，Nginx和服务治理框架均支持一个节点失败后访问另一个节点。</p><p>2、非对等节点的故障转移，通过心跳检测并实施主备切换（比如redis的哨兵模式或者集群模式、MySQL的主从切换等）。</p><p>3、接口层面的超时设置、重试策略和幂等设计。</p><p>4、降级处理：保证核心服务，牺牲非核心服务，必要时进行熔断；或者核心链路出问题时，有备选链路。</p><p>5、限流处理：对超过系统处理能力的请求直接拒绝或者返回错误码。</p><p>6、MQ场景的消息可靠性保证，包括producer端的重试机制、broker侧的持久化、consumer端的ack机制等。</p><p>7、灰度发布，能支持按机器维度进行小流量部署，观察系统日志和业务指标，等运行平稳后再推全量。</p><p>8、监控报警：全方位的监控体系，包括最基础的CPU、内存、磁盘、网络的监控，以及Web服务器、JVM、数据库、各类中间件的监控和业务指标的监控。</p><p>9、灾备演练：类似当前的“混沌工程”，对系统进行一些破坏性手段，观察局部故障是否会引起可用性问题。</p><p>高可用的方案主要从冗余、取舍、系统运维3个方向考虑，同时需要有配套的值班机制和故障处理流程，当出现线上问题时，可及时跟进处理。</p><h4 id="高扩展的实践方案"><strong>高扩展的实践方案</strong></h4><p>1、合理的分层架构：比如上面谈到的互联网最常见的分层架构，另外还能进一步按照数据访问层、业务逻辑层对微服务做更细粒度的分层（但是需要评估性能，会存在网络多一跳的情况）。</p><p>2、存储层的拆分：按照业务维度做垂直拆分、按照数据特征维度进一步做水平拆分（分库分表）。</p><p>3、业务层的拆分：最常见的是按照业务维度拆（比如电商场景的商品服务、订单服务等），也可以按照核心接口和非核心接口拆，还可以按照请求源拆（比如To C和To B，APP和H5）。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode56-合并区间</title>
      <link href="/2022/07/09/LeetCode56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
      <url>/2022/07/09/LeetCode56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="56-合并区间"><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h4><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><p>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p><hr><p>思路：先按照区间起始位置升序排序，然后逐个遍历，如果当前区间起始位置 &gt; 结果数组最后一个区间的结束位置，则不合并，直接加到结果数组；否则合并。</p><p>这里注意排序的使用：<code>Arrays.sort(intervals, (a1, a2) -&gt; a1[0] - a2[0]);</code></p><p>以及最后根据idx的长度使用<code>Arrays.copyOf</code>进行裁剪，注意接口参数是左闭右开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals, (a1, a2) -&gt; a1[<span class="number">0</span>] - a2[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[intervals.length][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] interval : intervals) &#123;</span><br><span class="line">            <span class="comment">// 结果数组为空，或者当前区间起始位置 &gt; 结果数组最后一个区间的结束位置，则不合并，直接加到结果数组</span></span><br><span class="line">            <span class="keyword">if</span> (idx == -<span class="number">1</span> || interval[<span class="number">0</span>] &gt; res[idx][<span class="number">1</span>]) &#123;</span><br><span class="line">                res[++idx] = interval;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 合并区间</span></span><br><span class="line">                res[idx][<span class="number">1</span>] = Math.max(res[idx][<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(res, idx + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题解和代码参考：<a href="https://leetcode.cn/problems/merge-intervals/solution/chi-jing-ran-yi-yan-miao-dong-by-sweetiee/">https://leetcode.cn/problems/merge-intervals/solution/chi-jing-ran-yi-yan-miao-dong-by-sweetiee/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode39-组合总和</title>
      <link href="/2022/07/03/LeetCode39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
      <url>/2022/07/03/LeetCode39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="39-组合总和"><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h4><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p>输入：candidates = [2,3,6,7], target = 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 = 7 。<br>仅有这两种组合。</p><hr><p>回溯的思路是每次用<code>target</code>减去选择的数，然后进行递归。当<code>target=0</code>表示找到了一种选择。</p><p>本题的难点是去除重复的。比如<code>target</code>为5时，选择2-3和选择3-2即是一种重复的选择。</p><p>去重的思路是按照<code>candidate</code>数组的下标，确定起始下标i，且只能选择i和i后面的树，这样就不会出现选择3后再选择2。</p><p>代码思路参考<a href="https://leetcode.cn/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">weiwei哥的题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, target, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> candidates 候选数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin      搜索起点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target     每减去一个元素，目标值变小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path       从根结点到叶子结点的路径，是一个栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res        结果集列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> begin, <span class="type">int</span> target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates, i, target - candidates[i], path, res);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode32-最长有效括号</title>
      <link href="/2022/07/02/LeetCode32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
      <url>/2022/07/02/LeetCode32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="32-最长有效括号"><a href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号</a></h4><p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p>示例 1：</p><p>输入：s = “(()”<br>输出：2<br>解释：最长有效括号子串是 “()”<br>示例 2：</p><p>输入：s = “)()())”<br>输出：4<br>解释：最长有效括号子串是 “()()”</p><hr><p>感觉动态规划的题，核心就是找到状态转移的方差，一个是定义dp[i]，一个是如何根据之前的结果推理出dp[i]的表达式。</p><p>对于数组的题目，dp[i]的定义很多都是以i结尾的最优解是啥，然后再推理dp[i]的表达式。</p><p>对于这题，我们定义dp[i]表示以i结尾的最长有效括号的子串长度。</p><p>根据题意，我们假设：</p><ul><li><p>当<code>s[i] = '('</code>时，dp[i]必然等于0，因此不必讨论。</p></li><li><p>当<code>s[i] = ')'</code>时：</p><ul><li>如果<code>s[i-1] = '('</code>，那么s[i]就必定和s[i - 1]配对，那么很容易得出这种情况的表达式：<code>dp[i] = dp[i - 2] + 2</code></li><li>如果<code>s[i-1] = ')'</code>，dp[i-1]表示以s[i - 1]结尾的最长有效括号子串，那么s[i]有可能和<code>s[i - dp[i - 1] - 1]</code>这个字符匹配，即如果<code>s[i - dp[i - 1] - 1]</code>为<code>(</code>，那么可以得到<code>dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2]</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// dp[i]表示以i结尾的最长有效括号</span></span><br><span class="line">        <span class="comment">// 若s[i]为(，dp[i] = 0</span></span><br><span class="line">        <span class="comment">// 若s[i]为)，</span></span><br><span class="line">        <span class="comment">//     s[i-1]为(，那么dp[i] = dp[i - 2] + 2</span></span><br><span class="line">        <span class="comment">//     s[i-1]为)，并且s[i - dp[i-1] - 1]为(，那么dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2];</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>; </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) - <span class="number">2</span> &gt;= <span class="number">0</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = Math.max(ans, dp[i]);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode20-有效的括号</title>
      <link href="/2022/06/26/LeetCode20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
      <url>/2022/06/26/LeetCode20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="20-有效的括号"><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h4><p>给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，‘]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><hr><p>思路比较简单，就是用栈。</p><blockquote><p>这里用map存了括号的配对，这里在new的时候进行了初始化赋值，可以记住这个用法。这里的双<code>&#123;&#125;</code>是用的匿名内部类，第一个括号为匿名内部类，第二个括号为实例初始化块。</p><p>这种写法代码比较简单，但执行效率比普通初始化低。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Character,Character&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Character&gt;()&#123;&#123;</span><br><span class="line">        put(<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>); put(<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;[&#x27;</span>); put(<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] c = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c[i])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != map.get(c[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(c[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode15-三数之和</title>
      <link href="/2022/06/25/LeetCode15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2022/06/25/LeetCode15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="15-三数之和"><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h4><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><p>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]</p><hr><p>思路比较简单：双指针，从两边开始，和两数之和类似，主要记录一下实现的一些细节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= len - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果第一个数都大于0了，直接break</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    <span class="comment">// 跳过相同的值，去重</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要记住<code>Arrays.asList()</code>这个接口的用法</li><li>注意<strong>去重</strong>的细节</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秒杀项目整理</title>
      <link href="/2022/06/25/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E6%95%B4%E7%90%86/"/>
      <url>/2022/06/25/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、基础秒杀项目概述">一、基础秒杀项目概述</h2><h3 id="1-项目架构">1. 项目架构</h3><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/1-架构图.PNG" style="zoom: 80%;" /><p>接入层模型（View Object）：与前端页面对接的模型，用于前端页面的展示，是一个聚合模型。</p><p>业务层（Domain Object）：领域模型，是业务的核心模型，拥有完整的生命周期，是贫血模型。和业务相关，因此是<strong>最先设计</strong>的。</p><p>数据层（Data Object）：数据模型，同数据库映射，用以ORM方式操作数据库的模型。</p><blockquote><p>贫血模型：对应的Domain Model只包含基础的属性、get、set方法，不包含具体的业务逻辑。而业务逻辑则放在调用贫血模型的service中。</p><p>这种设计模式其实是和面向对象的思想背道而驰的，它是一种面向过程的思想。它破坏的面向对象的封装性。面向对象主张将数据和行为绑定在一起，对外提供接口。</p><p>这里项目中采用贫血模型可能因为只有秒杀业务逻辑，相对简单，开发迅速。对于复杂的业务逻辑，则需要更完善的设计，并采用充血模型。</p></blockquote><h3 id="2-对象、模型关系">2. 对象、模型关系</h3><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/2-模型图.PNG" style="zoom:80%;" /><p>图中的三层对应了上述的三种模型。并且可以看到模型间进行了各种组合/聚合。</p><p>(1) 商品模型ItemModel组合了数据库中的商品数据表ItemDO和库存数据表ItemStockDO，并且如果该商品在某个秒杀活动中，他就会和秒杀活动模型PromoModel聚合成秒杀商品模型，最后将这两个聚合成的模型组合成ItemVO给前端展示。</p><p>(2) 用户模型UserModel包含了用户数据表和用户密码表。这里将用户数据和用户密码进行分表设计，因为用户密码可能存放于加密机或者其他数据库中，其次除了登录、注册等操作之外，其他用户相关的操作都用不到密码，因此在接口调用UserModel的时候，可以减少一次数据库的查询，并且可以节省表空间。</p><blockquote><p><strong>补充用户基本信息和密码分表设计的原因：</strong></p><ul><li>性能方面：登录时只需要用户Id和密码，增加查询的效率。复杂的登录系统可能还有登录IP地址、上次登录时间、登录设备等，也可能有各种第三方登录的授权信息，如果和用户基础信息放一个表，会显得非常臃肿，后期添加新的登录方式也很难维护</li><li>安全方面：防止查询用户信息的时候，查到用户密码；防止SQL注入。</li></ul></blockquote><p>(3) 我们对商品数据和库存数据也进行了分表，因为库存的操作是非常耗时耗性能的，库存交易时，会对库存加<strong>行锁</strong>进行减库存。我们将库存表分出去后，如果后期对商品的库存进行优化时，更加方便。比如对同一个商品的itemId号模10，分到10个不同的数据库中，以减少单个数据库性能的消耗，提高并发性。</p><blockquote><p><strong>库存表的优化</strong>也可以根据库存量除以10，分到10条记录中，这样也可以减少数据库性能消耗，相当于负载均衡到10条记录上。</p></blockquote><h3 id="3-类图">3. 类图</h3><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/3-类图.PNG" style="zoom:80%;" /><h2 id="二、各模块流程">二、各模块流程</h2><h2 id="三、分布式部署">三、分布式部署</h2><p>nginx反向代理，负载均衡；分布式会话管理；使用redis实现分布式会话管理；</p><h3 id="3-1-Java应用程序">3.1 Java应用程序</h3><p>部署相对简单，在对应服务器安装<code>jdk</code>，在服务器上编写<code>application.properties</code>配置文件，该配置文件会覆盖<code>SpringBoot</code>内的配置，因此可以根据不同的服务器配置不同的属性。最后通过<code>deploy.sh</code>脚本启动应用服务器。</p><p><code>deploy.sh</code>脚本实例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -Xms400m -Xmx400m -XX:NewSize=200m -jar miaosha.jar --spring.config.addition-location=/var/www/miaosha/application.properties</span><br></pre></td></tr></table></figure><h3 id="3-2-MySQL部署">3.2 MySQL部署</h3><p>安装相关依赖，需要注意的点是数据库远程开放端口连接，简单说就是开放ip白名单，只有你的应用服务器ip能访问数据库，以保证安全性。</p><h3 id="3-3-nginx部署">3.3 nginx部署</h3><p>nginx可以作为web服务器、动静分离服务器、反向代理服务器等。</p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/4-nginx.PNG" style="zoom:80%;" /><ul><li>动静分离：在实现反向代理的时候，如果是静态资源，就直接在nginx的静态资源路径去读取，无需访问后端服务器；</li></ul><p>项目里采用的是nginx的openResty框架。</p><blockquote><p>OpenResty是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。<br>OpenResty通过汇聚各种设计精良的 Nginx 模块（主要由 OpenResty 团队自主开发），从而将 Nginx 有效地变成一个强大的通用 Web 应用平台。这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。<br>OpenResty® 的目标是让你的Web服务直接跑在 Nginx 服务内部，充分利用 Nginx 的非阻塞 I/O 模型，不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。</p></blockquote><h4 id="3-3-2-master-worker模型">3.3.2 master-worker模型</h4><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/5-nginx-master-worker2.PNG" alt=""></p><p>nginx的进程模型由一个master进程和多个相互独立的worker进程组成，并且这些worker进程都是单线程的。</p><p>启动nginx服务器后，nginx首先会创建一个master进程，然后会根据配置的<code>worker process</code>的数量来启动相应数量的工作进程。这里的master进程和worker进程式父子进程的关系，即worker进程是由master进程fork出来的。由于这种关系，master进程就可以管理所有worker进程的内存空间。</p><p>master进程用于管理worker进程，而worker进程才是用于处理客户端连接的。在启动nginx后，master会创建一个socket的文件句柄，用于listen在nginx的外部服务端口上面。这时master进程就会采用epoll的多路复用模型。当客户端访问外部服务端口，会发送http请求，然后进行tcp三次握手，会向端口发起socket的connect操作，这时epoll模型会产生对应的回调方法，nginx的master进程是不会处理这个accept操作的，而是由worker进程去处理。</p><p>那由哪个worker进程去处理呢？nginx在内存中有一个accept mutex，类似于互斥锁，那么worker进程会去争抢这个互斥锁，抢到锁的那个worker进程就去处理这个连接，并且以后对应这个connect的socket的cend和receive都由这个worker进程去负责。</p><p>这也是nginx高效的原因之一。</p><h4 id="3-3-3-nginx平滑重启的原理">3.3.3 nginx平滑重启的原理</h4><p>master进程发送信号给worker进程，worker进程将所有的socket句柄交给master管理，然后master会读取配置文件，创建一个新的worker进程，再将之前的socket句柄交给新的worker进程管理。</p><h3 id="3-4-分布式会话（重点）">3.4 分布式会话（重点）</h3><h4 id="3-4-1-为什么要分布式会话？">3.4.1 为什么要分布式会话？</h4><p>单体的实现无法应用于分布式场景。比如：用户在服务器A进行登录，下一次的路由请求又被分到服务器B上，那么他对应的sessionId就不存在了。</p><h4 id="3-4-2-解决方案">3.4.2 解决方案</h4><ul><li><p>nginx的负载均衡策略为ip_hash</p><p>同一个ip会被分到同一个目标服务器上，问题是如果目标服务器宕机或重启，session就会丢失。</p></li><li><p>将session集中存储到redis中（常用策略）</p></li></ul><h4 id="3-4-3-实现">3.4.3 实现</h4><p>这里简单描述一下实现。导包安装啥的不说了。需要注意的是redis的序列化方式，默认是JDK的序列化方式，直接用会报错。一种方案是我们的模型需要实现Serializable接口；另一种是修改redis的序列化方式，改为JSON或者String。</p><p>我们可以使用UUID作为token，记住设置key的过期时间，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">uuidToken</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">redisTemplate.opsForValue().set(uuidToken, userModel);</span><br><span class="line">redisTemplate.expire(uuidToken, <span class="number">1</span>, TimeUnit.HOURS); <span class="comment">// 设置过期时间</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode5-最长回文子串</title>
      <link href="/2022/06/24/LeetCode5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2022/06/24/LeetCode5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="5-最长回文子串"><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h4><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><hr><h2 id="1-动态规划解">1. 动态规划解</h2><p><strong>定义状态</strong>：<code>dp[i][j]</code>表示子串<code>s[i...j]</code>是否为回文子串</p><p><strong>状态转移方程</strong>：<code>dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]</code></p><p>两个指针<code>i</code>和<code>j</code>分别 代表区间的两端，当两端相等时，<code>s[i...j]</code>是否为回文子串 就取决于<code>s[i+1...j-1]</code></p><p>理清楚上面的转移方程代码思路就比较清晰了。</p><p>时空复杂度都为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="type">char</span>[] charArr = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (charArr[i] != charArr[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// j - 1 - (i + 1) + 1 &lt; 2，中间不够成区间</span></span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新最大长度</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-中心扩散法">2. 中心扩散法</h2><p>遍历每个下标，以每个下标为中心，向两边扩散，找到以当前下标为中心的最长回文子串。</p><p>需要分别计算奇数和偶数的情况。奇数以中心字符向两边扩散，偶数时回文中心位于两个字符之间。</p><p>详细看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// [起始位置， 长度]</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] odd = centerSpread(s, i, i);</span><br><span class="line">            <span class="type">int</span>[] even = centerSpread(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span>[] max = odd[<span class="number">1</span>] &gt; even[<span class="number">1</span>] ? odd : even;</span><br><span class="line">            <span class="keyword">if</span> (max[<span class="number">1</span>] &gt; maxLen) &#123;</span><br><span class="line">                res = max;</span><br><span class="line">                maxLen = max[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(res[<span class="number">0</span>], res[<span class="number">0</span>] + res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] centerSpread(String s, <span class="type">int</span> left, <span class="type">int</span> right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt;= len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left + <span class="number">1</span>, right - <span class="number">1</span> - left&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>空间为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><hr><p>参考题解：<a href="https://leetcode.cn/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/">https://leetcode.cn/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode4-寻找两个正序数组的中位数</title>
      <link href="/2022/06/23/LeetCode4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2022/06/23/LeetCode4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="4-寻找两个正序数组的中位数"><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h4><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><hr><h2 id="一、归并算法">一、归并算法</h2><p>合并两个有序数组，再根据长度直接得到中位数。时间复杂度不符合要求。</p><p>其实可以不用全部合并完，合并到中位数的位置即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[len1 + len2];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len1 &amp;&amp; j &lt; len2) &#123;</span><br><span class="line">            tmp[k++] = nums1[i] &lt; nums2[j] ? nums1[i++] : nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len1) &#123;</span><br><span class="line">            tmp[k++] = nums1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; len2) &#123;</span><br><span class="line">            tmp[k++] = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k % <span class="number">2</span> == <span class="number">0</span> ? (tmp[(k - <span class="number">1</span>) / <span class="number">2</span>] + tmp[k / <span class="number">2</span>]) / <span class="number">2.0</span> : tmp[k / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、二分搜索">二、二分搜索</h2><p>主要思路：用分割线分割两个数组，保证nums1中分割线左边的第一个元素小于等于nums2中分割线右边的第一个元素；nums1中分割线右边的第一个元素大于等于nums2中分割线左边的第一个元素。</p><p>简单来说就是两个数组分割线左边的元素小于等于分割线右边的元素。</p><p>我们只需要对长度较小的数组进行二分即可。另一个数组对应的分割线位置可以通过计算得到。</p><p>如下图：分割线左边的8大于右边的6，因此分割线偏左，需要向右调整。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tov7ol30j20ww0ci3z9.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">            <span class="type">int</span>[] t = nums1;</span><br><span class="line">            nums1 = nums2;</span><br><span class="line">            nums2 = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分割线左边的所有元素的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalLeft</span> <span class="operator">=</span> m + (n - m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 nums1 的区间 [0, m] 里查找恰当的分割线，</span></span><br><span class="line">        <span class="comment">// 使得 nums1[i - 1] &lt;= nums2[j] &amp;&amp; nums2[j - 1] &lt;= nums1[i]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// i表示nums1中分割线右边的第一个元素，j表示nums2中分割线右边的第一个元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> totalLeft - i;</span><br><span class="line">            <span class="comment">// 说明nums1中分割线偏右，需调整，下一轮搜索区间：[left, i - 1]</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] &gt; nums2[j]) &#123;</span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间：[i, right]</span></span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> totalLeft - i;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">nums1LeftMax</span> <span class="operator">=</span> i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">nums1RightMin</span> <span class="operator">=</span> i == m ? Integer.MAX_VALUE : nums1[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">nums2LeftMax</span> <span class="operator">=</span> j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">nums2RightMin</span> <span class="operator">=</span> j == n ? Integer.MAX_VALUE : nums2[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((m + n) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums1LeftMax, nums2LeftMax);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin)) * <span class="number">0.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考题解：<a href="https://suanfa8.com/binary-search/solutions/find-index/0004-median-of-two-sorted-arrays/">https://suanfa8.com/binary-search/solutions/find-index/0004-median-of-two-sorted-arrays/</a></p><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/">https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring随笔</title>
      <link href="/2022/06/16/Spring%E9%9A%8F%E7%AC%94/"/>
      <url>/2022/06/16/Spring%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>Spring随笔</h1><blockquote><p>视频是黑马的SSM教程，<a href="https://www.bilibili.com/video/BV1Fi4y1S7ix?p=43&amp;spm_id_from=pageDriver&amp;vd_source=9636809faa9be7bdebfcad6a250ff4b6">传送门</a>，记录些知识点，主要是<strong>概念</strong>及<strong>使用</strong>，本篇不涉及源码相关。</p></blockquote><h2 id="1-Spring核心概念">1. Spring核心概念</h2><p>Spring核心概念这部分内容中主要包含<strong>IOC/DI</strong>、<strong>IOC容器</strong>和<strong>Bean</strong>。</p><h3 id="1-1-提出概念前，项目中的问题？">1.1 提出概念前，项目中的问题？</h3><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/1-1.PNG" alt=""></p><p>(1)业务层需要调用数据层的方法，就需要在业务层new数据层的对象</p><p>(2)如果数据层的实现类发生变化，那么业务层的代码也需要跟着改变，发生变更后，都需要进行编译打包和重部署</p><p>(3)所以，现在代码在编写的过程中存在的问题是：<strong>耦合度偏高</strong></p><p>针对这个问题，该如何解决呢?</p><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/1-2.PNG" alt=""></p><p>我们就想，如果能把框中的内容给去掉，不就可以降低依赖了么，但是又会引入新的问题，去掉以后程序能运行么?</p><p>答案肯定是不行，因为bookDao没有赋值为Null，强行运行就会出空指针异常。</p><p>所以现在的问题就是，业务层不想new对象，运行的时候又需要这个对象，该咋办呢?</p><p>针对这个问题，Spring就提出了一个解决方案:</p><ul><li><strong>使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象</strong></li></ul><p>这种实现思就是Spring的一个核心概念</p><h3 id="1-2-IOC、IOC容器、Bean、DI概念">1.2 IOC、IOC容器、Bean、DI概念</h3><h4 id="1-2-1-IOC（Inversion-of-Control）控制反转">1.2.1 IOC（Inversion of Control）控制反转</h4><p>(1) 什么是控制反转呢？</p><p>使用对象时，由主动new产生对象转换为<strong>由外部提供对象</strong>，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。</p><ul><li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li><li><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li></ul><p>(2) IOC容器的作用以及内部存放的是什么?</p><ul><li>IOC容器类似于一个工厂，负责对象的创建、初始化等一系列工作</li><li>被创建或被管理的对象在IOC容器中统称为<strong>Bean</strong></li><li>IOC容器中放的就是一个个的Bean对象</li></ul><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p><blockquote><p><a href="https://javadoop.com/post/spring-ioc">IOC源码阅读</a></p></blockquote><h4 id="1-2-2-DI（Dependency-Injection）依赖注入">1.2.2 DI（Dependency Injection）依赖注入</h4><p>(1) 什么是依赖注入呢?</p><p>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入。</p><p>(2) IOC容器中的Bean需要根据具体的业务来建立关系</p><blockquote><p>IOC和DI的目的就是充分解耦</p></blockquote><ul><li>使用IOC容器管理bean（IOC)</li><li>在IOC容器内将有依赖关系的bean进行关系绑定（DI）</li><li>最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依 赖关系.</li></ul><h4 id="1-2-3-小结">1.2.3 小结</h4><p>(1) 什么IOC/DI思想?</p><ul><li>IOC:控制反转，控制反转的是对象的创建权</li><li>DI:依赖注入，绑定对象与对象之间的依赖关系</li></ul><p>(2) 什么是IOC容器?</p><p>​Spring创建了一个容器用来存放所创建的对象，这个容器就叫IOC容器</p><p>(3) 什么是Bean?</p><p>​容器中所存放的一个个对象就叫Bean或Bean对象</p><h3 id="1-3-IOC相关">1.3 IOC相关</h3><h4 id="1-3-1-bean的基础配置">1.3.1 bean的基础配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;bean的唯一标识&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;bean的全路径类名&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">scope</span>=<span class="string">&quot;bean的作用范围，有Singleton（默认）和prototype&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">&quot;bean的别名&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-2-bean的实例化">1.3.2 bean的实例化</h4><p>Spring的IOC实例化对象的三种方式：</p><ul><li><strong>构造方法</strong>：底层用的是反射</li><li>静态工厂</li><li>实例工厂<ul><li><strong>FactoryBean</strong></li></ul></li></ul><p>1.实例工厂的步骤：</p><p>​(1) 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.UserDaoFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;userFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>​(2) 创建实例化工厂对象，对应第一行配置；调用对象中的方法来创建bean，对应第二行的配置</p><p>​其中，factory-bean是工厂的实例对象；factory-method是工厂对象中的具体创建对象的方法名</p><p>2.FactoryBean的步骤：</p><p>实现FactoryBean接口，重写接口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; &#123;</span><br><span class="line"><span class="comment">// 代替原始实例工厂中创建对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 返回所创建类的Class对象</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">    <span class="keyword">return</span> UserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.UserDaoFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>FactoryBean接口有三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被重写后，会创建对象并返回</span></span><br><span class="line">T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被重写后，返回被创建类的Class对象</span></span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-3-3-bean的生命周期">1.3.3 bean的生命周期</h4><ul><li>Bean 容器找到配置文件中 Spring Bean 的定义。</li><li>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。</li><li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li><li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li><li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li><li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li><li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li><li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li><li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ul><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/1-3.jpg" alt="bean的生命周期"></p><h4 id="1-3-4-核心容器总结">1.3.4 核心容器总结</h4><ul><li><p>容器相关</p><ul><li>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载</li><li>ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载</li><li>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能</li><li>ApplicationContext接口常用初始化类：ClassPathXmlApplicationContext(常用)、FileSystemXmlApplicationContext</li></ul></li><li><p>bean相关</p><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/1-4.PNG" alt=""></p></li></ul><h3 id="1-4-DI相关">1.4 DI相关</h3><p>两种注入方式：setter注入和构造器注入；两种数据类型：简单类型和引用类型。</p><h4 id="1-4-1-setter注入">1.4.1 setter注入</h4><p>对于引用数据类型使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于简单数据类型使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-4-2-构造器注入">1.4.2 构造器注入</h4><p>对于引用类型：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于简单类型：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>两个<code>constructor-arg</code>的顺序可以任意。</p><p>如果参数类型重复，可以通过配置index属性，来确认顺序：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-4-3-依赖注入小结">1.4.3 依赖注入小结</h4><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/1-5.PNG" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Sprint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer49-丑数</title>
      <link href="/2022/06/16/%E5%89%91%E6%8C%87Offer49-%E4%B8%91%E6%95%B0/"/>
      <url>/2022/06/16/%E5%89%91%E6%8C%87Offer49-%E4%B8%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h4 id="剑指-Offer-49-丑数"><a href="https://leetcode.cn/problems/chou-shu-lcof/">剑指 Offer 49. 丑数</a></h4><h4 id="264-丑数-II"><a href="https://leetcode.cn/problems/ugly-number-ii/">264. 丑数 II</a></h4><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><p><strong>示例:</strong></p><blockquote><p>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</p></blockquote><hr><p><a href="https://leetcode.cn/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/">参考题解</a></p><p>丑数递推性质：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>丑数</mtext><mo>=</mo><mtext>某较小丑数</mtext><mo>×</mo><mtext>某因子</mtext></mrow><annotation encoding="application/x-tex">丑数 = 某较小丑数 \times 某因子</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">丑数</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">某较小丑数</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">某因子</span></span></span></span></p><p>为了不遗漏，我们用三个游标a、b、c分别标记哪些数乘了2、乘了3和乘了5。如a则表示a前面的a-1个数都乘过2了，下一个应该乘2的数应该是a。</p><p>那么新的丑数应该是<code>a * 2</code>、<code>b * 3</code>、<code>c * 5</code>中最小的那个数</p><p>丑数递推公式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>a</mi></msub><mo>×</mo><mn>2</mn><mo separator="true">,</mo><msub><mi>x</mi><mi>b</mi></msub><mo>×</mo><mn>3</mn><mo separator="true">,</mo><msub><mi>x</mi><mi>c</mi></msub><mo>×</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x_{n+1}=min(x_a×2,x_b×3,x_c×5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mclose">)</span></span></span></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> dp[a] * <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> dp[b] * <span class="number">3</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n5</span> <span class="operator">=</span> dp[c] * <span class="number">5</span>;</span><br><span class="line">            dp[i] = Math.min(Math.min(n2, n3), n5);</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == n2) a++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == n3) b++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == n5) c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考题解的高赞评论也有详细的解释</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer37-序列化二叉树</title>
      <link href="/2022/06/15/%E5%89%91%E6%8C%87Offer37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/06/15/%E5%89%91%E6%8C%87Offer37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="剑指-Offer-37-序列化二叉树"><a href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></h4><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>提示：输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><hr><p>思路：采用dfs遍历、使用StringBuilder存储，每个节点使用<code>,</code>分隔，遇到null节点使用<code>#</code>标识。注意反序列化时，左右节点的顺序要与序列化dfs时一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        dfs(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;#&quot;</span>).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(root.val).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        dfs(root.left, sb);</span><br><span class="line">        dfs(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] ss = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : ss) &#123;</span><br><span class="line">            queue.offer(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(queue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">dfs</span><span class="params">(Queue&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (node.equals(<span class="string">&quot;#&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(node));</span><br><span class="line">        root.left = dfs(queue);</span><br><span class="line">        root.right = dfs(queue);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis随笔</title>
      <link href="/2022/06/10/Redis%E9%9A%8F%E7%AC%94/"/>
      <url>/2022/06/10/Redis%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考黑马的redis入门到实战视频，记录一些知识点</p><p>视频在b站 -&gt; <a href="https://www.bilibili.com/video/BV1cr4y1671t?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=9636809faa9be7bdebfcad6a250ff4b6">传送门</a></p></blockquote><hr><h2 id="一、基础">一、基础</h2><h3 id="1-redis特征">1. redis特征</h3><ul><li>键值(key-value)型，value支持多种不同数据类型，功能丰富</li><li><strong>单线程</strong>，每个命令具备原子性</li><li>低延迟，速度快（基于<strong>内存</strong>、IO多路复用、良好的编码）</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li></ul><h3 id="2-redis的常用指令">2. redis的常用指令</h3><h4 id="2-1-通用指令">2.1 通用指令</h4><ul><li><p>KEYS：查看符合模板的所有key</p></li><li><p>DEL：删除一个指定的key</p></li><li><p>EXISTS：判断key是否存在</p></li><li><p>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</p></li><li><p>TTL：查看一个KEY的剩余有效期</p></li></ul><p>通过help [command] 可以查看一个命令的具体用法：</p><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/1-1.PNG" alt=""></p><h4 id="2-2-String相关指令">2.2 String相关指令</h4><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><blockquote><p>对于自增指令，字符串必须符合<code>int</code>或者<code>float</code>的形式</p></blockquote><p>redis中的key允许有层级结构，可以通过<code>:</code>隔开，如下图所示：</p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/1-2.png" style="zoom: 67%;" /><h4 id="2-4-Hash常见指令">2.4 Hash常见指令</h4><ul><li>HSET key field value：添加或者修改hash类型key的field的值</li><li>HGET key field：获取一个hash类型key的field的值</li><li>HMSET：批量添加多个hash类型key的field的值</li><li>HMGET：批量获取多个hash类型key的field的值</li><li>HGETALL：获取一个hash类型的key中的所有的field和value</li><li>HKEYS：获取一个hash类型的key中的所有的field</li><li>HVALS：获取一个hash类型的key中的所有的value</li><li>HINCRBY:让一个hash类型key的字段值自增并指定步长</li><li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li></ul><p>例如：</p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/1-3.png" style="zoom:67%;" /><h4 id="2-5-List常见指令">2.5 List常见指令</h4><p>redis的list与Java中的LinkedList类似，可以看成一个双向链表。</p><ul><li>LPUSH key  element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key  element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/1-4-List.png" style="zoom:67%;" /><h4 id="2-6-Set常见指令">2.6 Set常见指令</h4><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li><li>SDIFF key1 key2 … ：求key1与key2的差集</li><li>SUNION key1 key2 …：求key1和key2的并集</li></ul><h4 id="2-7-SortedSet">2.7 SortedSet</h4><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>特性：可排序、元素不重复、查询速度快</p><p>一般用于实现排行榜的功能。</p><p>常见指令：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li></ul><blockquote><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可</p></blockquote><h3 id="3-Jedis">3. Jedis</h3><p>以redis命令作为方法名称，<strong>线程不安全</strong>，多线程情况下需要基于连接池来使用。</p><h4 id="3-1-demo">3.1 demo</h4><p>首先配置坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接写一个测试类，来调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lucky.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 建立连接</span></span><br><span class="line">        jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.153.6&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 2. 设置密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 选择库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 存入数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;jedis:test:user:1&quot;</span>, <span class="string">&quot;马里奥&quot;</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;jedis:test:user:1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 存入数据</span></span><br><span class="line">        jedis.hset(<span class="string">&quot;jedis:test:user:2&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;库巴&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;jedis:test:user:2&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;12&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取</span></span><br><span class="line">        Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;jedis:test:user:2&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/1-5-jedis.png" style="zoom:67%;" /><h4 id="3-2-jedis的连接池">3.2 jedis的连接池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lucky.jedis.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>); <span class="comment">// 最大连接数</span></span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>); <span class="comment">// 最大空闲数</span></span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>); <span class="comment">// 最小空闲连接数</span></span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 创建连接池对象</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig,</span><br><span class="line">                <span class="string">&quot;192.168.153.6&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedis = JedisConnectionFactory.getJedis();</span><br></pre></td></tr></table></figure><h3 id="4-SpringDataRedis">4. SpringDataRedis</h3><p>直接看demo吧</p><p>首先加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后写配置，这里用的yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.153</span><span class="number">.6</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment"># 最大连接</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment"># 最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment"># 最小空闲连接</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">100</span> <span class="comment"># 连接等待时间</span></span><br></pre></td></tr></table></figure><p>然后写测试类：</p><p>注意在测试前修改了redisTemplate的<strong>序列化策略</strong>。它默认使用的是JDK的序列化策略，因此在添加数据时会出现乱码。因此这里将RedisTemplate的序列化策略修改为String的序列化策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lucky7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lucky7.redis.config.redis.pojo.User;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringRedisDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入String</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;牜牜&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user2&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;路易&quot;</span>, <span class="number">18</span>));</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user: &quot;</span> + user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RedisTemplate配置类：</p><p>这里我们配置key使用string序列化，value使用JSON序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lucky7.redis.config.redis.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">genericJackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置KEY的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/1-5-redisTemplate序列化.png" style="zoom:67%;" /><p>我们看到写入JSON的同时，写入了<code>class</code>属性，因此反序列化时可以将value转化成USER对象。</p><p>缺点是<strong>占用空间变多</strong>，方案是value也采用string序列化策略。</p><p>Spring默认提供了StringRedisTemplate类，可以直接用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lucky7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.lucky7.redis.config.redis.pojo.User;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringRedisDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JSON工具</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testStringTemplate</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;鸣人&quot;</span>, <span class="number">88</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonObj</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user3&quot;</span>, jsonObj);</span><br><span class="line">        <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user3&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(val, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>补充乱码原因：</p><p>1、redis默认序列化器：JdkSerializationRedisSerializer<br>2、redis默认序列化器底层使用ByteArrayOutputStream流对key进行序列化操作<br>3、序列化key的过程中ByteArrayOutputStream转为ObjectOutputStream<br>4、ObjectOutputStream构造方法中将传入的输出流做了一个writeStreamHeader()操作，writeStreamHeader()调用Bits.putShort方法修改了流中原本为空的byte数组中的几位字节，导致原本为空的流有值<br>参考链接：<a href="https://blog.csdn.net/qq_44872787/article/details/122562595">https://blog.csdn.net/qq_44872787/article/details/122562595</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer39-数组中出现次数超过一半的数字</title>
      <link href="/2022/06/10/%E5%89%91%E6%8C%87Offer39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2022/06/10/%E5%89%91%E6%8C%87Offer39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1:</strong></p><p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2</p><hr><p>思路：采用摩尔投票法。思想为票数正负抵消。时间复杂度为O(n)，空间为O(1)。</p><p>简单理解：最坏情况拿众数和其他数一换一，最终剩下的肯定是众数。</p><p>具体的证明可以看参考题解。</p><p>实现：遍历时，两个数不同则票数-1，两个数相同则票数+1，票数为0时，则更新统计的数字(votes)</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">votes</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (votes == <span class="number">0</span>) &#123;</span><br><span class="line">                res = num;</span><br><span class="line">            &#125;</span><br><span class="line">            votes += num == res ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验证res是否为众数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            cnt += num == res ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt; len / <span class="number">2</span> ? res : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考<a href="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/solution/mian-shi-ti-39-shu-zu-zhong-chu-xian-ci-shu-chao-3/">题解</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer56-1-数组中数字出现的次数</title>
      <link href="/2022/06/09/%E5%89%91%E6%8C%87Offer56-1-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
      <url>/2022/06/09/%E5%89%91%E6%8C%87Offer56-1-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h4><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><strong>示例 1：</strong></p><p>输入：nums = [4,1,4,6]<br>输出：[1,6] 或 [6,1]</p><hr><p>思路：直接参考<a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/jian-zhi-offer-56-i-shu-zu-zhong-shu-zi-tykom/">题解</a></p><p>假设只出现一次的两个数分别为x和y</p><ol><li>首先将数组中所有数进行异或，因为两个相同的数异或后为0，因此最终的结果就是x和y的异或值</li><li>我们找到第一步结果中二进制的一个1位，该位的值为1，说明x和y在该位的值不同</li><li>我们循环数组，将数组进行分组，将x和y分在不同组。分组的标准就是第二步中的那一位1。将组内的数进行异或，因为只有x和y出现一次，因此两组异或的结果分别就是所求的x和y。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumbers(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 求 x ^ y 的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            n ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到x ^ y的二进制值中的1位，这一位表示x和y在该位上值不同，用于分组</span></span><br><span class="line">        <span class="keyword">while</span> ((n &amp; m) == <span class="number">0</span>) &#123;</span><br><span class="line">            m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历nums进行分组，x和y被分在不同组，那么两组异或的结果就是所求的x和y</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; m) != <span class="number">0</span>) &#123;</span><br><span class="line">                x ^= num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                y ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode110-平衡二叉树</title>
      <link href="/2022/06/09/LeetCode110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/06/09/LeetCode110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="110-平衡二叉树"><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><hr><p>思路：定义一个深度优先辅助方法，返回值为当前节点的深度，如果返回值为-1表示以当前节点为根的子树不是平衡二叉树。</p><p>返回-1的条件有三个：左子树返回-1，右子树返回-1，或者左右子树高度差大于1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> dfs(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> dfs(root.right);</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span> || right == -<span class="number">1</span> || Math.abs(left - right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer40-最小的k个数</title>
      <link href="/2022/06/09/%E5%89%91%E6%8C%87Offer40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
      <url>/2022/06/09/%E5%89%91%E6%8C%87Offer40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="剑指-Offer-40-最小的k个数"><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h4><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>示例 1：</strong></p><p>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]</p><hr><p>思路：我们的目标是找到递增排序后的第k个数。可以采用快排的思想，快排的partition操作会确定pivot在排序后的位置，将这个位置index与k进行比较，如果等于k，则返回[0, index]的数；如果index &lt; k，则在右半边继续找；如果index &gt; k，则在左半边找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivotIdx</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">            <span class="keyword">if</span> (pivotIdx == k - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Arrays.copyOf(arr, pivotIdx + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pivotIdx &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">                left = pivotIdx + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = pivotIdx - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIdx</span> <span class="operator">=</span> random.nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">        swap(arr, left, randomIdx);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">le</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ge</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (le &lt;= ge &amp;&amp; arr[le] &lt; pivot) &#123;</span><br><span class="line">                le++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (le &lt;= ge &amp;&amp; arr[ge] &gt; pivot) &#123;</span><br><span class="line">                ge--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (le &gt;= ge) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, le, ge);</span><br><span class="line">            le++;</span><br><span class="line">            ge--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, left, ge);</span><br><span class="line">        <span class="keyword">return</span> ge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 分治 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 快排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer16-数值的整数次方</title>
      <link href="/2022/06/07/%E5%89%91%E6%8C%87Offer16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
      <url>/2022/06/07/%E5%89%91%E6%8C%87Offer16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="剑指-Offer-16-数值的整数次方"><a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>示例 1：</strong><br>输入：x = 2.00000, n = 10<br>输出：1024.00000</p><hr><p>思路参考题解：<a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/">https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/</a></p><p>思路是使用快速幂。简单来说就是将指数改写为二进制。然后通过循环复制<code>x *= x</code>，在指数二进制为1的位置，将结果乘上x即<code>res *= x</code>。详细的描述可以看参考题解。</p><p>对于指数为负数的处理，如果指数为负数，<code>x = 1 / x</code>并将指数再设置为正数即可。比如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>可以转化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mo stretchy="false">)</mo><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">(\frac12)^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> || x == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="type">long</span> <span class="variable">nn</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            nn = -nn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (nn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nn &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                res *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            nn &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode236-二叉树的最近公共祖先</title>
      <link href="/2022/06/06/LeetCode236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <url>/2022/06/06/LeetCode236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="236-二叉树的最近公共祖先"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>示例 1：</strong></p><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/LeetCode236-binarytree.png" alt=""></p><p>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p><hr><p>思路：如果root为p和q的最近公共祖先，则一共有三种情况：</p><ol><li><code>p</code>和<code>q</code>在<code>root</code>的两侧</li><li><code>p = root</code>，且<code>q</code>在<code>root</code>的左子树或者右子树中；</li><li><code>q = root</code>，且<code>p</code>在<code>root</code>的左子树或者右子树中；</li></ol><p>考虑使用先序遍历，遇到p或者q时返回。从下往上回溯，当p和q在root异侧时，返回root。</p><p>详见代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">// p和q在root两侧，则最近公共祖先为root</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p和q在root右子树，则最近公共祖先为right</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考题解：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer54-二叉搜索树的第k大节点</title>
      <link href="/2022/06/04/%E5%89%91%E6%8C%87Offer54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/"/>
      <url>/2022/06/04/%E5%89%91%E6%8C%87Offer54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h4><p>给定一棵二叉搜索树，请找出其中第 <code>k</code> 大的节点的值。</p><hr><p>思路：对于二叉搜索树，<strong>中序遍历的倒序</strong>是<strong>递减</strong>的。题目中求第K打节点，可以转化为中序遍历倒序的第k个节点。</p><p>中序遍历过程中，如果–k之后，k的值为0，则表示遍历到第k个节点了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        <span class="comment">// 先--，再判断</span></span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode113-路径总和II</title>
      <link href="/2022/06/04/LeetCode113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/"/>
      <url>/2022/06/04/LeetCode113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="113-路径总和-II"><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h4><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p>示例 1：</p><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/LeetCode113.jpg" alt=""></p><p>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<br>输出：[[5,4,11,2],[5,8,4,5]]</p><hr><p>思路：回溯思想+DFS实现，因为要返回所有的路径，因此用path记录当前遍历的路径。当遍历到叶节点并且节点的值等于targetSum时，即找到符合条件的路径。</p><p>遍历时更新targetSum为<code>targetSum - 当前节点的value</code></p><p>注意回溯时将路径path中最后一个节点移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dfs(root, ans, path, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; ans, Deque&lt;Integer&gt; path, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到一条符合的路径</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; root.val == targetSum) &#123;</span><br><span class="line">            path.addLast(root.val);</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            path.removeLast();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.addLast(root.val);</span><br><span class="line">        dfs(root.left, ans, path, targetSum - root.val);</span><br><span class="line">        dfs(root.right, ans, path, targetSum - root.val);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode79.单词搜索</title>
      <link href="/2022/06/03/LeetCode79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
      <url>/2022/06/03/LeetCode79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="79-单词搜索"><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h4><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/LeetCode-79.jpg" alt=""></p><p>输入：board = [[“A”,“B”,“C”,“E”],[“S”,“F”,“C”,“S”],[“A”,“D”,“E”,“E”]], word = “ABCCED”<br>输出：true</p><hr><p>思路：采用深度优先和回溯的思路。是一道比较典型的回溯题。</p><p>定义了一个方向数组用于深度遍历时确定方向。</p><p>定义visited数组用于记录元素是否已经访问过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span>[] DIRECTIONS = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rows;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cols;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[][] board;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] toCharArray;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[][] visited;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rows = board.length;</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.cols = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="built_in">this</span>.board = board;</span><br><span class="line">        <span class="built_in">this</span>.len = word.length();</span><br><span class="line">        <span class="built_in">this</span>.visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[rows][cols];</span><br><span class="line">        <span class="built_in">this</span>.toCharArray = word.toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> begin)</span> &#123;</span><br><span class="line">        <span class="comment">// 退出条件，遍历到最后一个字母</span></span><br><span class="line">        <span class="keyword">if</span> (begin == len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> toCharArray[begin] == board[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前字母与单词对应下标的字母一致，则继续向四周搜索</span></span><br><span class="line">        <span class="keyword">if</span> (toCharArray[begin] == board[x][y]) &#123;</span><br><span class="line">            visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 向四周寻找</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> x + DIRECTIONS[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">newY</span> <span class="operator">=</span> y + DIRECTIONS[i + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 新坐标在矩阵范围内并且没有访问过</span></span><br><span class="line">                <span class="keyword">if</span> (isInArea(newX, newY) &amp;&amp; !visited[newX][newY]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(newX, newY, begin + <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            visited[x][y] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isInArea</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 52. 两个链表的第一个公共节点</title>
      <link href="/2022/06/01/%E5%89%91%E6%8C%87%20Offer52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
      <url>/2022/06/01/%E5%89%91%E6%8C%87%20Offer52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><p>输入两个链表，找出它们的第一个公共节点。</p><p><strong>示例 1：</strong></p><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/LeetCode160.png" alt=""></p><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><hr><p>思路：如果A为Null或者B为NUll，则不会相交；</p><p>定义两个指针分别从A和B开始同时向后走，假设A到相交节点的距离为a（示例中则为2），B到相交节点的距离为b（示例中则为3），重合部分长度为c（示例中则为3）。</p><p>如果指针A完，即A为Null后，继续从B开始向后遍历；同理B走完后从A继续遍历；两个指针相遇时，即在相交节点。</p><p>相交是指针A走的距离为a+c+b；指针B走的距离为b+c+a。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">b</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            a = a == <span class="literal">null</span> ? headB : a.next;</span><br><span class="line">            b = b == <span class="literal">null</span> ? headA : b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/shuang-zhi-zhen-fa-lang-man-xiang-yu-by-ml-zimingm/">参考题解</a></p><blockquote><p>你变成我，走过我走过的路。<br>我变成你，走过你走过的路。<br>然后我们便相遇了…        😄</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode3.最长不含重复字符的子字符串</title>
      <link href="/2022/06/01/LeetCode3-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/06/01/LeetCode3-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="3-无重复字符的最长子串"><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: s = “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><hr><p>思路：采用滑动窗口的思路，保证窗口内的字符不重复。采用HashMap记录字符最后一次出现的下标。右指针向右遍历的过程中，如果遇到重复字符，则更新左指针，记录字符在map中的下标，并更新返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(i))) &#123;</span><br><span class="line">                left = Math.max(left, map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新map中的下标</span></span><br><span class="line">            map.put(s.charAt(i), i);</span><br><span class="line">            ans = Math.max(ans, i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>13行中，left指针需要取left和<code>map.get(s.charAt(i)) + 1</code>的较大者。</p><p>比如：&quot;abba&quot;这个用例，在i遍历到第二个b的时候，left取2。i继续往后走，走到下一个a的时候，如果只取<code>map.get(s.charAt(i)) + 1</code>，left则往前退了，因此需要取两者的较大者~</p><blockquote><p>还有一个<a href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/mian-shi-ti-48-zui-chang-bu-han-zhong-fu-zi-fu-d-9/">动态规划解</a>，感觉没有滑动窗口的思路好理解，因此只记录滑动窗口解</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer46-把数字翻译成字符串</title>
      <link href="/2022/05/31/%E5%89%91%E6%8C%87Offer46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/05/31/%E5%89%91%E6%8C%87Offer46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="剑指-Offer-46-把数字翻译成字符串"><a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h4><p>题目：给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p>样例：</p><blockquote><p>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, “bwfi”, “bczi”, “mcfi&quot;和&quot;mzi”</p><p>其中：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>&lt;</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">0 \leq num &lt; 2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span></span></span></span></p></blockquote><p>思路：动态规划题的核心是找到状态转移方程，以及定义好初始状态。</p><p>定义：dp[i]表示第i个数字结尾的方案数，那么转移方程有两种情况：</p><ol><li>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>两个数字可以被翻译，即在[10, 25]区间内，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i - 1] + dp[i - 2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></li><li>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>两个数字不能被翻译，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></li></ol><p>可以看到dp[i]的值仅和前两个dp值有关，因此可以优化空间数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">char</span>[] c = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">dp1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dp2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (c[i - <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (c[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            ans = <span class="number">10</span> &lt;= a &amp;&amp; a &lt;= <span class="number">25</span> ? dp1 + dp2 : dp2;</span><br><span class="line">            dp1 = dp2;</span><br><span class="line">            dp2 = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/2021/04/10/Redis%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/04/10/Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Redis">Redis</h4><blockquote><p>面经整理，主要是理论知识</p></blockquote><h5 id="Redis基本数据类型">Redis基本数据类型</h5><p>key是字符串，value是5种：String、List、Hash、Set、Zset</p><p><strong>String</strong>：是SDS(Simple Dynamic String)，动态字符串，可修改，最长512M。</p><blockquote><p>扩展：为什么不用c语言的字符串？Redis如何解决</p><ul><li><p>多增加了字符串长度属性len：c语音中的字符串末尾有’\0’，并且获取长度是O(N)级别的。SDS只需O(1)</p></li><li><p>自动扩展空间：由于字符串经常会进行拼接操作，所以没有提取获取长度，可能会造成缓存区溢出。当 SDS 需要对字符串进行修改时，首先借助于 <code>len</code> 和 <code>alloc</code> 检查空间是否满足修改所需的要求，如果空间不够的话，SDS 会自动扩展空间，避免了像 C 字符串操作中的覆盖情况；</p></li><li><p>有效降低内存分配次数：SDS优化了修改字符串带来的内存重分配的次数，采用<strong>空间预分配(会分配多余的free空间)和惰性空间释放(缩减字符串后不会马上释放空间)</strong></p></li><li><p>二进制安全：因为存了长度，不用去判断空字符<code>\0</code></p></li></ul></blockquote><p><strong>List</strong>：相当于Java的LinkedList，插入删除O(1)，索引定位O(n)</p><p>​lrange：输出list指定范围的元素<code>lrange mylist 0 -1</code></p><p><strong>Hash</strong>：数组+链表 解决哈希冲突，实际上字典结构内部包含两个HashTable，用于扩容时的<strong>渐进式搬迁</strong>。当hash表中的<strong>元素个数等于第一位数组的长度</strong>时，扩容为原数组的两倍。如果Redis正在做 <code>bgsave(持久化命令)</code>，为了减少内存也得过多分离，Redis 尽量不去扩容，但是如果 hash 表非常满了，<strong>达到了第一维数组长度的 5 倍了</strong>，这个时候就会 <strong>强制扩容</strong>。</p><p>当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 <strong>元素个数低于数组长度的 10%</strong>，缩容不会考虑 Redis 是否在做 <code>bgsave</code>。</p><blockquote><p><strong>渐进式rehash</strong>：大字典扩容需要申请新数组，并将原数组所有元素重新挂接到新数组中，由于单线程，所以采用渐进式rehash，这会在rehash的过程中，保留新旧两个hash结构，查询时同时查两个，当全部迁移完成后，使用新的hash结构取而代之</p></blockquote><p><strong>Set</strong>：无序、唯一。</p><h5 id="Redis的zset的底层数据结构？">Redis的zset的底层数据结构？</h5><p>zset：唯一性，并为每个value赋予一个score值，代表排序权重</p><p>跳跃表：有序列表zset的数据结构，链表按照score排序，链表分层，上层的链表树约为下层的1/2，查询的时候从上层开始查，查询效率O(logN)</p><blockquote><p>为什么不用红黑树/平衡树？性能和实现考虑</p></blockquote><p>插入节点，根据随机算法来分配合理的层数，从期望上来看，50%的概率被分到第一层，25%的概率被分到第二层，1/4第三层…</p><p>跳表默认最大的层数为32层</p><p>插入的大致流程：声明存储变量、搜索当前节点插入的位置、生成插入节点、重排前向指针、重排后向指针并返回</p><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/1-%E8%B7%B3%E8%B7%83%E8%A1%A8.png" alt=""></p><p>元素排名：跳跃表在前向指针上增加了一个<code>span</code>属性，<strong>用来表示从前一个节点沿着当前层的forward指针跳到当前节点中间跳过了多少节点</strong>。因此可以沿着搜索路径，将所有经过的节点的跨度<code>span</code>值加起来就能得到最终的<code>rank</code>值</p><p>扩展：</p><p>Bitmap：布隆过滤器</p><p>HyperLogLog：不精确的去重计数功能，适合大规模去重统计</p><p>Geospatial：保存地理位置</p><p>pub/sub：订阅功能，简单的消息队列</p><p>Pipeline：批量执行一组指令，一次性返回结果，可以减少频繁的请求应答</p><p>Lua：支持Lua脚本执行一系列的功能。具有原子性</p><p>事务：只保证串行执行命令，并保证全部执行，但执行命令失败不会回滚，而是继续执行</p><h5 id="Redis-和-Memcached-的区别和共同点">Redis 和 Memcached 的区别和共同点</h5><p>MC：多线程异步IO，只支持K-V，最大失效时间30天，key和value大小有限制</p><p>Redis：单线程，采用非阻塞的异步事件处理机制，避免线程上下文切换的代价；支持持久化；支持<strong>多种数据结构</strong>；主从同步机制、集群</p><h5 id="Redis如何支持高并发">Redis如何支持高并发</h5><p>主从架构 + 读写分离</p><p>一主多从，主负责写，并负责将数据同步到其他slave节点上，从负责读</p><h5 id="为什么Redis用单线程而不是多线程">为什么Redis用单线程而不是多线程</h5><p><a href="https://draveness.me/whys-the-design-redis-single-thread">https://draveness.me/whys-the-design-redis-single-thread</a></p><p>CPU不是Redis的瓶颈，Redis的瓶颈是内存大小和网络带宽，数据都在内存中</p><p>单线程带来更高的可维护性，方便开发</p><p>单线程也可以并发处理客户端请求，IO多路复用</p><blockquote><p>4.0后引入多线程？只是在部分命令上引入(多个非阻塞的删除操作)，在整体架构上还是单线程模型</p></blockquote><h5 id="Redis的事务是怎么实现的">Redis的事务是怎么实现的</h5><p>redis事务是通过multi,exec,discard,watch/unwatch指令用来操作事务。</p><ul><li><p>mutil：开启事务，此后所有的操作将会添加到当前链接的事务“操作队列”中。</p></li><li><p>exec：提交事务</p></li><li><p>discard：取消事务，记住，此指令不是严格意义上的“事务回滚”，只是表达了“事务操作被取消”的语义，将会导致事务的操作队列中的操作不会被执行，且事务关闭。</p></li><li><p>watch/unwatch：“观察”，被watch的key如果被其他客户端修改，会discard；事务执行成功或discard会导致被watch的key变为unwatch</p><blockquote><p>这里的watch其实实现了一个CAS乐观锁，只有被watch的key没有改变时，才会exec执行事务</p></blockquote></li></ul><p>原理：EXEC指令将会触发事务中所有的操作被<strong>写入AOF文件</strong>（如果开启了AOF），然后开始在内存中实施这些数据变更操作<br>如果在EXEC指令被<strong>提交之前</strong>，Redis-server即检测到提交的某个指令存在<strong>语法错误</strong>，那么此事务将会被提前标记<strong>DISCARD</strong>，此后事务提交也将<strong>直接被驳回</strong>；但是如果在<strong>EXEC提交后</strong>，在实施数据变更时（Redis将不会预检测数据类型，比如你对一个“非数字”类型的key执行INCR操作），某个操作导致了<strong>ERROR</strong>，那么redis仍然<strong>不会回滚</strong>此前<strong>已经执行成功的操作</strong>，而且也不会中断ERROR之后的其他操作<strong>继续执行</strong>。</p><p>对于开发者而言，你务必关注事务执行后返回的结果（结果将是一个集合，按照操作提交的顺序排列，对于执行失败的操作，结果将是一个ERROR）。</p><h5 id="缓存的更新方式">缓存的更新方式</h5><p>可以在更新完DB后直接更新缓存；设置失效时间，可以看做数据不一致的最大容忍时间，可以在key失效时请求数据源获取新数据，重置失效时间；失效时，异步更新，防止数据源更新时出错</p><h5 id="缓存一致性问题">缓存一致性问题</h5><ol><li><p>先删除缓存，后更新数据库</p><p>如果删除缓存后，更新数据库的过程中，有线程进行读，缓存被删了，读数据库，读到旧数据，写入缓存，不一致</p><p>解决：延时双删：更新数据库的线程在更新完后，sleep一段时间，然后再删除一次缓存</p></li><li><p>先更新数据库，再删除缓存</p><p>如果更新成功，缓存删除失败，不一致</p><p>解决：通过消息队列，利用消息队列的重试机制，保证消息的<strong>最终一致性</strong></p></li><li><p>其他：设置缓存过期时间。</p></li></ol><h5 id="如果在更新Redis时服务器宕机，怎么办？">如果在更新Redis时服务器宕机，怎么办？</h5><p>持久化、主从、</p><h5 id="Redis的部署架构是什么样的？">Redis的部署架构是什么样的？</h5><p>单机、主从、集群</p><h5 id="Redis内存淘汰机制、几种淘汰策略">Redis内存淘汰机制、几种淘汰策略</h5><p>设置有效期</p><p>删除过期键的策略：定时删除、惰性删除、定时扫描</p><ul><li><strong>定时删除</strong> ：为每个键设置一个定时器，一旦过期时间到了，则将键删除。这种策略对内存很友好，但是对 <code>CPU</code> 不友好，因为每个定时器都会占用一定的 <code>CPU</code> 资源。</li><li><strong>惰性删除</strong> ：不管键有没有过期都不主动删除，等到每次去获取键时再判断是否过期，如果过期就删除该键，否则返回键对应的值。这种策略对内存不够友好，可能会浪费很多内存。</li><li><strong>定期扫描</strong> ：系统每隔一段时间就定期扫描一次，发现过期的键就进行删除。这种策略相对来说是上面两种策略的折中方案，需要注意的是这个定期的频率要结合实际情况掌控好，使用这种方案有一个缺陷就是可能会出现已经过期的键也被返回。</li></ul><p>淘汰没过期键的策略</p><table><thead><tr><th style="text-align:left">淘汰策略</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">volatile-lru</td><td style="text-align:left">根据 LRU 算法删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错</td></tr><tr><td style="text-align:left">allkeys-lru</td><td style="text-align:left">根据 LRU 算法删除所有的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错</td></tr><tr><td style="text-align:left">volatile-lfu</td><td style="text-align:left">根据 LFU 算法删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错</td></tr><tr><td style="text-align:left">allkeys-lfu</td><td style="text-align:left">根据 LFU 算法删除所有的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错</td></tr><tr><td style="text-align:left">volatile-random</td><td style="text-align:left">随机删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错</td></tr><tr><td style="text-align:left">allkeys-random</td><td style="text-align:left">随机删除所有键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错</td></tr><tr><td style="text-align:left">volatile-ttl</td><td style="text-align:left">根据键值对象的 ttl 属性， 删除最近将要过期数据。如果没有，则直接报错</td></tr><tr><td style="text-align:left">noeviction</td><td style="text-align:left">默认策略，不作任何处理，直接报错</td></tr></tbody></table><blockquote><p>衍生：Redis对LRU算法的改进，解决传统LRU的什么缺点？怎么改进的？抽样删除</p></blockquote><p>Redis热度数据管理：LRU：lru属性24位、全局属性lru_clock；LFU：lru属性高16位时钟低8位频数、频次递增(随机数、概率p公式、对数因子)、频次递减(<code>lfu-decay-time</code>、计算差值、除以<code>lfu-decay-time</code>)</p><h5 id="Redis缓存穿透和缓存雪崩？">Redis缓存穿透和缓存雪崩？</h5><p><strong>缓存雪崩</strong>：Redis中的缓存大面积失效，所有的流量直接打在数据库上，数据库亚历山大啊</p><p>解决方案：在往Redis中存数据的时候，设置随机的失效时间；或者考虑热点数据永不失效，有更新操作的时候更新一下缓存</p><p><strong>缓存穿透</strong>：缓存和数据库都没有的数据，而某个不良用户不断地发起请求，比如数据库中的id都大于0，我一直用小于0的id去请求，每次都能避开Redis，直接打在数据库上，造成数据库压力过大</p><p>解决方案1：在接口层增加校验，如用户权限校验、参数校验、不合法的直接返回Null给前端。比如id校验id&lt;=0直接拦截。</p><p>解决方案2：缓存和数据库都取不到的key，可以将对应key的value设置为null、错误提示等，具体看场景，设置个失效时间30秒。</p><p>解决方案3：<strong>布隆过滤器</strong></p><p><strong>缓存击穿</strong>：是指某个热点key，不停地扛着大并发，当这个key失效的瞬间，持续的大并发就会击穿缓存，直接请求数据库。</p><p>解决方案：设置热点数据永不过期，数据有更新时，同时更新缓存即可</p><p><strong>总结</strong>：上述三个问题，之前：Redis高可用，主从+哨兵，Redis集群，避免全盘崩溃</p><p>若还是发生了上述问题，采用本地缓存、限流、降级等方法，避免MySQL挂掉</p><p>发生问题之后，Redis持久化RDB+AOF，一旦重启，自动从磁盘加载数据，快速恢复缓存数据</p><p>哪怕限流，也不能让数据库挂掉，对用户来说多刷几次而已~</p><h5 id="布隆过滤器">布隆过滤器</h5><p>概念：用于检索一个元素是否在一个集合中。</p><p>原理：当元素被加入集合时，通过k个散列函数将这个元素映射成一个位(bit)数组中的k个点，把他们置成1。检索时，只要看对应的这些点是否为1，就大概率知道该集合中是否有该元素。</p><p>缺点：有可能误判，可能元素不在集合中，但k个bit位都为1；删除困难</p><h5 id="Redis持久化的方式">Redis持久化的方式</h5><p>两种持久化方式：RDB和AOF</p><h6 id="RDB"><strong>RDB</strong></h6><p>快照是一次全量备份，快照作为包含整个数据集的单个.rdb文件生成，快照是内存数据的二进制序列化形式，在存储上非常紧凑。</p><p>使用系统多进程<code>COW(Copy On Write)</code>机制的<code>fork</code>函数，产生一个<strong>子进程</strong>，<strong>子进程</strong>会拷贝<strong>父进程</strong>的部分<strong>代码段和数据段</strong>，<strong>快照持久</strong>化可以完全由<strong>子进程</strong>完成，<strong>父进程</strong>继续<strong>处理客户端请求</strong>。数据段由操作系统的<strong>页面</strong>组合而成，主进程在对某个页面进行修改时，会得到该页面的一份复制，然后<strong>在复制页上进行修改</strong>，而<strong>子进程</strong>相应的<strong>页面是没有变化</strong>的，子进程只需要遍历数据进行序列化写磁盘就行了。</p><p><strong>触发机制</strong>：手动、自动</p><p>自动触发：</p><ol><li>在配置文件中设置触发条件</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当在规定的时间内，Redis发生了写操作的个数满足条件，会触发发生BGSAVE命令。</span></span><br><span class="line"><span class="comment"># save &lt;seconds&gt; &lt;changes&gt;</span></span><br><span class="line"><span class="comment"># 当用户设置了多个save的选项配置，只要其中任一条满足，Redis都会触发一次BGSAVE操作</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1 </span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10 </span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000</span></span><br><span class="line"><span class="comment"># 以上配置的含义：900秒之内至少一次写操作、300秒之内至少发生10次写操作、</span></span><br><span class="line"><span class="comment"># 60秒之内发生至少10000次写操作，只要满足任一条件，均会触发bgsave</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>执行shutdown命令关闭服务器时，如果没有开启AOF，则会自动执行一次<code>bgsave</code></p></li><li><p>主从同步：master执行<code>bgsave</code>，并缓存该时间段的写操作，将rdb发送给slave，slave同步数据，最后master向所有slave发送缓存中的写操作，完成同步</p></li></ol><p><strong>执行流程</strong>：使用操作系统多进程的COW机制</p><ol><li>执行<code>bgsave</code>时，先看有不有子进程正在执行RDB/AOF持久化任务，有则返回</li><li>主进程<code>fork</code>一个子进程来执行RDF，<code>fork</code>操作会对主进程造成阻塞，只是<code>fork</code>期间阻塞，之后就不阻塞了</li><li>子进程根据主进程的内存生成临时快照文件，持久化完成后用临时快照文件替换原来的RDF文件。此过程主进程仍然可以响应写操作，但是是在内存页面的副本进行，不会影响子进程持久化工作</li><li>子进程完成后发消息给主进程</li></ol><p><strong>RDB的优缺点</strong></p><p>优点</p><ul><li>RDB文件小，适合定时备份，用于容灾</li><li>Redis加载RDB文件速度比AOF日志快很多，因为RDB存的是内存中的数据，而AOF日志记录的是指令，需要顺序执行所有指令来恢复</li></ul><p>缺点</p><ul><li>无法实时持久化，两次<code>bgsave</code>过程中的数据可能丢失</li><li><code>fork</code>子进程会阻塞Redis主进程</li><li>老版本的Redis可能不兼容新版本RDB格式文件</li></ul><h6 id="AOF"><strong>AOF</strong></h6><p>Append Only File，仅追加文件，AOF 日志是连续的增量备份。每次执行<strong>修改内存</strong>中数据集的写操作时，都会<strong>记录</strong>该操作。假设AOF记录了自Redis实例创建以来<strong>所有的修改性指令</strong>，那么就可以通过对一个空的Redis实例<strong>顺序执行所有指令</strong>，即<strong>重放</strong>，来恢复Redis当前实例的内存数据结构的状态</p><p>AOF会在持续运行中持续增大，因此需要定期进行AOF重写，对AOF日志进行瘦身</p><p>开启方式</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 此选项为aof功能的开关，默认为“no”，可以通过“yes”来开启aof功能  </span></span><br><span class="line"><span class="comment">## 只有在“yes”下，aof重写/文件同步等特性才会生效  </span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## 指定aof文件名称  </span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">appendonly.aof  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## 指定aof操作中文件同步策略，有三个合法值：always everysec no,默认为everysec  </span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec  </span></span><br><span class="line"><span class="comment">## 在aof-rewrite期间，appendfsync是否暂缓文件同步，&quot;no&quot;表示“不暂缓”，“yes”表示“暂缓”，默认为“no”  </span></span><br><span class="line"><span class="attr">no-appendfsync-on-rewrite</span> <span class="string">no  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## aof文件rewrite触发的最小文件尺寸(mb,gb),只有大于此aof文件大于此尺寸是才会触发rewrite，默认“64mb”，建议“512mb”  </span></span><br><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">64mb  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## 相对于“上一次”rewrite，本次rewrite触发时aof文件应该增长的百分比  </span></span><br><span class="line"><span class="comment">## 每一次rewrite之后，redis都会记录下此时“新aof”文件的大小(例如A)</span></span><br><span class="line"><span class="comment">## aof文件增长到A*(1 + p)之后，触发下一次rewrite，每一次aof记录的添加，都会检测当前aof文件的尺寸。  </span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br></pre></td></tr></table></figure><p>Linux对文件采用延迟写入，即每次写入先进缓存，到了已定时机再写入磁盘。</p><p>Linux提供了<code>fsync(int fd)</code>函数，可以将指定文件的内容强制从内核缓存刷到磁盘，但是是一个磁盘IO操作，非常耗时。因此<strong>Redis提供了3种AOF同步策略</strong>：</p><ul><li>always：每条AOF都立即同步，性能低，安全</li><li>everysec：每秒同步，默认的方式，性能安全较平衡</li><li>no：永不直接同步，全由操作系统决定。性能好但非常不安全</li></ul><p><strong>重写(Rewrite)机制</strong></p><p>不是基于源AOF文件，而是基于当前内存数据，类似于RDB快照的方式，使用更少的指令来记录内存中数据的状态。先存当前内存状态，再将重写期间的写操作从缓存写入AOF。</p><p><strong>触发机制</strong>：手动和自动</p><p>手动：<code>bgrewriteaof</code>命令：<code>redis-cli -h ip -p port bgrewriteaof</code></p><p>自动</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto-aof-rewrite-min-size</span>:<span class="string">表示运行AOF重写时文件最小体积，默认为64MB（我们线上是512MB）。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span>:<span class="string">代表当前AOF文件空间（aof_current_size）和上一次重写后AOF文件空间（aof_base_size）</span></span><br></pre></td></tr></table></figure><p><strong>AOF的优缺点</strong></p><p>优点：只是追加写日志，写增量信息，对服务器性能影响小，速度比RDB快，内存消耗少</p><p>缺点</p><ul><li>日志文件太大，需要不断重写瘦身，但和RDB文件比还是很大</li><li>使用AOF恢复数据时，比RDB慢</li></ul><h6 id="Redis4-0混合持久化">Redis4.0混合持久化</h6><p>RDB文件和AOF日志结合，AOF日志记录自RDB持久化开始到当前这段时间发生的增量数据。</p><p>大量数据使用RDB，性能高，恢复快；增量数据使用AOF，尽量保证数据不丢失</p><h5 id="Redis主从复制怎么实现的">Redis主从复制怎么实现的</h5><p>作用</p><ul><li>数据冗余：主从复制实现数据的热备份</li><li>故障恢复：主节点挂了，从节点可以提供服务，实现快速故障恢复</li><li>负载均衡：主从复制、读写分离，主提供写，从提供读</li></ul><p>实现原理</p><p><strong>准备阶段 - &gt; 数据同步阶段 - &gt; 命令传播阶段</strong></p><p>slave第一次连接到master时，master会启动子进程生成RDB快照，并把过程中的写请求存到缓存，RDB文件生成后，将RDB文件发给slave，并把缓存中的写操作也发给slave</p><p>之后的数据通过AOF日志同步</p><h5 id="Redis中的哨兵是干啥的">Redis中的哨兵是干啥的</h5><p>架构</p><p>哨兵节点：哨兵系统由一个或多个哨兵节点组成，不存储数据</p><p>数据节点：主、从都是数据节点</p><p>功能</p><ul><li><strong>监控（Monitoring）：</strong> 哨兵会不断地检查主节点和从节点是否运作正常。</li><li><strong>自动故障转移（Automatic failover）：</strong> 当 <strong>主节点</strong> 不能正常工作时，哨兵会开始 <strong>自动故障转移操作</strong>，它会将失效主节点的其中一个 <strong>从节点升级为新的主节点</strong>，并让其他从节点改为复制新的主节点。<ol><li>在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被 <strong>淘汰</strong>。</li><li>在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被 <strong>淘汰</strong>。</li><li>在 <strong>经历了以上两轮淘汰之后</strong> 剩下来的从服务器中， 我们选出 <strong>复制偏移量（replication offset）最大</strong> 的那个 <strong>从服务器</strong> 作为新的主服务器；如果复制偏移量不可用，或者从服务器的复制偏移量相同，那么 <strong>带有最小运行 ID</strong> 的那个从服务器成为新的主服务器。</li></ol></li><li><strong>配置提供者（Configuration provider）：</strong> 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。</li><li><strong>通知（Notification）：</strong> 哨兵可以将故障转移的结果发送给客户端。</li></ul><h5 id="为什么Redis的负载因子设置比HashMap的负载因子大">为什么Redis的负载因子设置比HashMap的负载因子大</h5><p>Redis的负载因子是键值对的数量/长度，HashMap是已使用的数量/长度</p><h5 id="Redis的分布式锁？">Redis的分布式锁？</h5><p>最低保证分布式锁的有效性及安全性的要求如下：</p><p>1.互斥；任何时刻只能有一个client获取锁</p><p>2.释放死锁；即使锁定资源的服务崩溃或者分区，仍然能释放锁</p><p>3.容错性；只要多数redis节点（一半以上）在使用，client就可以获取和释放锁</p><p><strong>问题</strong></p><p>因为redis在进行主从复制时是异步完成的，比如在clientA获取锁后，主redis复制数据到从redis过程中崩溃了，导致没有复制到从redis中，然后从redis选举出一个升级为主redis,造成新的主redis没有clientA 设置的锁，这是clientB尝试获取锁，并且能够成功获取锁，导致互斥失效；</p><p><strong>Redis分布式锁的实现</strong></p><p><strong>单实例</strong>中的实现：<code>SET key_name value_name NX PX 30000</code>保证原子性</p><blockquote><p>NX 表示if not exist 就设置并返回True，否则不设置并返回False   PX 表示过期时间用毫秒级， 30000 表示这些毫秒时间后此key过期</p></blockquote><p>获取失败则等待一段时间重试(大于ttl)或退出</p><p>获取锁，完成相关操作后，必须删除自己的锁。这里获取和删除都是用lua脚本，保证操作的原子性</p><p><strong>多节点</strong>Redis实现(RedLock)：有效防止单点故障</p><p>1.获取当前时间戳</p><p>2.client尝试按照顺序使用相同的key,value获取所有redis服务的锁，在获取锁的过程中的获取时间比锁过期时间短很多，这是为了不要过长时间等待已经关闭的redis服务。并且试着获取下一个redis实例。</p><p>比如：TTL为5s,设置获取锁最多用1s，所以如果一秒内无法获取锁，就放弃获取这个锁，从而尝试获取下个锁</p><p>3.client通过获取所有能获取的锁后的时间减去第一步的时间，这个时间差要小于TTL时间并且至少有3个redis实例成功获取锁，才算真正的获取锁成功</p><p>4.如果成功获取锁，则锁的真正有效时间是 TTL减去第三步的时间差 的时间；比如：TTL 是5s,获取所有锁用了2s,则真正锁有效时间为3s(其实应该再减去时钟漂移);</p><p>5.如果客户端由于某些原因获取锁失败，便会开始解锁所有redis实例；因为可能已经获取了小于3个锁，必须释放，否则影响其他client获取锁</p><h5 id="Redis包含的模块">Redis包含的模块</h5><h5 id="Redis为什么快？">Redis为什么快？</h5><ol><li>纯内存操作</li><li>单线程，没有各自乱七八糟的锁</li><li>多路IO复用模型，底层有很多优化</li><li>高效的数据结构：如不同长度的字符串用了不同的结构体、HyperLogLog的密集型存储结构等</li></ol><h5 id="Redis的HyperLogLog">Redis的HyperLogLog</h5><p>HyperLogLog是一种估计基数的近似最优算法。基数统计：用来统计一个集合中不重复的元素个数，比如统计网站每个页面的UV(独立访客)</p><p>大致的原理：一个随机数，尾部有1个0的概率为1/2，两个0的概率为1/4，…，尾部k个0的概率为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mi>k</mi></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span>。因此我们可以通过尾部连续0的最大数量k，估算出我们用了多少个随机数。HyperLogLog通过分配若干桶(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup></mrow><annotation encoding="application/x-tex">2^{14}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span></span></span></span>=26384)，对每个桶得到的最大数量k进行调和平均，得到一个k#，k#为一个浮点数。具体还有很多修正因子，比较复杂</p><p>占用内存仅12KB，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup></mrow><annotation encoding="application/x-tex">2^{14}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span></span></span></span>个桶，每个6bit，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup><mo>∗</mo><mfrac><mn>6</mn><mn>8</mn></mfrac></mrow><annotation encoding="application/x-tex">2^{14}*\frac68</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>Redis的实现：计数量小的时候，转换成稀疏存储方式；否则采用密集存储。最大限度节约内存</p><p>密集存储：16384个6bit连续成串，8bit 1字节，需要一些移位拼接的处理</p><p>稀疏存储：当某个计数值需要调整到大于32时，会转换为密集存储</p><ul><li>00开头表示后6位整数值加1就是零值计数器的数量</li><li>01后14bit最多可以表示连续16384个零值计数器</li><li>1vvvvvxx：中间5bit计数，后2bit表示连续几个桶</li></ul><p>指令：<code>pfadd</code>和<code>pfcount</code></p><p><a href="https://mp.weixin.qq.com/s/9dtGe3d_mbbxW5FpVPDNow">https://mp.weixin.qq.com/s/9dtGe3d_mbbxW5FpVPDNow</a></p><p><a href="https://cloud.tencent.com/developer/article/1349691">https://cloud.tencent.com/developer/article/1349691</a></p><h5 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？">假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h5><p>使用 <code>keys</code> 指令可以扫出指定模式的 key 列表。但是要注意 keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 <code>scan</code> 指令，<code>scan</code> 指令可以无阻塞的提取出指定模式的 <code>key</code> 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习随笔</title>
      <link href="/2020/08/10/JVM_Note/"/>
      <url>/2020/08/10/JVM_Note/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JVM的架构模型">JVM的架构模型</h2><p>JAVA编译器输入的指令流基本是一种基于<strong>栈的指令集架构</strong>，另一种架构是基于寄存器的。<br>两者的区别：</p><ul><li><strong>基于栈式架构的特点</strong><ul><li>设计和实现更简单，适用于资源受限的系统，比如嵌入式。</li><li>避开了寄存器的分配难题：采用零地址指令方式分配。（零地址就是只有操作码，没有地址字段，因为栈的话只对栈顶进行操作，就不需要地址）</li><li>指令流中的指令大部分是零地址指令，执行过程依赖操作栈。<strong>指令集更小</strong>，编译器容易实现。</li><li>不需要硬件支持，可移植性更好，更好实现<strong>跨平台</strong></li></ul></li><li><strong>基于寄存器架构的特点</strong><ul><li>指令集完全依赖于硬件，可移植性差。</li><li>性能优秀、执行高效</li><li>花费更少的指令来完成一项操作</li><li>在大部分情况下，采用一地址指令、二地址指令和在地址指令为主。</li></ul></li></ul><h2 id="JVM的生命周期">JVM的生命周期</h2><ul><li>虚拟机的启动：Java虚拟机的启动时通过引导类加载器(bootstrap class loader)创建一个初始类(initial calss)来完成的，这个类是由虚拟机的具体实现指定的。</li><li>虚拟机的执行：<ul><li>任务：执行Java程序</li><li>程序开始执行时它才运行，程序结束它就停止</li><li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</li></ul></li><li>虚拟机的退出：<ul><li>程序正常执行结束</li><li>程序碰到异常或错误而异常终止</li><li>由于操作系统出错而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或者System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作</li><li>除此之外，JNI(Java Native Interface)规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况</li></ul></li></ul><h2 id="JVM整体结构">JVM整体结构</h2><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/JVM_jiegou.jpg" alt=""></p><h2 id="类加载器子系统">类加载器子系统</h2><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/JVM_leijiazaiqi.jpg" alt=""></p><ul><li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</li><li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</li><li>加载的类信息存放在一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分信息是Class文件中常量池部分的内存映射）</li></ul><h3 id="类的加载阶段">类的加载阶段</h3><ol><li>加载：<ol><li>通过一个类的全限定名定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的<strong>java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口。</li></ol></li><li>链接：<ol><li>验证：<ul><li>目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性</li><li>主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证</li></ul></li><li>准备：<ul><li>为类变量分配内存并且设置类变量为默认初始值，即零值</li><li>这里不包含final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化</li><li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li></ul></li><li>解析：<ul><li>将常量池内的符号引用转换为直接引用的过程。</li><li>解析操作往往会伴随着JVM在执行完初始化之后再执行。</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。</li></ul></li></ol></li><li>初始化：<ul><li>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程。</li><li>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和<strong>静态代码块</strong>中的语句合并而来的。</li><li>&lt;clinit&gt;()不同于类的构造器。(构造器是虚拟机视角下的&lt;init&gt;())</li><li>若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类&lt;clinit&gt;()已经执行完毕。</li><li>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。</li></ul></li></ol><h3 id="类加载器的分类">类加载器的分类</h3><ul><li><p>JVM支持两种类型的类加载器：<strong>引导类加载器(Bootstrap ClassLoader)</strong> 和<strong>自定义类加载器(User-Defined ClassLoader)</strong></p></li><li><p>从概念上讲，自定义类加载器一般指程序中由程序员自定义的一类类加载器，但Java虚拟机规范指出，将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</p></li><li><p>无论定义咋分，最常见的三个类加载器如下图：<br>（引导类加载器、扩展类加载器和系统类加载器）<br><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/JVM_leijiazaiqifenlei.jpg" alt=""><br><strong>这里的四者之间的关系是包含关系。不是上下层关系，也不是父类的继承关系。</strong><br>Demo:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 获取系统类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader); <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 获取其上层：扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader); <span class="comment">// sun.misc.Launcher$ExtClassLoader@1b6d3586</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 获取其上层：获取不到引导类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader); <span class="comment">// null</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader); <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// String类使用引导类加载器进行加载 ---&gt; Java的核心类库都是使用引导类加载器进行加载</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1); <span class="comment">// null</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="启动类加载器-引导类加载器，Bootstrap-ClassLoader">启动类加载器(引导类加载器，Bootstrap ClassLoader)</h3><ul><li>这个类加载器使用C/C++语言实现的，嵌套在JVM内部</li><li>它用来加载Java的核心库(JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容)，用于提供JVM自身需要的类</li><li>并不继承自java.lang.ClassLoader，没有父加载器</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</li><li>处于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><h3 id="扩展类加载器-Extension-ClassLoader">扩展类加载器(Extension ClassLoader)</h3><ul><li>Java编写</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录jre/lib/ext子目录(扩展目录)下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li></ul><h3 id="应用程序类加载器-系统加载器，AppClassLoader">应用程序类加载器(系统加载器，AppClassLoader)</h3><ul><li>Java编写</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它完成加载的</li><li>通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************启动类加载器*************&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取BootstrapClassLoader能够加载的api路径</span></span><br><span class="line">        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span>(URL element : urls)&#123;</span><br><span class="line">            System.out.println(element.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            *************启动类加载器*************</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/resources.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/rt.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/sunrsasign.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/jsse.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/jce.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/charsets.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/jfr.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/classes</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;**************扩展类加载器**************&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">extDirs</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String path : extDirs.split(<span class="string">&quot;;&quot;</span>))&#123;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            **************扩展类加载器**************</span></span><br><span class="line"><span class="comment">            E:\Java\jdk8\jdk1.8.0_251\jre\lib\ext</span></span><br><span class="line"><span class="comment">            C:\Windows\Sun\Java\lib\ext</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户自定义类加载器">用户自定义类加载器</h3><ul><li>在Java的日常应用程序开发中，类的加载几乎是由上述三种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，类定制类的加载方式。</li><li>目的：<ul><li>隔离加载器</li><li>修改类加载器</li><li>扩展加载源</li><li>防止源码泄露</li></ul></li></ul><h3 id="获取ClassLoader的方式">获取ClassLoader的方式</h3><ol><li><code>class.getClassLoader()</code>：获取当前类的ClassLoader</li><li><code>Thread.currentThread().getContextClassLoader()</code>：获取当前线程上下文的ClassLoader</li><li><code>ClassLoader.getSystemClassLoader()</code>：获取系统的ClassLoader</li><li><code>DriverManager.getCallerClassLoader()</code>：获取调用者的ClassLoader</li></ol><h3 id="双亲委派机制">双亲委派机制</h3><ul><li>Java虚拟机对class文件采用按需加载的方式，加载时采用双亲委派记至，即把请求交由父类处理，它是一种任务委派模式。</li><li>原理：<ol><li>如果一个类加载器收到了类加载请求，它不会先自己加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上层委托，以此类推，直到请求最终达到顶层的启动类加载器；</li><li>如果父类加载器可以完成加载任务，就成功返回，倘若父类加载器无法完成此次加载任务，子加载器才会尝试自己去加载<br><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/shuangqinweipai.jpg" alt=""></li></ol></li><li>优势：<ol><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改</li></ol></li></ul><h3 id="沙箱安全机制">沙箱安全机制</h3><ul><li>将Java代码限定在JVM特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证代码的有效隔离，防止对本地系统造成破坏。</li><li>如果我们自定义一个类名为String的类，并且包为java.lang。如果没有沙箱安全机制，可能会污染到原本jdk中的String类。根据双亲委派机制，委托到顶层的启动类加载器，就可以完成String的加载，避免了代码污染。</li></ul><h3 id="线程">线程</h3><ul><li>JVM允许多线程并行执行</li><li>在Hotspot JVM中，每个线程都与操作系统的本地线程直接映射。当一个Java线程准备好执行后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li><li>操作系统负责所有线程的安排调度到任何一个CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</li></ul><h2 id="运行时数据区">运行时数据区</h2><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/JVM_yunxingshishujuqu.jpg" alt=""></p><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/JVM_yunxingshishujuqu2.jpg" alt=""></p><ul><li>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机的退出而销毁。另外一些则是与线程一一对应，这些与线程对应的数据区会随着线程开始和结束而创建和销毁。</li><li>上面第一张图中，红色区域(方法区和堆)为一个进程共享的区域，而灰色部分(PC寄存器、本地方法栈和虚拟机栈)则为一个线程一份。</li><li>每个JVM只有一个Runtime实例。即为运行时环境。</li></ul><h3 id="程序计数器-PC寄存器，Program-Counter-Register">程序计数器(PC寄存器，Program Counter Register)</h3><h4 id="概述">概述</h4><ul><li>存储指令相关的现场信息，CPU只有把数据装载到寄存器才能够运行。</li><li>这里的PC寄存器只是JVM对物理PC寄存器的一种抽象模拟，并不是物理寄存器。</li><li>作用：PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码，由执行引擎读取下一条指令。(和计组学的那个功能类似。。)</li><li>它是一块很小的内存空间，运行速度最快的存储区域</li><li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值(undefined)</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖它来完成。</li><li>字节码解释器工作时是通过改变程序计数器的值来选取下一条需要执行的字节码指令。</li><li>它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</li></ul><h4 id="问题">问题</h4><ol><li>使用PC寄存器存储字节码指令地址有什么用？(为什么使用PC寄存器记录当前线程的执行地址呢？)<br>因为CPU需要不停地切换各个线程，这时候切换回来以后，就需要知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</li><li>PC寄存器为什么会被设定为线程私有？<br>多线程就是在一个特定的时间内只会执行其中某一个线程，CPU会不停地做任务切换，因此就会涉及到中断和恢复。为了能够准确地记录每个线程正在执行的当前字节码指令地址，就必须为每个线程分配一个PC寄存器。</li></ol><h3 id="虚拟机栈">虚拟机栈</h3><h4 id="概述-2">概述</h4><ul><li>栈是运行时的单位，堆是存储的单位</li><li>生命周期与线程一致。即每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame)，对应着一次次的Java方法调用。是线程私有的。</li><li>作用：管Java程序的运行，保存方法的局部变量、部分结果。并参与方法的调用和返回。</li><li>对于栈来说，不存在垃圾回收问题。</li><li>栈中可能出现的异常：<ul><li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出<strong>StackOverflowError</strong>异常。</li><li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存区创建对应的虚拟机栈，那Java虚拟机将会抛出一个<strong>OutOfMemoryError</strong>异常。</li></ul></li><li>设置栈内存大小：<code>-Xss</code></li></ul><h4 id="栈的存储单位">栈的存储单位</h4><ul><li>每个线程都有自己的栈，栈中的数据都是以**栈帧(Stack Frame)**的格式存在</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li><li>JVM对Java栈的操作：压栈和出栈</li><li>当前执行的方法的栈帧：当前栈帧-&gt;当前方法-&gt;当前类</li><li>不同线程中所包含的栈帧是不允许存在互相引用的</li><li>Java方法的两种返回方式：一是正常放回，return；另一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</li></ul><h4 id="栈帧的内部结构">栈帧的内部结构</h4><ul><li>局部变量表(Local Variables)</li><li>操作数栈(Operand Stack)(或表达式栈)</li><li>动态链接(Dynamic Linking)(或指向运行时常量池的方法引用)</li><li>方法返回地址(Return Address)(或方法正常退出或者异常退出的定义)</li><li>一些附加信息<br>PS：方法返回地址、动态链接和一些附加信息也称作帧数据区</li></ul><h5 id="局部变量表-Local-Variables">局部变量表(Local Variables)</h5><ul><li><p>也称局部变量数组或本地变量表</p></li><li><p>定义一个<strong>数字数组</strong>，主要用于存储方法参数和定义在方法体内的局部变量(各类基本数据类型、对象引用(reference)、returnAddress类型)</p></li><li><p>局部变量表建立在线程的栈上，是线程私有的数据，因此不存在数据安全问题</p></li><li><p>局部变量表所需的容量大小是在<strong>编译期</strong>确定的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p></li><li><p>方法嵌套调用的次数由栈的大小决定。站越大，方法嵌套调用次数越多。</p></li><li><p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p></li><li><p>Slot:</p><ul><li>局部变量表，最基本的存储单元是Slot(变量槽)</li><li>32位以内的类型只占用一个slot(包括returnAddress类型)；64位的类型(long和double)占用两个slot<blockquote><p>byte、short、char在存储前被转换为int，boolean也被转换为int(0为false，1为true)</p></blockquote></li><li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可访问到局部变量表中指定的局部变量值</li><li>局部变量按照声明的顺序被复制到局部变量表的每一个Slot上</li><li>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列</li></ul><p>Demo:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVariablesTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();</span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9.6</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">        test.add(a, b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;a + b = &quot;</span> + (a + b));</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/JVM_jububianliangbiao.jpg" alt=""></p><ul><li>栈帧中的局部变量表中的槽位是可以重复利用的。如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很可能会服用过期局部变量的槽位，从而节省资源</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        b = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上述方法有四个变量，但是局部变量表的槽位只有三个。变量b在出了括号后，过了其作用域。因此之后声明的变量c占了之前b的slot的位置。这样就节省了资源。<br><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/JVM_jububianliangbiao2.jpg" alt=""></p></li></ul><p>变量的分类：</p><ul><li>按照数据类型分：1. 基本数据类型 2. 引用数据类型</li><li>按照在类中声明的位置分：<ol><li>成员变量：在使用前，都经历过默认初始化赋值<ul><li>类变量：linking的prepare阶段：给类变量默认赋值 —&gt; initial阶段：给类变量显式赋值即静态代码块赋值</li><li>实例变量：随着对象的创建，会在对空间中分配实例变量空间，并进行默认赋值</li></ul></li><li>局部变量：在使用前，必须进行显式赋值。否则编译不通过</li></ol></li></ul><ol><li>在栈帧中，与性能调优关系最密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。如果局部变量表中的变量不存在了，指向堆空间的指针也就不存在了，那么堆中垃圾就需要被回收</li><li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</li></ol><h5 id="操作数栈-Operand-Stack">操作数栈(Operand Stack)</h5><ul><li>每个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈，也可以成为表达式栈。</li><li>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</li><li>如果被调用的方法带有返回值，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器下一条需要执行的字节码指令。</li><li>一个方法刚开始执行时，栈帧被创建，随之这个方法的操作数栈也被创建，但为空。且最大深度在编译期就定义好了。</li><li>操作数栈<strong>并非采用访问索引的方式来进行数据访问</strong>，只能通过push和pop来操作，因为它是个<strong>栈</strong>，但是它是由数组实现的。</li><li>Java虚拟机的届时引擎是基于栈的执行引擎，其中栈指的就是操作数栈。</li></ul><h4 id="栈顶缓存技术-ToS-Top-of-Stack-Cashing">栈顶缓存技术(ToS, Top-of-Stack Cashing)</h4><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈操作，使得需要更多的指令分派次数和内存读写此时。<br>HotSpot JVM提出栈顶缓存技术(ToS, Top-of-Stack Cashing)，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率</strong>。</p><h4 id="动态链接">动态链接</h4><ul><li>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中<strong>该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现<strong>动态链接(Dynamic Linking)</strong>。比如invokedynamic指令</li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(Symbolic Reference)保存在class文件的常量池里。比如：描述一个方法调用另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong>。<br><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/JVM_dataDynamicLinking.jpg" alt=""></li></ul><h4 id="方法的调用">方法的调用</h4><p>在JVM中，将<strong>符号引用</strong>转换为调用方法的<strong>直接引用</strong>与方法的绑定机制相关。</p><ul><li>静态链接：<br>当一个字节码文件被装进JVM内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程，称之为静态链接。</li><li>动态链接：<br>如果<strong>被调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期间将方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此称之为动态链接。</li></ul><hr><p>对应的方法的绑定机制为：早期绑定(Early Binding)和晚期绑定(Late Binding)。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><ul><li>早期绑定：<br>就是指被调用的<strong>目标方法如果在编译期可知，且运行时保持不变</strong>时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此就可以使用静态链接的方式将符号引用转换为直接引用。</li><li>晚期绑定：<br>如果<strong>被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称为晚期绑定。</li></ul><h4 id="虚方法与非虚方法">虚方法与非虚方法</h4><ul><li>非虚方法：<ul><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。</li><li>静态方法、私有方法、final方法、实例构造器、父类方法等</li><li>其他方法称为虚方法</li></ul></li><li>子类对象的多态性的使用前提：1. 类的继承关系 2. 方法的重写</li><li>虚拟机中提供了一下几条方法调用指令：<ul><li>普通调用指令：<ol><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ol></li><li>动态调用指令：<br>5. invokedynamic：动态解析出需要调用的方法，然后执行</li><li>前四条指令固化在虚拟机内部，方法的调用执行不可认为干预，而invokedynamic指令则支持由用户确定方法版本，其中invokestatic指令和invokespecial指令调用的方法称为虚方法，其余的（final修饰的除外）称为虚方法。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2020/07/08/Java_Basic/"/>
      <url>/2020/07/08/Java_Basic/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><blockquote><p>重新看看Java基础<br>顺便随便记一些基础的东西。。😃</p></blockquote><hr><h2 id="数据类型">数据类型</h2><p>基本类型：4种整型、两种浮点类型、1中用于表示Unicode编码的字符型char和boolean型</p><ol><li>整型：int、short、long、byte</li><li>浮点型：float、double<blockquote><p>注意：浮点型存在舍入误差，有些小数无法精确表示，如果在数值计算时不允许有误差，可以考虑使用BigDecimal类</p></blockquote></li><li>char类型：用单引号括起来</li><li>boolean：两个值：true和false<blockquote><p>在c++中，可以使用数值0表示布尔值false，非0相当于布尔值true；但Java中不行，编译不能通过</p></blockquote></li></ol><h2 id="final">final</h2><ol><li>关键字final指示常量。</li><li>final表示这个变量只能被赋值一次。一旦被赋值后，就不能改变。</li><li>常量名一般使用全大写。</li><li>类常量可以使用<code>static final</code>来设置，定义位于main方法外，同一个类中的方法都可以使用。</li></ol><h2 id="枚举类型">枚举类型</h2><h2 id="Scanner类">Scanner类</h2><p>从键盘输入数据。</p><ol><li>导包：<code>import java.util.Scanner</code></li><li>创建对象：<code>Scanner sc = new Scanner(System.in)</code></li><li>使用：参数类型 变量名 = sc.成员方法名<code>   从键盘获取一个int：</code>int num = sc.nextInt()<code>    从键盘获取一个String：</code>String str = sc.next()`</li></ol><h2 id="ArrayList">ArrayList</h2><ol><li>创建：<code>ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();</code>。E表示泛型。</li><li><code>System.out.print(list)</code>打印的是list的内容，不是地址。</li><li>public boolean add(E e)：向集合添加元素，参数类型与创建集合的泛型一致。</li><li>public int size()：获取list长度。</li><li>public E remove(int index)：从集合删除索引为index的元素，返回被删除的元素。</li><li>public E get(int index)：获取下标为index的元素，并返回该元素。</li><li>泛型只能为引用类型，不能为基本类型。必须使用基本类型的包装类。</li></ol><table><thead><tr><th style="text-align:center">基本类型</th><th style="text-align:center">包装类</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">Byte</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">Integer</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">Short</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">Long</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">Float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">Double</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">Character</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">Boolean</td></tr></tbody></table><h2 id="String">String</h2><ol><li><p>字符串的构造方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;第一个字符串:&quot;</span> + str1);   <span class="comment">// 第一个字符串:</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] c = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二个字符串：&quot;</span> + str2);   <span class="comment">// 第二个字符串：ABC</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] b = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b);</span><br><span class="line">        System.out.println(<span class="string">&quot;第三个字符串：&quot;</span> + str3);   <span class="comment">// 第三个字符串：abc</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;第四个字符串：&quot;</span> + str4);   <span class="comment">// 第四个字符串：Hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串常量池<br>程序中直接用双引号表示的字符串，就在字符串池中。<br>字符串常量池存在堆中。因为引号表示的字符串，是不能更改的，相当于一个常量。而通过字符数组（或者字节数组）创建的字符串的内容，根据字符数组的改变而改变，它存的地址是数组地址。</p><blockquote><p>对于基本类型来说，== 是进行<em><strong>数值</strong></em>的比较；<br>对于引用类型来说，== 是进行<em><strong>地址值</strong></em>的比较。</p></blockquote> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStringPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] c = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line"></span><br><span class="line">        System.out.println(str1 == str2);   <span class="comment">//true</span></span><br><span class="line">        System.out.println(str1 == str3);   <span class="comment">//false</span></span><br><span class="line">        System.out.println(str3 == str2);   <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串常用方法</p></li></ol><ul><li><p>equals<br><code>public boolean equals(object obj)</code>：参数可以是任意对象，只有参数为字符串并且内容想到才返回true，否则返回false。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStringEquals</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;LeLe&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;LeLe&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] c = &#123;<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;lele&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(str1.equals(str2));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(str2.equals(str3));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(str1.equals(str3));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(str1.equals(str4));  <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>equalsIgnoreCase<br><code>public boolean equalsIgnoreCase(String str)</code>：忽略大小写，比较内容。<br>上面的例子中：<br><code>System.out.println(str1.equalsIgnoreCase(str4));    // true</code></p></li><li><p>length<br><code>str1.length()</code>：获取字符串字符个数。</p></li><li><p>concat<br><code>public String concat(String str)</code>：将当前字符串和参数字符串拼接，并返回新的字符串。</p></li><li><p>charAt<br><code>public char charAt(int index)</code>：获取指定索引位置的单个字符。索引从0开始。</p></li><li><p>indexOf<br><code>public int indexOf(String str)</code>：查找参数字符串在本字符串当中首次出现的索引位置，如果没有，返回-1。<br><strong>上面四个方法的示例如下：</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStringGet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;LeLe&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;str1的长度为：&quot;</span> + str1.length());    <span class="comment">// str1的长度为：4</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;str1 + str2为：&quot;</span> + str1.concat(str2));    <span class="comment">// str1 + str2为：LeLeHello</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;str2的第3个字符为：&quot;</span> + str2.charAt(<span class="number">1</span>));    <span class="comment">// str2的第3个字符为：e</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Le在str1中首次出现的索引为:&quot;</span> + str1.indexOf(<span class="string">&quot;Le&quot;</span>));   <span class="comment">// Le在str1中首次出现的索引为:0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>substring<br><code>public String substring(int index):</code>：截取从参数位置一直到字符串结尾。返回新字符串。<br><code>public String substring(int begin, int end)</code>：截取从begin到end中间的字符串。<strong>左闭右开[begin,end)</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSubString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello,LeLe&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(str1.substring(<span class="number">6</span>));  <span class="comment">// LeLe</span></span><br><span class="line">        System.out.println(str1.substring(<span class="number">0</span>,<span class="number">5</span>));    <span class="comment">// Hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>toCharArray<br><code>public char[] toCharArray()</code>：将当前字符串拆分成字符数组作为返回值。</p></li><li><p>getBytes<br><code>public byte[] getBytes()</code>：获取当前字符串底层的字节数组。</p></li><li><p>replace<br><code>public String replace(CharSequence oldString,CharSequence newString)</code>：将所有出现的老字符串替换成新的字符串，返回替换之后的新的字符串。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStringConvert</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;LeLe&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] c = str1.toCharArray();</span><br><span class="line">        System.out.println(c[<span class="number">1</span>]);   <span class="comment">// e</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] b = str1.getBytes();</span><br><span class="line">        System.out.println(b[<span class="number">2</span>]);   <span class="comment">// 76</span></span><br><span class="line"></span><br><span class="line">        System.out.println(str1.replace(<span class="string">&quot;Le&quot;</span>, <span class="string">&quot;Ba&quot;</span>));</span><br><span class="line">        <span class="comment">// BaBa</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>split<br><code>public String[] split(String regex)</code>：按照参数的规则，将字符串切分成若干部分。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStringSplit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello,LeLe,HaHa,Zhang San&quot;</span>;</span><br><span class="line">        String[] array1 = str1.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array1.length; i++) &#123;</span><br><span class="line">            System.out.println(array1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Hello</span></span><br><span class="line">        <span class="comment">// LeLe</span></span><br><span class="line">        <span class="comment">// HaHa</span></span><br><span class="line">        <span class="comment">// Zhang San</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：split方法的参数其实是一个<strong>正则表达式</strong>。需要注意转义。如按照英文句点&quot;.“来切分，必须写” \\. &quot;</p></blockquote></li></ul><ol start="4"><li>拼接：<ul><li>可以直接使用 “+”号 将两个字符串进行拼接；</li><li>字符串与非字符串用“+”号拼接时，非字符会被转成字符串，输出中常用</li><li>多个字符串拼接可以使用join方法：<code>String s = String.join(&quot;/&quot;,&quot;good&quot;,&quot;bad&quot;,&quot;haha&quot;) // good/bad/haha</code></li></ul></li><li>不可变字符串：String类没有提供修改字符串的方法，在Java中，字符串相当于存放在一个公共的存储池中，字符串变量指向存储池中相应的位置，编译期可以让字符串共享。当字符串变量不使用后，Java会进行垃圾回收。</li><li>空串与null：空串是长度为0，内容为空的字符串，判断字符串是否为空：<code>if(str.length() == 0)</code>或者<code>if(str.equals(&quot;&quot;))</code>；null表示没有任何对象与该变量关联，判断一个字符串是否为null：<code>if(str == null)</code></li><li>字符串的构建：由较短的字符串构建字符串时，采用字符串连接的方式效率比较地下。每次连接字符串，都会创建一个新的String对象，耗时耗空间。因此可以使用StringBuilder类。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> String <span class="title function_">implicit</span><span class="params">(String[] fields)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            res += fields[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">explicit</span><span class="params">(String[] fields)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            res.append(fields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面两个方法各自实现了字符串的拼接，我们通过编译，得到字节码，如下图：<br><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/datastringBuilderTest01.jpg" alt=""><br>字节码的8-35行构成一个循环体，循环体内new了一个StringBuilder对象，也就是说每次循环都会创建一个新的StringBuilder对象。<br><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/datastringBuilderTest02.jpg" alt=""><br>而第二个方法，它只创建了一个StringBuilder对象。</p><h2 id="switch语句">switch语句</h2><ol><li>用法：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(choice) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>switch语句将从与选项值匹配的case标签处开始执行，直到碰到break语句，或者一直执行到switch语句的结束处。如果没有匹配的case，并有default语句，就执行default语句</li></ol><blockquote><p><strong>注意</strong>：如果case结尾没有break，程序会继续执行下一个case分支语句</p></blockquote><ol start="3"><li>case的标签可以是：char、byte、short、int的常量表达式，也可以为枚举或者字符串字面量</li><li>switch使用枚举时,不必在每个标签中指明枚举名：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Size</span> <span class="variable">sz</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="keyword">switch</span>(sz) &#123;</span><br><span class="line">    <span class="keyword">case</span> SMALL: <span class="comment">// no need to use Size.SMALL</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大数值">大数值</h2><ol><li>java.math包中的：BigInteger和BigDecimal。这两个类可以处理包含任意长度数字序列的数值，前者实现了任意精度的整数运算，后者则实现了任意精度的浮点数计算。</li><li>可以使用valueOf方法将普通数值转换为大数值：<code>BigInteger num = BigInteger.valueOf(100)</code></li><li>大数值的运算不能使用算数运算符，需要使用大数值类中的add、subtract、multiply、divide、mod方法</li><li>大数值的divide方法需要给出舍入方式，RoundingMode.HALF_UP为四舍五入</li></ol><h2 id="Arrays-sort">Arrays.sort()</h2><ol><li>默认为升序排序</li><li>采用了双基准快排(DualPivotQuicksort)。快排采用分治的思想，用一个pivot将原数组分成两个子数组，然后递归。双基准快排则是采用两个pivot，将原数组分成三部分（x &lt; pivot1 ; pivot1 &lt;= x &lt;= pivot2 ; x &gt; pivot3）,然后递归。</li><li>Arrays.sort()采用了很多排序方法，不同的情况则使用不同的排序方法。我们假设原数组长度为length<ul><li>length &lt;= 47 ：使用插入排序</li><li>47 &lt; length &lt;= 286 ：使用快速排序</li><li>length &gt; 286 并且 数组高度结构化(基本有序) ：归并排序</li><li>length &gt; 286 并且 基本无序或逆序 ： 快速排序</li></ul></li><li>双基准快排的细节：<ul><li>在选取pivot时，首先通过位运算，获取数组长度的1/7左右</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inexpensive approximation of length / 7</span></span><br><span class="line"><span class="type">int</span> <span class="variable">seventh</span> <span class="operator">=</span> (length &gt;&gt; <span class="number">3</span>) + (length &gt;&gt; <span class="number">6</span>) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>然后选取数组的中间位置e3,以及e3左右1/7、2/7的位置，分别为e1、e2和e4、e5</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Sort five evenly spaced elements around (and including) the</span></span><br><span class="line"><span class="comment"> * center element in the range. These elements will be used for</span></span><br><span class="line"><span class="comment"> * pivot selection as described below. The choice for spacing</span></span><br><span class="line"><span class="comment"> * these elements was empirically determined to work well on</span></span><br><span class="line"><span class="comment"> * a wide variety of inputs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">e3</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// The midpoint</span></span><br><span class="line"><span class="type">int</span> <span class="variable">e2</span> <span class="operator">=</span> e3 - seventh;</span><br><span class="line"><span class="type">int</span> <span class="variable">e1</span> <span class="operator">=</span> e2 - seventh;</span><br><span class="line"><span class="type">int</span> <span class="variable">e4</span> <span class="operator">=</span> e3 + seventh;</span><br><span class="line"><span class="type">int</span> <span class="variable">e5</span> <span class="operator">=</span> e4 + seventh;</span><br></pre></td></tr></table></figure><ul><li>然后对5个索引进行排序，这里用的是插入排序。排完后放回5个位置中</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sort these elements using insertion sort</span></span><br><span class="line"><span class="keyword">if</span> (a[e2] &lt; a[e1]) &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[e2]; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (a[e3] &lt; a[e2]) &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[e3]; a[e3] = a[e2]; a[e2] = t;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[e4] &lt; a[e3]) &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[e4]; a[e4] = a[e3]; a[e3] = t;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; a[e2]) &#123; a[e3] = a[e2]; a[e2] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[e5] &lt; a[e4]) &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[e5]; a[e5] = a[e4]; a[e4] = t;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; a[e3]) &#123; a[e4] = a[e3]; a[e3] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; a[e2]) &#123; a[e3] = a[e2]; a[e2] = t;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Pointers</span></span><br><span class="line"><span class="type">int</span> <span class="variable">less</span>  <span class="operator">=</span> left;  <span class="comment">// The index of the first element of center part</span></span><br><span class="line"><span class="type">int</span> <span class="variable">great</span> <span class="operator">=</span> right; <span class="comment">// The index before the first element of right part</span></span><br></pre></td></tr></table></figure><ul><li>如果5个元素都不相同，则e2为pivot1，e4为pivot3，然后继续双基准快排</li><li>如果5个元素存在相同的，则以e3为pivot进行普通快排</li></ul></li></ol><h2 id=""></h2><h2 id="HashMap（待补充）">HashMap（待补充）</h2><ol><li>底层？<ul><li>初始大小16，默认负载因子0.75（可自定义），12时扩容，扩容一倍即32</li><li>HashMap存的是Node节点，Node节点里包含key和value</li><li>HashMap由数组+单向链表</li></ul></li></ol><h2 id="Java内存结构概述">Java内存结构概述</h2><ol><li>栈(Stack): 存放方法中的局部变量。一旦超出作用域，java会自动释放它的内存空间。</li><li>堆(Heap): 凡是new出来的东东（对象、数组等等），都存放在堆中。<br>堆中的东西都有一个内存地址值（16进制），且都有一个默认初始值。规则如下：<br>int默认为0；double默认为0.0；字符默认为’\u0000’；布尔默认为false；引用类型默认为null。<br>实体不再被使用后，会在不确定的时间内被垃圾回收器回收。</li><li>方法区(Method Area)：包含class和static变量。</li><li>本地方法栈(Native Method Stack)：与操作系统相关。</li><li>寄存器(pc Register)：CPU相关。CPU访问寄存器执行速度远大于在主存上的执行速度。</li></ol><h2 id="面向对象三大特征">面向对象三大特征</h2><ol><li><p>封装：将实现的细节隐藏，对外界不可见。需要的时候直接调用即可，不需要知道实现细节。<br>（1） 方法就是一种封装<br>（2） 关键字private也是一种封装：使用private修饰后，只能在类的内部进行访问。在本类范围外则不能直接访问，不能对其进行修改。间接访问static成员变量，可以定义一组getter/setter方法。</p></li><li><p>继承：将共性提取到父类中。继承是多态的前提。<br>Java是<strong>单继承</strong>的。可以<strong>多级继承</strong>。</p></li><li><p>多态：</p></li></ol><h2 id="this关键字">this关键字</h2><p>方法的局部变量和类的成员变量重名时，会就近使用方法的局部变量。如果要访问类的成员变量，需要使用this。格式：this.成员变量名。</p><blockquote><p>ps：谁调用的方法，谁就是this。也就是当前的对象。</p></blockquote><h2 id="构造方法">构造方法</h2><p>构造方法是用来创建对象的方法。一般通过new关键字来创建对象时调用的。格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 类名称(参数类型 参数名称, ...)&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>构造方法的名称必须和类名称完全一样。</li><li>构造方法无返回值。</li><li>如果无构造方法，默认一个无参构造方法，方法体啥都不做。</li><li>构造方法可以重载（方法名相同，参数列表不同）。</li></ol><h2 id="static">static</h2><ol><li>使用static关键字修饰的成员变量，不再属于对象自己，而是属于类的。所有的对象共享同一份。</li><li>使用static关键字修饰的成员方法，就是静态方法，它不再属于对象，而是属于类的。</li><li>如果没有static关键字，必须先创建对象，然后通过对象来使用。<br>如果有static关键字，可以直接通过类名称来使用。<br>无论是成员变量还是成员方法，如果有了static关键字修饰，都推荐使用类名称进行使用。</li><li>静态代码块：当第一次用到本类时，静态代码快执行唯一的一次。<br>静态内容总是优先于非静态，所以静态代码快比构造方法先执行。<br>一般用来一次性对静态成员变量进行赋值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名称&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 静态代码块的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>静态不能直接访问非静态。因为内存中是先有的静态内容，后有的非静态内容。</li><li>静态方法中不能使用this。this代表当前对象。</li><li>静态变量存在内存中的方法区里的静态区中。根据类名称访问静态成员变量的时候，和对象（存在内存的堆中）没关系，只和类有关系。</li></ol></blockquote><p>Demo01</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">idCounter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String room;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = ++idCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStaticField</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        Student.room = <span class="string">&quot;Room 101&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span> + one.getId() + <span class="string">&quot;,name:&quot;</span> + one.getName()</span><br><span class="line">                + <span class="string">&quot;,age:&quot;</span> + one.getAge() + <span class="string">&quot;,room:&quot;</span> + Student.room);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">two</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;呆子&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span> + two.getId() + <span class="string">&quot;,name:&quot;</span> + two.getName()</span><br><span class="line">                + <span class="string">&quot;,age:&quot;</span> + two.getAge() + <span class="string">&quot;,room:&quot;</span> + Student.room);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output:</span></span><br><span class="line">    <span class="comment">//  id:1,name:张三,age:20,room:Room 101</span></span><br><span class="line">    <span class="comment">//  id:2,name:呆子,age:10,room:Room 101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo02</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">numStatic</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一个普通的成员方法。&quot;</span>);</span><br><span class="line">        <span class="comment">// 成员方法可以访问成员变量，也可以访问静态变量</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(numStatic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodStatic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个static方法。&quot;</span>);</span><br><span class="line">        <span class="comment">// 静态方法只能访问静态变量</span></span><br><span class="line">        System.out.println(numStatic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01StaticField</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        obj.method();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态方法可以使用对象名来调用，也可以直接通过类名称来调用</span></span><br><span class="line">        obj.methodStatic(); <span class="comment">// 不推荐，这种写法编译后仍会被翻译成“类名称.静态方法名”</span></span><br><span class="line">        MyClass.methodStatic();  <span class="comment">// 推荐</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重写">重写</h2><ol><li>重写：在继承关系中，方法名一样，参数一样。<br>重载：方法名一样，参数不一样。</li><li>@override写在方法前，检测是否是有效的正确的重写。</li></ol><h2 id="父子类构造方法的访问">父子类构造方法的访问</h2><ol><li>子类构造方法中，默认一个<code>super();</code>调用，必须先调用父类构造，再调用子类构造。</li><li>子类构造可以通过super关键字来调用父类重载构造。</li><li>super的父类构造调用必须是子类构造方法中的第一个语句，且只能有一个super调用。</li></ol><h2 id="super关键字">super关键字</h2><ol><li>在子类成员方法中访问父类的成员变量。<code>super.xxx</code></li><li>在子类的成员方法中访问父类的成员方法。<code>super.xxx()</code></li><li>在子类的构造方法中访问父类的构造方法。<code>super()</code></li></ol><h2 id="this关键字-2">this关键字</h2><ol><li>在本类的成员方法中，访问本类的成员变量。<code>this.xxx</code></li><li>在本类的成员方法中，访问本类的另一个成员方法。<code>this.xxx()</code></li><li>在本类的构造方法中，访问本类的另一个构造方法。<code>this(...)</code></li></ol><blockquote><p>注意：在第三种用法中，<code>this(...)</code>调用必须也是构造方法的第一个且唯一的语句。super和this两种构造调用，不能同时使用。</p></blockquote><h2 id="抽象类">抽象类</h2><ol><li>抽象类不能创建对象。</li><li>抽象类可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</li><li>抽象类不一定包含抽象方法，有抽象方法一定是抽象类。</li><li>抽象类的子类，必须重写抽象父类中所有的抽象方法。</li></ol><h2 id="接口">接口</h2><ul><li>接口没有静态代码块或者构造方法。</li><li>一个类的直接父类是唯一的，单一个类可以同时实现多个接口。</li><li>如果实现类所实现的多个接口中，存在重复的抽象方法，只需要覆盖重写一次即可。</li><li>如果实现类没有覆盖重写所有接口的所有抽象方法，那么实现类必须为一个抽象类。</li><li>如果实现类所实现的多个接口中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</li><li>一个类如果父类中的方法，和接口中的默认方法产生冲突，优先用父类当中的方法。</li></ul><h3 id="成员变量">成员变量</h3><p>格式： <code>[public] [static] [final] 数据类型 常量名称 = 数据值;</code></p><blockquote><p>常量必须进行赋值，一旦赋值，不能改变。<br>常量命名建议全大写，用下划线分隔。</p></blockquote><h3 id="接口中的抽象方法">接口中的抽象方法</h3><p>格式：  <code>[public] [abstract] 返回值类型 方法名称(参数列表);</code></p><blockquote><p>实现类必须覆盖重写接口所有的抽象方法，除非实现类也是抽象类。</p></blockquote><h3 id="接口的默认方法">接口的默认方法</h3><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="keyword">default</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>接口中的默认方法，可以解决接口升级的问题。如果接口需要添加一个新的抽象方法，但不能影响以及运行的实现类，则可以使用默认方法。</li><li>接口的默认方法，可以通过接口实现类的对象直接调用。</li><li>接口的默认方法，也可以被接口实现类进行覆盖重写。</li></ol></blockquote><h3 id="接口的静态方法">接口的静态方法</h3><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>静态方法不能通过接口实现类的对象来调用，必须通过接口名称来调用。<br>格式：接口名称.静态方法名(参数);</p></blockquote><h3 id="私有方法">私有方法</h3><p>（Java 9之后）格式：</p><ol><li>普通私有方法：<code>public 返回值类型 方法名称(参数列表) &#123; 方法体 &#125;</code></li><li>静态私有方法：<code>public static 返回值类型 方法名称(参数列表) &#123; 方法体 &#125;</code></li></ol><blockquote><p>private的方法只有接口自己使用。</p></blockquote><h2 id="Iterator迭代器">Iterator迭代器</h2><p>对集合进行遍历。两个常用方法：</p><ol><li>boolean hasNext():如果仍然有元素可以迭代，则返回true；判断集合是否还有下一个元素，有则返回true，无则返回false。</li><li>E next():返回迭代的下一个元素；取出集合中的下一个元素。<br>Iterator是一个接口，无法直接用，需要使用Iterator接口的实现类对象。<br>Collection接口中的iterator()方法，返回的就是迭代器的实现类对象<br><code>Iterator&lt;E&gt; iterator()</code> 返回在此collection的元素上进行迭代的迭代器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoIterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;马云&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for遍历">for遍历</h2><p>使用的Iterator迭代器，形式上是for。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:list) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型">泛型</h2><p>未知数据类型，当创建对象或者具体使用的时候，再确定泛型的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericClass</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> E name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(E name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFanxing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GenericClass&lt;Integer&gt; gc = <span class="keyword">new</span> <span class="title class_">GenericClass</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        gc.setName(<span class="number">6</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">gcName</span> <span class="operator">=</span> gc.getName();</span><br><span class="line">        System.out.println(gcName); <span class="comment">// 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射">反射</h2><ul><li>反射机制：将类的各个组成部分封装为其他<strong>对象</strong>。</li><li>java代码经历的三个阶段：<ul><li><p>Source源代码阶段(存在硬盘)：源码(xxx.java),编译后，字节码文件(xxx.class)。字节码文件存放成员变量、构造方法、成员方法等等。</p></li><li><p>Class类对象阶段：通过类加载器(ClassLoader)将字节码文件加载到内存中去。<br>在内存中如何表述字节码文件的内容？Class类对象。<br>Class类对象包括用来描述成员变量、构造方法、成员方法的若干对象。<br>如成员变量，使用<code>Field[] fields</code>这样一个数组来表示所有的成员变量。<br>如构造方法，使用<code>Constructor[] cons</code>来表示所有的构造器。<br>成员方法，使用<code>Method[] methods</code>来表示所有成员方法。<br>之后可以通过Class类对象的行为，来new对象啊。。等等</p></li><li><p>Runtime运行时阶段:xxx对象，new xxx()。</p></li></ul></li></ul><h3 id="获取Class类对象的方式">获取Class类对象的方式</h3><ol><li><p>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象。</p><ul><li>多用于配置文件，将类名定义在配置文件中。读取文件，加载类。</li></ul></li><li><p>类名.class：通过类名的属性class获取。</p><ul><li>多用于参数的传递。</li></ul></li><li><p>对象.getClass()：getClass()方法在Object类中定义。</p><ul><li>多用于对象的获取字节码的方式。</li></ul><p>Demo：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 1. Class.forName(&quot;全类名&quot;)</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.demo.person.Person&quot;</span>);</span><br><span class="line">        System.out.println(cls1);   <span class="comment">// class com.demo.person.Person</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 2. 类名.class</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls2</span> <span class="operator">=</span> Person.class;</span><br><span class="line">        System.out.println(cls2);   <span class="comment">// class com.demo.person.Person</span></span><br><span class="line">        <span class="comment">// 3. 对象.getClass();</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls3</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">        System.out.println(cls3);   <span class="comment">// class com.demo.person.Person</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// ==比较三个对象</span></span><br><span class="line">        System.out.println(cls1==cls2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(cls1==cls3); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>结论：同一个字节码文件(*.class)在一次程序运行过程中，只被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</li></ul><h3 id="Class对象的功能">Class对象的功能</h3><ul><li>获取功能：<ol><li><p>获取成员变量</p><ul><li>Field[] getFields()：获取所有<strong>public</strong>修饰的成员变量</li><li>Field getField(String name)：获取指定名称的<strong>public</strong>修饰的成员变量</li><li>Field[] getDeclaredFields():获取所有的成员变量，不考虑修饰符</li><li>Field getDeclaredFields(String name)</li><li>Field操作：<ol><li>设置值：<code>void set(object obj, boject value)</code></li><li>获取值：<code>get(object obj)</code></li><li>忽略访问权限修饰符的安全检查(暴力反射)：setAccessible(true)</li></ol></li></ul><p>person类：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String public_a;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> protected_b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> private_d;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, public_a=&#x27;&quot;</span> + public_a + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, protected_b=&quot;</span> + protected_b +</span><br><span class="line">                <span class="string">&quot;, c=&quot;</span> + c +</span><br><span class="line">                <span class="string">&quot;, private_d=&quot;</span> + private_d +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eating...&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 0. 获取person.Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">personClass</span> <span class="operator">=</span> Person.class;</span><br><span class="line">        <span class="comment">// 1. Field[] getFields()</span></span><br><span class="line">        Field[] fields = personClass.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);  <span class="comment">// public int com.demo.classDemo.Person.public_a</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. Field getField(String name)</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">a</span> <span class="operator">=</span> personClass.getField(<span class="string">&quot;public_a&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取成员变量a的值</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> a.get(p);</span><br><span class="line">        System.out.println(value);  <span class="comment">// null</span></span><br><span class="line">        <span class="comment">// 设置值</span></span><br><span class="line">        a.set(p, <span class="string">&quot;张三&quot;</span>); <span class="comment">// Person&#123;name=&#x27;null&#x27;, age=0, public_a=&#x27;张三&#x27;, protected_b=0, c=0, private_d=0&#125;</span></span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.Field[] getDeclaredFields()</span></span><br><span class="line">        Field[] declaredFields = personClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field declaredField : declaredFields)&#123;</span><br><span class="line">            System.out.println(declaredField);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        private java.lang.String com.demo.classDemo.Person.name</span></span><br><span class="line"><span class="comment">        private int com.demo.classDemo.Person.age</span></span><br><span class="line"><span class="comment">        ...共6个...</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 4. Field getDeclaredFields(String name)</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">d</span> <span class="operator">=</span> personClass.getDeclaredField(<span class="string">&quot;private_d&quot;</span>);</span><br><span class="line">        <span class="comment">// 忽略访问权限修饰符的安全检查，否则会报错</span></span><br><span class="line">        d.setAccessible(<span class="literal">true</span>);  <span class="comment">// 暴力反射</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value2</span> <span class="operator">=</span> d.get(p);</span><br><span class="line">        System.out.println(value2); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取构造方法</p><ul><li>Constructor&lt;?&gt;[] getConstructors()</li><li>Constructor&lt;T&gt; getConstructor(类&lt;?&gt;… parameterTypes)</li><li>Constructor&lt;T&gt; getDeclaredConstructors()</li><li>Constructor<?>[] getDeclaredConstructor(类<?>… parameterTypes)</li><li>Constructor:构造方法<ul><li>创建对象：<code>T newInstance(object... initargs)</code></li></ul></li></ul><p>Demo：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">personClass</span> <span class="operator">=</span> Person.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Constructor&lt;?&gt;[] getConstructors()</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> personClass.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        System.out.println(constructor1);  <span class="comment">// public com.demo.classDemo.Person(java.lang.String,int)</span></span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> constructor1.newInstance(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        System.out.println(person); <span class="comment">// Person&#123;name=&#x27;张三&#x27;, age=18, public_a=&#x27;null&#x27;, protected_b=0, c=0, private_d=0&#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取成员方法</p><ul><li>Method[] getMethods()</li><li>Method getMethod(String name, 类&lt;?&gt;… parameterTypes)</li><li>Method[] getDeclaredMethods()</li><li>Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes)</li><li>Method:方法对象<ul><li>执行方法:<code>object invoke(object obj, object...args)</code></li><li>获取方法名称:<code>String getName</code></li></ul></li></ul><p>Demo:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">personClass</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定名称的方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">eat_method</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        eat_method.invoke(p);   <span class="comment">// eating...</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">eat_method2</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;eat&quot;</span>, String.class);</span><br><span class="line">        eat_method2.invoke(p,<span class="string">&quot;apple&quot;</span>);  <span class="comment">// eating...apple</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有public修饰的方法</span></span><br><span class="line">        Method[] methods = personClass.getMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method method:methods)&#123;</span><br><span class="line">            System.out.println(method); <span class="comment">// 除了Person的方法，还有Object里的方法</span></span><br><span class="line">        <span class="comment">//method.setAccessible(true);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取类名</p><ul><li>String getName()</li></ul></li></ol></li></ul><h3 id="案例">案例</h3><ul><li>需求:可以创建任意类的对象，并且执行其中任意的方法。</li><li>实现：<ol><li>配置文件</li><li>反射</li></ol></li><li>步骤：<ol><li>将需要创建的对象的全类名和需要执行的方法定义在配置文件中</li><li>在程序中加载读取配置文件</li><li>使用反射技术来加载类文件进内存</li><li>创建对象</li><li>执行方法<br>配置文件（pro.properties）：注意：配置文件放在src目录下<br><code>className=com.demo.classDemo.Person</code><br><code>methodName=eat</code></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            前提：不能改变改类的任何代码，可以创建任意的对象，可以执行任意方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 1. 加载配置文件</span></span><br><span class="line">        <span class="comment">// 1.1 创建Properties对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 1.2 加载配置文件，转换为一个集合</span></span><br><span class="line">        <span class="comment">// 1.2.1 获取class目录下的配置文件</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ReflectTest.class.getClassLoader();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;pro.properties&quot;</span>);</span><br><span class="line">        pro.load(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取配置文件中定义的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.加载该类进内存</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">        <span class="comment">// 4.创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        <span class="comment">//5.获取方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//6.执行方法</span></span><br><span class="line">        method.invoke(obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解">注解</h2><ul><li><p>概念：说明程序的。给计算机看的。</p></li><li><p>使用：<code>@注解名称</code></p></li><li><p>分类：</p><ol><li>生成javadoc文档</li><li>编译检查（如<code>@Override</code>）</li><li>代码分析（用反射）</li></ol></li><li><p>JDK中预定义的一些注解</p><ul><li><code>@Override</code>:检测被该注解标注的方法是否继承自父类（接口）的</li><li><code>@Deprecated</code>：该注解标注的内容表示已过时</li><li><code>@SuppressWarnings(&quot;all&quot;)</code>：压制警告</li></ul></li><li><p>自定义注解</p><ul><li>格式：<ul><li>元注解</li><li><code>public @interface 注解名称&#123; 属性列表; &#125;</code></li></ul></li><li>本质：注解本质上是一个接口，该接口默认继承Annotation接口<br><code>public interface Myanno extends java.lang.annotation.Annotation &#123;&#125;</code></li><li>属性：接口中的抽象方法<ul><li>要求：<ol><li>属性的返回值类型有以下取值<ul><li>基本数据类型</li><li>字符串</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul></li><li>定义了属性，在使用时需要给属性赋值。<ul><li>定义属性时可以使用<strong>default</strong>设置默认值。</li><li>If只有一个属性需要赋值，并且属性的名称是<strong>value</strong>，则<strong>value</strong>可以省略。</li><li>数组赋值时，值使用{ }。如果数组中只有一个值，可省略{ }。</li></ul></li></ol></li></ul></li><li>元注解：用于描述注解的注解。<ul><li><code>@Target</code>：描述注解能够作用的位置<ul><li>ElementType取值：<ul><li>TYPE：可以作用于类上</li><li>METHOD：可以作用于方法上</li><li>FIELD：可以作用于成员变量上</li></ul></li></ul></li><li><code>@Retention</code>：描述注解被保留的阶段<ul><li><code>@Retention(RetentionPolicy.RUNTIME)</code>：当前被描述的注解，会保留到Class字节码文件中，并被JVM读取到。</li></ul></li><li><code>@Documented</code>：描述注解是否被抽取到API文档中</li><li><code>@Inherited</code>：描述注解是否被子类继承</li></ul></li></ul></li><li><p>在程序使用（解析）注解：获取注解中定义的属性值</p><ol><li>获取注解定义的位置（类、方法等等）的对象。（Class、Method、Field）</li><li>获取指定的注解。<code>getAnnotation(Class)</code></li><li>使用注解中的抽象方法获取配置的属性值。</li></ol><p>注解：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 描述需要执行的类名和方法名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span> <span class="comment">// 作用在类上面</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Pro &#123;</span><br><span class="line">    </span><br><span class="line">    String <span class="title function_">className</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">methodName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pro(className = &quot;com.demo.annotation.China&quot;,methodName = &quot;show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        前提：不能改变改类的任何代码，可以创建任意的对象，可以执行任意方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 1. 解析注解</span></span><br><span class="line">        <span class="comment">// 1.1 获取该类的字节码文件对象</span></span><br><span class="line">        Class&lt;ReflectTest&gt; reflectTestClass = ReflectTest.class;</span><br><span class="line">        <span class="comment">// 2. 获取上面的注解对象</span></span><br><span class="line">        <span class="comment">// 在内存中生成了一个该注解接口的子类实现对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public class ProImpl implements Pro&#123;</span></span><br><span class="line"><span class="comment">                public String className()&#123;</span></span><br><span class="line"><span class="comment">                    return &quot;com.demo.annotation.China&quot;;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                public String methodName()&#123;</span></span><br><span class="line"><span class="comment">                    return &quot;show&quot;;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Pro</span> <span class="variable">annotation</span> <span class="operator">=</span> reflectTestClass.getAnnotation(Pro.class);</span><br><span class="line">        <span class="comment">// 3. 调用注解对象中定义的抽象方法，获取返回值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> annotation.className();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> annotation.methodName();</span><br><span class="line">        System.out.println(className);  <span class="comment">// com.demo.annotation.China</span></span><br><span class="line">        System.out.println(methodName); <span class="comment">// show</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
