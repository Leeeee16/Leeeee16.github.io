<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指Offer16-数值的整数次方</title>
      <link href="/2022/06/07/%E5%89%91%E6%8C%87Offer16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
      <url>/2022/06/07/%E5%89%91%E6%8C%87Offer16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-Offer-16-数值的整数次方"><a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>示例 1：</strong><br>输入：x = 2.00000, n = 10<br>输出：1024.00000</p><hr><p>思路参考题解：<a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/">https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/</a></p><p>思路是使用快速幂。简单来说就是将指数改写为二进制。然后通过循环复制<code>x *= x</code>，在指数二进制为1的位置，将结果乘上x即<code>res *= x</code>。详细的描述可以看参考题解。</p><p>对于指数为负数的处理，如果指数为负数，<code>x = 1 / x</code>并将指数再设置为正数即可。比如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>可以转化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mo stretchy="false">)</mo><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">(\frac12)^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> || x == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="type">long</span> <span class="variable">nn</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            nn = -nn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (nn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nn &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                res *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            nn &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode236-二叉树的最近公共祖先</title>
      <link href="/2022/06/06/LeetCode236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <url>/2022/06/06/LeetCode236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
      
        <content type="html"><![CDATA[<h4 id="236-二叉树的最近公共祖先"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>示例 1：</strong></p><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/LeetCode236-binarytree.png" alt=""></p><p>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p><hr><p>思路：如果root为p和q的最近公共祖先，则一共有三种情况：</p><ol><li><code>p</code>和<code>q</code>在<code>root</code>的两侧</li><li><code>p = root</code>，且<code>q</code>在<code>root</code>的左子树或者右子树中；</li><li><code>q = root</code>，且<code>p</code>在<code>root</code>的左子树或者右子树中；</li></ol><p>考虑使用先序遍历，遇到p或者q时返回。从下往上回溯，当p和q在root异侧时，返回root。</p><p>详见代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">// p和q在root两侧，则最近公共祖先为root</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p和q在root右子树，则最近公共祖先为right</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考题解：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer54-二叉搜索树的第k大节点</title>
      <link href="/2022/06/04/%E5%89%91%E6%8C%87Offer54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/"/>
      <url>/2022/06/04/%E5%89%91%E6%8C%87Offer54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h4><p>给定一棵二叉搜索树，请找出其中第 <code>k</code> 大的节点的值。</p><hr><p>思路：对于二叉搜索树，<strong>中序遍历的倒序</strong>是<strong>递减</strong>的。题目中求第K打节点，可以转化为中序遍历倒序的第k个节点。</p><p>中序遍历过程中，如果–k之后，k的值为0，则表示遍历到第k个节点了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        <span class="comment">// 先--，再判断</span></span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> 深度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode113-路径总和II</title>
      <link href="/2022/06/04/LeetCode113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/"/>
      <url>/2022/06/04/LeetCode113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/</url>
      
        <content type="html"><![CDATA[<h4 id="113-路径总和-II"><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h4><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p>示例 1：</p><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/LeetCode113.jpg" alt=""></p><p>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<br>输出：[[5,4,11,2],[5,8,4,5]]</p><hr><p>思路：回溯思想+DFS实现，因为要返回所有的路径，因此用path记录当前遍历的路径。当遍历到叶节点并且节点的值等于targetSum时，即找到符合条件的路径。</p><p>遍历时更新targetSum为<code>targetSum - 当前节点的value</code></p><p>注意回溯时将路径path中最后一个节点移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dfs(root, ans, path, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; ans, Deque&lt;Integer&gt; path, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到一条符合的路径</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; root.val == targetSum) &#123;</span><br><span class="line">            path.addLast(root.val);</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            path.removeLast();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.addLast(root.val);</span><br><span class="line">        dfs(root.left, ans, path, targetSum - root.val);</span><br><span class="line">        dfs(root.right, ans, path, targetSum - root.val);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 回溯 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode79.单词搜索</title>
      <link href="/2022/06/03/LeetCode79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
      <url>/2022/06/03/LeetCode79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h4 id="79-单词搜索"><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h4><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/LeetCode-79.jpg" alt=""></p><p>输入：board = [[“A”,“B”,“C”,“E”],[“S”,“F”,“C”,“S”],[“A”,“D”,“E”,“E”]], word = “ABCCED”<br>输出：true</p><hr><p>思路：采用深度优先和回溯的思路。是一道比较典型的回溯题。</p><p>定义了一个方向数组用于深度遍历时确定方向。</p><p>定义visited数组用于记录元素是否已经访问过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span>[] DIRECTIONS = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rows;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cols;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[][] board;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] toCharArray;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[][] visited;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rows = board.length;</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.cols = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="built_in">this</span>.board = board;</span><br><span class="line">        <span class="built_in">this</span>.len = word.length();</span><br><span class="line">        <span class="built_in">this</span>.visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[rows][cols];</span><br><span class="line">        <span class="built_in">this</span>.toCharArray = word.toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> begin)</span> &#123;</span><br><span class="line">        <span class="comment">// 退出条件，遍历到最后一个字母</span></span><br><span class="line">        <span class="keyword">if</span> (begin == len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> toCharArray[begin] == board[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前字母与单词对应下标的字母一致，则继续向四周搜索</span></span><br><span class="line">        <span class="keyword">if</span> (toCharArray[begin] == board[x][y]) &#123;</span><br><span class="line">            visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 向四周寻找</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> x + DIRECTIONS[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">newY</span> <span class="operator">=</span> y + DIRECTIONS[i + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 新坐标在矩阵范围内并且没有访问过</span></span><br><span class="line">                <span class="keyword">if</span> (isInArea(newX, newY) &amp;&amp; !visited[newX][newY]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(newX, newY, begin + <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            visited[x][y] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isInArea</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 52. 两个链表的第一个公共节点</title>
      <link href="/2022/06/01/%E5%89%91%E6%8C%87%20Offer52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
      <url>/2022/06/01/%E5%89%91%E6%8C%87%20Offer52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><p>输入两个链表，找出它们的第一个公共节点。</p><p><strong>示例 1：</strong></p><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/LeetCode160.png" alt=""></p><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><hr><p>思路：如果A为Null或者B为NUll，则不会相交；</p><p>定义两个指针分别从A和B开始同时向后走，假设A到相交节点的距离为a（示例中则为2），B到相交节点的距离为b（示例中则为3），重合部分长度为c（示例中则为3）。</p><p>如果指针A完，即A为Null后，继续从B开始向后遍历；同理B走完后从A继续遍历；两个指针相遇时，即在相交节点。</p><p>相交是指针A走的距离为a+c+b；指针B走的距离为b+c+a。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">b</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            a = a == <span class="literal">null</span> ? headB : a.next;</span><br><span class="line">            b = b == <span class="literal">null</span> ? headA : b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/shuang-zhi-zhen-fa-lang-man-xiang-yu-by-ml-zimingm/">参考题解</a></p><blockquote><p>你变成我，走过我走过的路。<br>我变成你，走过你走过的路。<br>然后我们便相遇了…        😄</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode3.最长不含重复字符的子字符串</title>
      <link href="/2022/06/01/LeetCode3-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/06/01/LeetCode3-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h4 id="3-无重复字符的最长子串"><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: s = “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><hr><p>思路：采用滑动窗口的思路，保证窗口内的字符不重复。采用HashMap记录字符最后一次出现的下标。右指针向右遍历的过程中，如果遇到重复字符，则更新左指针，记录字符在map中的下标，并更新返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(i))) &#123;</span><br><span class="line">                left = Math.max(left, map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新map中的下标</span></span><br><span class="line">            map.put(s.charAt(i), i);</span><br><span class="line">            ans = Math.max(ans, i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>13行中，left指针需要取left和<code>map.get(s.charAt(i)) + 1</code>的较大者。</p><p>比如：&quot;abba&quot;这个用例，在i遍历到第二个b的时候，left取2。i继续往后走，走到下一个a的时候，如果只取<code>map.get(s.charAt(i)) + 1</code>，left则往前退了，因此需要取两者的较大者~</p><blockquote><p>还有一个<a href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/mian-shi-ti-48-zui-chang-bu-han-zhong-fu-zi-fu-d-9/">动态规划解</a>，感觉没有滑动窗口的思路好理解，因此只记录滑动窗口解</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer46-把数字翻译成字符串</title>
      <link href="/2022/05/31/%E5%89%91%E6%8C%87Offer46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/05/31/%E5%89%91%E6%8C%87Offer46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-Offer-46-把数字翻译成字符串"><a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h4><p>题目：给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p>样例：</p><blockquote><p>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, “bwfi”, “bczi”, “mcfi&quot;和&quot;mzi”</p><p>其中：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>&lt;</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">0 \leq num &lt; 2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span></span></span></span></p></blockquote><p>思路：动态规划题的核心是找到状态转移方程，以及定义好初始状态。</p><p>定义：dp[i]表示第i个数字结尾的方案数，那么转移方程有两种情况：</p><ol><li>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>两个数字可以被翻译，即在[10, 25]区间内，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i - 1] + dp[i - 2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></li><li>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>两个数字不能被翻译，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></li></ol><p>可以看到dp[i]的值仅和前两个dp值有关，因此可以优化空间数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">char</span>[] c = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">dp1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dp2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (c[i - <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (c[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            ans = <span class="number">10</span> &lt;= a &amp;&amp; a &lt;= <span class="number">25</span> ? dp1 + dp2 : dp2;</span><br><span class="line">            dp1 = dp2;</span><br><span class="line">            dp2 = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/2021/04/10/Redis%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/04/10/Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h4 id="Redis">Redis</h4><blockquote><p>面经整理，主要是理论知识</p></blockquote><h5 id="Redis基本数据类型">Redis基本数据类型</h5><p>key是字符串，value是5种：String、List、Hash、Set、Zset</p><p><strong>String</strong>：是SDS(Simple Dynamic String)，动态字符串，可修改，最长512M。</p><blockquote><p>扩展：为什么不用c语言的字符串？Redis如何解决</p><ul><li><p>多增加了字符串长度属性len：c语音中的字符串末尾有’\0’，并且获取长度是O(N)级别的。SDS只需O(1)</p></li><li><p>自动扩展空间：由于字符串经常会进行拼接操作，所以没有提取获取长度，可能会造成缓存区溢出。当 SDS 需要对字符串进行修改时，首先借助于 <code>len</code> 和 <code>alloc</code> 检查空间是否满足修改所需的要求，如果空间不够的话，SDS 会自动扩展空间，避免了像 C 字符串操作中的覆盖情况；</p></li><li><p>有效降低内存分配次数：SDS优化了修改字符串带来的内存重分配的次数，采用<strong>空间预分配(会分配多余的free空间)和惰性空间释放(缩减字符串后不会马上释放空间)</strong></p></li><li><p>二进制安全：因为存了长度，不用去判断空字符<code>\0</code></p></li></ul></blockquote><p><strong>List</strong>：相当于Java的LinkedList，插入删除O(1)，索引定位O(n)</p><p>​lrange：输出list指定范围的元素<code>lrange mylist 0 -1</code></p><p><strong>Hash</strong>：数组+链表 解决哈希冲突，实际上字典结构内部包含两个HashTable，用于扩容时的<strong>渐进式搬迁</strong>。当hash表中的<strong>元素个数等于第一位数组的长度</strong>时，扩容为原数组的两倍。如果Redis正在做 <code>bgsave(持久化命令)</code>，为了减少内存也得过多分离，Redis 尽量不去扩容，但是如果 hash 表非常满了，<strong>达到了第一维数组长度的 5 倍了</strong>，这个时候就会 <strong>强制扩容</strong>。</p><p>当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 <strong>元素个数低于数组长度的 10%</strong>，缩容不会考虑 Redis 是否在做 <code>bgsave</code>。</p><blockquote><p><strong>渐进式rehash</strong>：大字典扩容需要申请新数组，并将原数组所有元素重新挂接到新数组中，由于单线程，所以采用渐进式rehash，这会在rehash的过程中，保留新旧两个hash结构，查询时同时查两个，当全部迁移完成后，使用新的hash结构取而代之</p></blockquote><p><strong>Set</strong>：无序、唯一。</p><h5 id="Redis的zset的底层数据结构？">Redis的zset的底层数据结构？</h5><p>zset：唯一性，并为每个value赋予一个score值，代表排序权重</p><p>跳跃表：有序列表zset的数据结构，链表按照score排序，链表分层，上层的链表树约为下层的1/2，查询的时候从上层开始查，查询效率O(logN)</p><blockquote><p>为什么不用红黑树/平衡树？性能和实现考虑</p></blockquote><p>插入节点，根据随机算法来分配合理的层数，从期望上来看，50%的概率被分到第一层，25%的概率被分到第二层，1/4第三层…</p><p>跳表默认最大的层数为32层</p><p>插入的大致流程：声明存储变量、搜索当前节点插入的位置、生成插入节点、重排前向指针、重排后向指针并返回</p><img src="https://mmbiz.qpic.cn/mmbiz_png/ia1kbU3RS1H5ZLiaicqeR9mzkQuQLwvtFfQ5qUqf8c0vC3bfbc710Tz6iadcOlDYb39pApOUP9pCaUDQtuicUn9Jibvg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /><img src="https://mmbiz.qpic.cn/mmbiz_png/ia1kbU3RS1H5ZLiaicqeR9mzkQuQLwvtFfQclc3x7f7KuQtUMpfn1rP3I7mGVuOyydQjyhujAgTzo9z8XiacD0oJmA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /><p>元素排名：跳跃表在前向指针上增加了一个<code>span</code>属性，<strong>用来表示从前一个节点沿着当前层的forward指针跳到当前节点中间跳过了多少节点</strong>。因此可以沿着搜索路径，将所有经过的节点的跨度<code>span</code>值加起来就能得到最终的<code>rank</code>值</p><p>扩展：</p><p>Bitmap：布隆过滤器</p><p>HyperLogLog：不精确的去重计数功能，适合大规模去重统计</p><p>Geospatial：保存地理位置</p><p>pub/sub：订阅功能，简单的消息队列</p><p>Pipeline：批量执行一组指令，一次性返回结果，可以减少频繁的请求应答</p><p>Lua：支持Lua脚本执行一系列的功能。具有原子性</p><p>事务：只保证串行执行命令，并保证全部执行，但执行命令失败不会回滚，而是继续执行</p><h5 id="Redis-和-Memcached-的区别和共同点">Redis 和 Memcached 的区别和共同点</h5><p>MC：多线程异步IO，只支持K-V，最大失效时间30天，key和value大小有限制</p><p>Redis：单线程，采用非阻塞的异步事件处理机制，避免线程上下文切换的代价；支持持久化；支持<strong>多种数据结构</strong>；主从同步机制、集群</p><h5 id="Redis如何支持高并发">Redis如何支持高并发</h5><p>主从架构 + 读写分离</p><p>一主多从，主负责写，并负责将数据同步到其他slave节点上，从负责读</p><h5 id="为什么Redis用单线程而不是多线程">为什么Redis用单线程而不是多线程</h5><p><a href="https://draveness.me/whys-the-design-redis-single-thread">https://draveness.me/whys-the-design-redis-single-thread</a></p><p>CPU不是Redis的瓶颈，Redis的瓶颈是内存大小和网络带宽，数据都在内存中</p><p>单线程带来更高的可维护性，方便开发</p><p>单线程也可以并发处理客户端请求，IO多路复用</p><blockquote><p>4.0后引入多线程？只是在部分命令上引入(多个非阻塞的删除操作)，在整体架构上还是单线程模型</p></blockquote><h5 id="Redis的事务是怎么实现的">Redis的事务是怎么实现的</h5><p>redis事务是通过multi,exec,discard,watch/unwatch指令用来操作事务。</p><ul><li><p>mutil：开启事务，此后所有的操作将会添加到当前链接的事务“操作队列”中。</p></li><li><p>exec：提交事务</p></li><li><p>discard：取消事务，记住，此指令不是严格意义上的“事务回滚”，只是表达了“事务操作被取消”的语义，将会导致事务的操作队列中的操作不会被执行，且事务关闭。</p></li><li><p>watch/unwatch：“观察”，被watch的key如果被其他客户端修改，会discard；事务执行成功或discard会导致被watch的key变为unwatch</p><blockquote><p>这里的watch其实实现了一个CAS乐观锁，只有被watch的key没有改变时，才会exec执行事务</p></blockquote></li></ul><p>原理：EXEC指令将会触发事务中所有的操作被<strong>写入AOF文件</strong>（如果开启了AOF），然后开始在内存中实施这些数据变更操作<br>如果在EXEC指令被<strong>提交之前</strong>，Redis-server即检测到提交的某个指令存在<strong>语法错误</strong>，那么此事务将会被提前标记<strong>DISCARD</strong>，此后事务提交也将<strong>直接被驳回</strong>；但是如果在<strong>EXEC提交后</strong>，在实施数据变更时（Redis将不会预检测数据类型，比如你对一个“非数字”类型的key执行INCR操作），某个操作导致了<strong>ERROR</strong>，那么redis仍然<strong>不会回滚</strong>此前<strong>已经执行成功的操作</strong>，而且也不会中断ERROR之后的其他操作<strong>继续执行</strong>。</p><p>对于开发者而言，你务必关注事务执行后返回的结果（结果将是一个集合，按照操作提交的顺序排列，对于执行失败的操作，结果将是一个ERROR）。</p><h5 id="缓存的更新方式">缓存的更新方式</h5><p>可以在更新完DB后直接更新缓存；设置失效时间，可以看做数据不一致的最大容忍时间，可以在key失效时请求数据源获取新数据，重置失效时间；失效时，异步更新，防止数据源更新时出错</p><h5 id="缓存一致性问题">缓存一致性问题</h5><ol><li><p>先删除缓存，后更新数据库</p><p>如果删除缓存后，更新数据库的过程中，有线程进行读，缓存被删了，读数据库，读到旧数据，写入缓存，不一致</p><p>解决：延时双删：更新数据库的线程在更新完后，sleep一段时间，然后再删除一次缓存</p></li><li><p>先更新数据库，再删除缓存</p><p>如果更新成功，缓存删除失败，不一致</p><p>解决：通过消息队列，利用消息队列的重试机制，保证消息的<strong>最终一致性</strong></p></li><li><p>其他：设置缓存过期时间。</p></li></ol><h5 id="如果在更新Redis时服务器宕机，怎么办？">如果在更新Redis时服务器宕机，怎么办？</h5><p>持久化、主从、</p><h5 id="Redis的部署架构是什么样的？">Redis的部署架构是什么样的？</h5><p>单机、主从、集群</p><h5 id="Redis内存淘汰机制、几种淘汰策略">Redis内存淘汰机制、几种淘汰策略</h5><p>设置有效期</p><p>删除过期键的策略：定时删除、惰性删除、定时扫描</p><ul><li><strong>定时删除</strong> ：为每个键设置一个定时器，一旦过期时间到了，则将键删除。这种策略对内存很友好，但是对 <code>CPU</code> 不友好，因为每个定时器都会占用一定的 <code>CPU</code> 资源。</li><li><strong>惰性删除</strong> ：不管键有没有过期都不主动删除，等到每次去获取键时再判断是否过期，如果过期就删除该键，否则返回键对应的值。这种策略对内存不够友好，可能会浪费很多内存。</li><li><strong>定期扫描</strong> ：系统每隔一段时间就定期扫描一次，发现过期的键就进行删除。这种策略相对来说是上面两种策略的折中方案，需要注意的是这个定期的频率要结合实际情况掌控好，使用这种方案有一个缺陷就是可能会出现已经过期的键也被返回。</li></ul><p>淘汰没过期键的策略</p><table><thead><tr><th style="text-align:left">淘汰策略</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">volatile-lru</td><td style="text-align:left">根据 LRU 算法删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错</td></tr><tr><td style="text-align:left">allkeys-lru</td><td style="text-align:left">根据 LRU 算法删除所有的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错</td></tr><tr><td style="text-align:left">volatile-lfu</td><td style="text-align:left">根据 LFU 算法删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错</td></tr><tr><td style="text-align:left">allkeys-lfu</td><td style="text-align:left">根据 LFU 算法删除所有的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错</td></tr><tr><td style="text-align:left">volatile-random</td><td style="text-align:left">随机删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错</td></tr><tr><td style="text-align:left">allkeys-random</td><td style="text-align:left">随机删除所有键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错</td></tr><tr><td style="text-align:left">volatile-ttl</td><td style="text-align:left">根据键值对象的 ttl 属性， 删除最近将要过期数据。如果没有，则直接报错</td></tr><tr><td style="text-align:left">noeviction</td><td style="text-align:left">默认策略，不作任何处理，直接报错</td></tr></tbody></table><blockquote><p>衍生：Redis对LRU算法的改进，解决传统LRU的什么缺点？怎么改进的？抽样删除</p></blockquote><p>Redis热度数据管理：LRU：lru属性24位、全局属性lru_clock；LFU：lru属性高16位时钟低8位频数、频次递增(随机数、概率p公式、对数因子)、频次递减(<code>lfu-decay-time</code>、计算差值、除以<code>lfu-decay-time</code>)</p><h5 id="Redis缓存穿透和缓存雪崩？">Redis缓存穿透和缓存雪崩？</h5><p><strong>缓存雪崩</strong>：Redis中的缓存大面积失效，所有的流量直接打在数据库上，数据库亚历山大啊</p><p>解决方案：在往Redis中存数据的时候，设置随机的失效时间；或者考虑热点数据永不失效，有更新操作的时候更新一下缓存</p><p><strong>缓存穿透</strong>：缓存和数据库都没有的数据，而某个不良用户不断地发起请求，比如数据库中的id都大于0，我一直用小于0的id去请求，每次都能避开Redis，直接打在数据库上，造成数据库压力过大</p><p>解决方案1：在接口层增加校验，如用户权限校验、参数校验、不合法的直接返回Null给前端。比如id校验id&lt;=0直接拦截。</p><p>解决方案2：缓存和数据库都取不到的key，可以将对应key的value设置为null、错误提示等，具体看场景，设置个失效时间30秒。</p><p>解决方案3：<strong>布隆过滤器</strong></p><p><strong>缓存击穿</strong>：是指某个热点key，不停地扛着大并发，当这个key失效的瞬间，持续的大并发就会击穿缓存，直接请求数据库。</p><p>解决方案：设置热点数据永不过期，数据有更新时，同时更新缓存即可</p><p><strong>总结</strong>：上述三个问题，之前：Redis高可用，主从+哨兵，Redis集群，避免全盘崩溃</p><p>若还是发生了上述问题，采用本地缓存、限流、降级等方法，避免MySQL挂掉</p><p>发生问题之后，Redis持久化RDB+AOF，一旦重启，自动从磁盘加载数据，快速恢复缓存数据</p><p>哪怕限流，也不能让数据库挂掉，对用户来说多刷几次而已~</p><h5 id="布隆过滤器">布隆过滤器</h5><p>概念：用于检索一个元素是否在一个集合中。</p><p>原理：当元素被加入集合时，通过k个散列函数将这个元素映射成一个位(bit)数组中的k个点，把他们置成1。检索时，只要看对应的这些点是否为1，就大概率知道该集合中是否有该元素。</p><p>缺点：有可能误判，可能元素不在集合中，但k个bit位都为1；删除困难</p><h5 id="Redis持久化的方式">Redis持久化的方式</h5><p>两种持久化方式：RDB和AOF</p><h6 id="RDB"><strong>RDB</strong></h6><p>快照是一次全量备份，快照作为包含整个数据集的单个.rdb文件生成，快照是内存数据的二进制序列化形式，在存储上非常紧凑。</p><p>使用系统多进程<code>COW(Copy On Write)</code>机制的<code>fork</code>函数，产生一个<strong>子进程</strong>，<strong>子进程</strong>会拷贝<strong>父进程</strong>的部分<strong>代码段和数据段</strong>，<strong>快照持久</strong>化可以完全由<strong>子进程</strong>完成，<strong>父进程</strong>继续<strong>处理客户端请求</strong>。数据段由操作系统的<strong>页面</strong>组合而成，主进程在对某个页面进行修改时，会得到该页面的一份复制，然后<strong>在复制页上进行修改</strong>，而<strong>子进程</strong>相应的<strong>页面是没有变化</strong>的，子进程只需要遍历数据进行序列化写磁盘就行了。</p><p><strong>触发机制</strong>：手动、自动</p><p>自动触发：</p><ol><li>在配置文件中设置触发条件</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当在规定的时间内，Redis发生了写操作的个数满足条件，会触发发生BGSAVE命令。</span></span><br><span class="line"><span class="comment"># save &lt;seconds&gt; &lt;changes&gt;</span></span><br><span class="line"><span class="comment"># 当用户设置了多个save的选项配置，只要其中任一条满足，Redis都会触发一次BGSAVE操作</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1 </span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10 </span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000</span></span><br><span class="line"><span class="comment"># 以上配置的含义：900秒之内至少一次写操作、300秒之内至少发生10次写操作、</span></span><br><span class="line"><span class="comment"># 60秒之内发生至少10000次写操作，只要满足任一条件，均会触发bgsave</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>执行shutdown命令关闭服务器时，如果没有开启AOF，则会自动执行一次<code>bgsave</code></p></li><li><p>主从同步：master执行<code>bgsave</code>，并缓存该时间段的写操作，将rdb发送给slave，slave同步数据，最后master向所有slave发送缓存中的写操作，完成同步</p></li></ol><p><strong>执行流程</strong>：使用操作系统多进程的COW机制</p><ol><li>执行<code>bgsave</code>时，先看有不有子进程正在执行RDB/AOF持久化任务，有则返回</li><li>主进程<code>fork</code>一个子进程来执行RDF，<code>fork</code>操作会对主进程造成阻塞，只是<code>fork</code>期间阻塞，之后就不阻塞了</li><li>子进程根据主进程的内存生成临时快照文件，持久化完成后用临时快照文件替换原来的RDF文件。此过程主进程仍然可以响应写操作，但是是在内存页面的副本进行，不会影响子进程持久化工作</li><li>子进程完成后发消息给主进程</li></ol><p><strong>RDB的优缺点</strong></p><p>优点</p><ul><li>RDB文件小，适合定时备份，用于容灾</li><li>Redis加载RDB文件速度比AOF日志快很多，因为RDB存的是内存中的数据，而AOF日志记录的是指令，需要顺序执行所有指令来恢复</li></ul><p>缺点</p><ul><li>无法实时持久化，两次<code>bgsave</code>过程中的数据可能丢失</li><li><code>fork</code>子进程会阻塞Redis主进程</li><li>老版本的Redis可能不兼容新版本RDB格式文件</li></ul><h6 id="AOF"><strong>AOF</strong></h6><p>Append Only File，仅追加文件，AOF 日志是连续的增量备份。每次执行<strong>修改内存</strong>中数据集的写操作时，都会<strong>记录</strong>该操作。假设AOF记录了自Redis实例创建以来<strong>所有的修改性指令</strong>，那么就可以通过对一个空的Redis实例<strong>顺序执行所有指令</strong>，即<strong>重放</strong>，来恢复Redis当前实例的内存数据结构的状态</p><p>AOF会在持续运行中持续增大，因此需要定期进行AOF重写，对AOF日志进行瘦身</p><p>开启方式</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 此选项为aof功能的开关，默认为“no”，可以通过“yes”来开启aof功能  </span></span><br><span class="line"><span class="comment">## 只有在“yes”下，aof重写/文件同步等特性才会生效  </span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## 指定aof文件名称  </span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">appendonly.aof  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## 指定aof操作中文件同步策略，有三个合法值：always everysec no,默认为everysec  </span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec  </span></span><br><span class="line"><span class="comment">## 在aof-rewrite期间，appendfsync是否暂缓文件同步，&quot;no&quot;表示“不暂缓”，“yes”表示“暂缓”，默认为“no”  </span></span><br><span class="line"><span class="attr">no-appendfsync-on-rewrite</span> <span class="string">no  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## aof文件rewrite触发的最小文件尺寸(mb,gb),只有大于此aof文件大于此尺寸是才会触发rewrite，默认“64mb”，建议“512mb”  </span></span><br><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">64mb  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## 相对于“上一次”rewrite，本次rewrite触发时aof文件应该增长的百分比  </span></span><br><span class="line"><span class="comment">## 每一次rewrite之后，redis都会记录下此时“新aof”文件的大小(例如A)</span></span><br><span class="line"><span class="comment">## aof文件增长到A*(1 + p)之后，触发下一次rewrite，每一次aof记录的添加，都会检测当前aof文件的尺寸。  </span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br></pre></td></tr></table></figure><p>Linux对文件采用延迟写入，即每次写入先进缓存，到了已定时机再写入磁盘。</p><p>Linux提供了<code>fsync(int fd)</code>函数，可以将指定文件的内容强制从内核缓存刷到磁盘，但是是一个磁盘IO操作，非常耗时。因此<strong>Redis提供了3种AOF同步策略</strong>：</p><ul><li>always：每条AOF都立即同步，性能低，安全</li><li>everysec：每秒同步，默认的方式，性能安全较平衡</li><li>no：永不直接同步，全由操作系统决定。性能好但非常不安全</li></ul><p><strong>重写(Rewrite)机制</strong></p><p>不是基于源AOF文件，而是基于当前内存数据，类似于RDB快照的方式，使用更少的指令来记录内存中数据的状态。先存当前内存状态，再将重写期间的写操作从缓存写入AOF。</p><p><strong>触发机制</strong>：手动和自动</p><p>手动：<code>bgrewriteaof</code>命令：<code>redis-cli -h ip -p port bgrewriteaof</code></p><p>自动</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto-aof-rewrite-min-size</span>:<span class="string">表示运行AOF重写时文件最小体积，默认为64MB（我们线上是512MB）。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span>:<span class="string">代表当前AOF文件空间（aof_current_size）和上一次重写后AOF文件空间（aof_base_size）</span></span><br></pre></td></tr></table></figure><p><strong>AOF的优缺点</strong></p><p>优点：只是追加写日志，写增量信息，对服务器性能影响小，速度比RDB快，内存消耗少</p><p>缺点</p><ul><li>日志文件太大，需要不断重写瘦身，但和RDB文件比还是很大</li><li>使用AOF恢复数据时，比RDB慢</li></ul><h6 id="Redis4-0混合持久化">Redis4.0混合持久化</h6><p>RDB文件和AOF日志结合，AOF日志记录自RDB持久化开始到当前这段时间发生的增量数据。</p><p>大量数据使用RDB，性能高，恢复快；增量数据使用AOF，尽量保证数据不丢失</p><h5 id="Redis主从复制怎么实现的">Redis主从复制怎么实现的</h5><p>作用</p><ul><li>数据冗余：主从复制实现数据的热备份</li><li>故障恢复：主节点挂了，从节点可以提供服务，实现快速故障恢复</li><li>负载均衡：主从复制、读写分离，主提供写，从提供读</li></ul><p>实现原理</p><p><strong>准备阶段 - &gt; 数据同步阶段 - &gt; 命令传播阶段</strong></p><p>slave第一次连接到master时，master会启动子进程生成RDB快照，并把过程中的写请求存到缓存，RDB文件生成后，将RDB文件发给slave，并把缓存中的写操作也发给slave</p><p>之后的数据通过AOF日志同步</p><h5 id="Redis中的哨兵是干啥的">Redis中的哨兵是干啥的</h5><p>架构</p><p>哨兵节点：哨兵系统由一个或多个哨兵节点组成，不存储数据</p><p>数据节点：主、从都是数据节点</p><p>功能</p><ul><li><strong>监控（Monitoring）：</strong> 哨兵会不断地检查主节点和从节点是否运作正常。</li><li><strong>自动故障转移（Automatic failover）：</strong> 当 <strong>主节点</strong> 不能正常工作时，哨兵会开始 <strong>自动故障转移操作</strong>，它会将失效主节点的其中一个 <strong>从节点升级为新的主节点</strong>，并让其他从节点改为复制新的主节点。<ol><li>在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被 <strong>淘汰</strong>。</li><li>在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被 <strong>淘汰</strong>。</li><li>在 <strong>经历了以上两轮淘汰之后</strong> 剩下来的从服务器中， 我们选出 <strong>复制偏移量（replication offset）最大</strong> 的那个 <strong>从服务器</strong> 作为新的主服务器；如果复制偏移量不可用，或者从服务器的复制偏移量相同，那么 <strong>带有最小运行 ID</strong> 的那个从服务器成为新的主服务器。</li></ol></li><li><strong>配置提供者（Configuration provider）：</strong> 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。</li><li><strong>通知（Notification）：</strong> 哨兵可以将故障转移的结果发送给客户端。</li></ul><h5 id="为什么Redis的负载因子设置比HashMap的负载因子大">为什么Redis的负载因子设置比HashMap的负载因子大</h5><p>Redis的负载因子是键值对的数量/长度，HashMap是已使用的数量/长度</p><h5 id="Redis的分布式锁？">Redis的分布式锁？</h5><p>最低保证分布式锁的有效性及安全性的要求如下：</p><p>1.互斥；任何时刻只能有一个client获取锁</p><p>2.释放死锁；即使锁定资源的服务崩溃或者分区，仍然能释放锁</p><p>3.容错性；只要多数redis节点（一半以上）在使用，client就可以获取和释放锁</p><p><strong>问题</strong></p><p>因为redis在进行主从复制时是异步完成的，比如在clientA获取锁后，主redis复制数据到从redis过程中崩溃了，导致没有复制到从redis中，然后从redis选举出一个升级为主redis,造成新的主redis没有clientA 设置的锁，这是clientB尝试获取锁，并且能够成功获取锁，导致互斥失效；</p><p><strong>Redis分布式锁的实现</strong></p><p><strong>单实例</strong>中的实现：<code>SET key_name value_name NX PX 30000</code>保证原子性</p><blockquote><p>NX 表示if not exist 就设置并返回True，否则不设置并返回False   PX 表示过期时间用毫秒级， 30000 表示这些毫秒时间后此key过期</p></blockquote><p>获取失败则等待一段时间重试(大于ttl)或退出</p><p>获取锁，完成相关操作后，必须删除自己的锁。这里获取和删除都是用lua脚本，保证操作的原子性</p><p><strong>多节点</strong>Redis实现(RedLock)：有效防止单点故障</p><p>1.获取当前时间戳</p><p>2.client尝试按照顺序使用相同的key,value获取所有redis服务的锁，在获取锁的过程中的获取时间比锁过期时间短很多，这是为了不要过长时间等待已经关闭的redis服务。并且试着获取下一个redis实例。</p><p>比如：TTL为5s,设置获取锁最多用1s，所以如果一秒内无法获取锁，就放弃获取这个锁，从而尝试获取下个锁</p><p>3.client通过获取所有能获取的锁后的时间减去第一步的时间，这个时间差要小于TTL时间并且至少有3个redis实例成功获取锁，才算真正的获取锁成功</p><p>4.如果成功获取锁，则锁的真正有效时间是 TTL减去第三步的时间差 的时间；比如：TTL 是5s,获取所有锁用了2s,则真正锁有效时间为3s(其实应该再减去时钟漂移);</p><p>5.如果客户端由于某些原因获取锁失败，便会开始解锁所有redis实例；因为可能已经获取了小于3个锁，必须释放，否则影响其他client获取锁</p><h5 id="Redis包含的模块">Redis包含的模块</h5><h5 id="Redis为什么快？">Redis为什么快？</h5><ol><li>纯内存操作</li><li>单线程，没有各自乱七八糟的锁</li><li>多路IO复用模型，底层有很多优化</li><li>高效的数据结构：如不同长度的字符串用了不同的结构体、HyperLogLog的密集型存储结构等</li></ol><h5 id="Redis的HyperLogLog">Redis的HyperLogLog</h5><p>HyperLogLog是一种估计基数的近似最优算法。基数统计：用来统计一个集合中不重复的元素个数，比如统计网站每个页面的UV(独立访客)</p><p>大致的原理：一个随机数，尾部有1个0的概率为1/2，两个0的概率为1/4，…，尾部k个0的概率为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mi>k</mi></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span>。因此我们可以通过尾部连续0的最大数量k，估算出我们用了多少个随机数。HyperLogLog通过分配若干桶(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup></mrow><annotation encoding="application/x-tex">2^{14}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span></span></span></span>=26384)，对每个桶得到的最大数量k进行调和平均，得到一个k#，k#为一个浮点数。具体还有很多修正因子，比较复杂</p><p>占用内存仅12KB，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup></mrow><annotation encoding="application/x-tex">2^{14}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span></span></span></span>个桶，每个6bit，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup><mo>∗</mo><mfrac><mn>6</mn><mn>8</mn></mfrac></mrow><annotation encoding="application/x-tex">2^{14}*\frac68</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>Redis的实现：计数量小的时候，转换成稀疏存储方式；否则采用密集存储。最大限度节约内存</p><p>密集存储：16384个6bit连续成串，8bit 1字节，需要一些移位拼接的处理</p><p>稀疏存储：当某个计数值需要调整到大于32时，会转换为密集存储</p><ul><li>00开头表示后6位整数值加1就是零值计数器的数量</li><li>01后14bit最多可以表示连续16384个零值计数器</li><li>1vvvvvxx：中间5bit计数，后2bit表示连续几个桶</li></ul><p>指令：<code>pfadd</code>和<code>pfcount</code></p><p><a href="https://mp.weixin.qq.com/s/9dtGe3d_mbbxW5FpVPDNow">https://mp.weixin.qq.com/s/9dtGe3d_mbbxW5FpVPDNow</a></p><p><a href="https://cloud.tencent.com/developer/article/1349691">https://cloud.tencent.com/developer/article/1349691</a></p><h5 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？">假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h5><p>使用 <code>keys</code> 指令可以扫出指定模式的 key 列表。但是要注意 keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 <code>scan</code> 指令，<code>scan</code> 指令可以无阻塞的提取出指定模式的 <code>key</code> 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习随笔</title>
      <link href="/2020/08/10/JVM_Note/"/>
      <url>/2020/08/10/JVM_Note/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM的架构模型">JVM的架构模型</h2><p>JAVA编译器输入的指令流基本是一种基于<strong>栈的指令集架构</strong>，另一种架构是基于寄存器的。<br>两者的区别：</p><ul><li><strong>基于栈式架构的特点</strong><ul><li>设计和实现更简单，适用于资源受限的系统，比如嵌入式。</li><li>避开了寄存器的分配难题：采用零地址指令方式分配。（零地址就是只有操作码，没有地址字段，因为栈的话只对栈顶进行操作，就不需要地址）</li><li>指令流中的指令大部分是零地址指令，执行过程依赖操作栈。<strong>指令集更小</strong>，编译器容易实现。</li><li>不需要硬件支持，可移植性更好，更好实现<strong>跨平台</strong></li></ul></li><li><strong>基于寄存器架构的特点</strong><ul><li>指令集完全依赖于硬件，可移植性差。</li><li>性能优秀、执行高效</li><li>花费更少的指令来完成一项操作</li><li>在大部分情况下，采用一地址指令、二地址指令和在地址指令为主。</li></ul></li></ul><h2 id="JVM的生命周期">JVM的生命周期</h2><ul><li>虚拟机的启动：Java虚拟机的启动时通过引导类加载器(bootstrap class loader)创建一个初始类(initial calss)来完成的，这个类是由虚拟机的具体实现指定的。</li><li>虚拟机的执行：<ul><li>任务：执行Java程序</li><li>程序开始执行时它才运行，程序结束它就停止</li><li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</li></ul></li><li>虚拟机的退出：<ul><li>程序正常执行结束</li><li>程序碰到异常或错误而异常终止</li><li>由于操作系统出错而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或者System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作</li><li>除此之外，JNI(Java Native Interface)规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况</li></ul></li></ul><h2 id="JVM整体结构">JVM整体结构</h2><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/JVM_jiegou.jpg" alt=""></p><h2 id="类加载器子系统">类加载器子系统</h2><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/JVM_leijiazaiqi.jpg" alt=""></p><ul><li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</li><li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</li><li>加载的类信息存放在一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分信息是Class文件中常量池部分的内存映射）</li></ul><h3 id="类的加载阶段">类的加载阶段</h3><ol><li>加载：<ol><li>通过一个类的全限定名定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的<strong>java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口。</li></ol></li><li>链接：<ol><li>验证：<ul><li>目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性</li><li>主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证</li></ul></li><li>准备：<ul><li>为类变量分配内存并且设置类变量为默认初始值，即零值</li><li>这里不包含final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化</li><li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li></ul></li><li>解析：<ul><li>将常量池内的符号引用转换为直接引用的过程。</li><li>解析操作往往会伴随着JVM在执行完初始化之后再执行。</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。</li></ul></li></ol></li><li>初始化：<ul><li>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程。</li><li>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和<strong>静态代码块</strong>中的语句合并而来的。</li><li>&lt;clinit&gt;()不同于类的构造器。(构造器是虚拟机视角下的&lt;init&gt;())</li><li>若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类&lt;clinit&gt;()已经执行完毕。</li><li>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。</li></ul></li></ol><h3 id="类加载器的分类">类加载器的分类</h3><ul><li><p>JVM支持两种类型的类加载器：<strong>引导类加载器(Bootstrap ClassLoader)</strong> 和<strong>自定义类加载器(User-Defined ClassLoader)</strong></p></li><li><p>从概念上讲，自定义类加载器一般指程序中由程序员自定义的一类类加载器，但Java虚拟机规范指出，将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</p></li><li><p>无论定义咋分，最常见的三个类加载器如下图：<br>（引导类加载器、扩展类加载器和系统类加载器）<br><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/JVM_leijiazaiqifenlei.jpg" alt=""><br><strong>这里的四者之间的关系是包含关系。不是上下层关系，也不是父类的继承关系。</strong><br>Demo:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 获取系统类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader); <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 获取其上层：扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader); <span class="comment">// sun.misc.Launcher$ExtClassLoader@1b6d3586</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 获取其上层：获取不到引导类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader); <span class="comment">// null</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader); <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// String类使用引导类加载器进行加载 ---&gt; Java的核心类库都是使用引导类加载器进行加载</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1); <span class="comment">// null</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="启动类加载器-引导类加载器，Bootstrap-ClassLoader">启动类加载器(引导类加载器，Bootstrap ClassLoader)</h3><ul><li>这个类加载器使用C/C++语言实现的，嵌套在JVM内部</li><li>它用来加载Java的核心库(JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容)，用于提供JVM自身需要的类</li><li>并不继承自java.lang.ClassLoader，没有父加载器</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</li><li>处于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><h3 id="扩展类加载器-Extension-ClassLoader">扩展类加载器(Extension ClassLoader)</h3><ul><li>Java编写</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录jre/lib/ext子目录(扩展目录)下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li></ul><h3 id="应用程序类加载器-系统加载器，AppClassLoader">应用程序类加载器(系统加载器，AppClassLoader)</h3><ul><li>Java编写</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它完成加载的</li><li>通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************启动类加载器*************&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取BootstrapClassLoader能够加载的api路径</span></span><br><span class="line">        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span>(URL element : urls)&#123;</span><br><span class="line">            System.out.println(element.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            *************启动类加载器*************</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/resources.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/rt.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/sunrsasign.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/jsse.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/jce.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/charsets.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/lib/jfr.jar</span></span><br><span class="line"><span class="comment">            file:/E:/Java/jdk8/jdk1.8.0_251/jre/classes</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;**************扩展类加载器**************&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">extDirs</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String path : extDirs.split(<span class="string">&quot;;&quot;</span>))&#123;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            **************扩展类加载器**************</span></span><br><span class="line"><span class="comment">            E:\Java\jdk8\jdk1.8.0_251\jre\lib\ext</span></span><br><span class="line"><span class="comment">            C:\Windows\Sun\Java\lib\ext</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户自定义类加载器">用户自定义类加载器</h3><ul><li>在Java的日常应用程序开发中，类的加载几乎是由上述三种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，类定制类的加载方式。</li><li>目的：<ul><li>隔离加载器</li><li>修改类加载器</li><li>扩展加载源</li><li>防止源码泄露</li></ul></li></ul><h3 id="获取ClassLoader的方式">获取ClassLoader的方式</h3><ol><li><code>class.getClassLoader()</code>：获取当前类的ClassLoader</li><li><code>Thread.currentThread().getContextClassLoader()</code>：获取当前线程上下文的ClassLoader</li><li><code>ClassLoader.getSystemClassLoader()</code>：获取系统的ClassLoader</li><li><code>DriverManager.getCallerClassLoader()</code>：获取调用者的ClassLoader</li></ol><h3 id="双亲委派机制">双亲委派机制</h3><ul><li>Java虚拟机对class文件采用按需加载的方式，加载时采用双亲委派记至，即把请求交由父类处理，它是一种任务委派模式。</li><li>原理：<ol><li>如果一个类加载器收到了类加载请求，它不会先自己加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上层委托，以此类推，直到请求最终达到顶层的启动类加载器；</li><li>如果父类加载器可以完成加载任务，就成功返回，倘若父类加载器无法完成此次加载任务，子加载器才会尝试自己去加载<br><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/shuangqinweipai.jpg" alt=""></li></ol></li><li>优势：<ol><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改</li></ol></li></ul><h3 id="沙箱安全机制">沙箱安全机制</h3><ul><li>将Java代码限定在JVM特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证代码的有效隔离，防止对本地系统造成破坏。</li><li>如果我们自定义一个类名为String的类，并且包为java.lang。如果没有沙箱安全机制，可能会污染到原本jdk中的String类。根据双亲委派机制，委托到顶层的启动类加载器，就可以完成String的加载，避免了代码污染。</li></ul><h3 id="线程">线程</h3><ul><li>JVM允许多线程并行执行</li><li>在Hotspot JVM中，每个线程都与操作系统的本地线程直接映射。当一个Java线程准备好执行后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li><li>操作系统负责所有线程的安排调度到任何一个CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</li></ul><h2 id="运行时数据区">运行时数据区</h2><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/JVM_yunxingshishujuqu.jpg" alt=""></p><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/JVM_yunxingshishujuqu2.jpg" alt=""></p><ul><li>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机的退出而销毁。另外一些则是与线程一一对应，这些与线程对应的数据区会随着线程开始和结束而创建和销毁。</li><li>上面第一张图中，红色区域(方法区和堆)为一个进程共享的区域，而灰色部分(PC寄存器、本地方法栈和虚拟机栈)则为一个线程一份。</li><li>每个JVM只有一个Runtime实例。即为运行时环境。</li></ul><h3 id="程序计数器-PC寄存器，Program-Counter-Register">程序计数器(PC寄存器，Program Counter Register)</h3><h4 id="概述">概述</h4><ul><li>存储指令相关的现场信息，CPU只有把数据装载到寄存器才能够运行。</li><li>这里的PC寄存器只是JVM对物理PC寄存器的一种抽象模拟，并不是物理寄存器。</li><li>作用：PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码，由执行引擎读取下一条指令。(和计组学的那个功能类似。。)</li><li>它是一块很小的内存空间，运行速度最快的存储区域</li><li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值(undefined)</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖它来完成。</li><li>字节码解释器工作时是通过改变程序计数器的值来选取下一条需要执行的字节码指令。</li><li>它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</li></ul><h4 id="问题">问题</h4><ol><li>使用PC寄存器存储字节码指令地址有什么用？(为什么使用PC寄存器记录当前线程的执行地址呢？)<br>因为CPU需要不停地切换各个线程，这时候切换回来以后，就需要知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</li><li>PC寄存器为什么会被设定为线程私有？<br>多线程就是在一个特定的时间内只会执行其中某一个线程，CPU会不停地做任务切换，因此就会涉及到中断和恢复。为了能够准确地记录每个线程正在执行的当前字节码指令地址，就必须为每个线程分配一个PC寄存器。</li></ol><h3 id="虚拟机栈">虚拟机栈</h3><h4 id="概述-2">概述</h4><ul><li>栈是运行时的单位，堆是存储的单位</li><li>生命周期与线程一致。即每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame)，对应着一次次的Java方法调用。是线程私有的。</li><li>作用：管Java程序的运行，保存方法的局部变量、部分结果。并参与方法的调用和返回。</li><li>对于栈来说，不存在垃圾回收问题。</li><li>栈中可能出现的异常：<ul><li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出<strong>StackOverflowError</strong>异常。</li><li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存区创建对应的虚拟机栈，那Java虚拟机将会抛出一个<strong>OutOfMemoryError</strong>异常。</li></ul></li><li>设置栈内存大小：<code>-Xss</code></li></ul><h4 id="栈的存储单位">栈的存储单位</h4><ul><li>每个线程都有自己的栈，栈中的数据都是以**栈帧(Stack Frame)**的格式存在</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li><li>JVM对Java栈的操作：压栈和出栈</li><li>当前执行的方法的栈帧：当前栈帧-&gt;当前方法-&gt;当前类</li><li>不同线程中所包含的栈帧是不允许存在互相引用的</li><li>Java方法的两种返回方式：一是正常放回，return；另一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</li></ul><h4 id="栈帧的内部结构">栈帧的内部结构</h4><ul><li>局部变量表(Local Variables)</li><li>操作数栈(Operand Stack)(或表达式栈)</li><li>动态链接(Dynamic Linking)(或指向运行时常量池的方法引用)</li><li>方法返回地址(Return Address)(或方法正常退出或者异常退出的定义)</li><li>一些附加信息<br>PS：方法返回地址、动态链接和一些附加信息也称作帧数据区</li></ul><h5 id="局部变量表-Local-Variables">局部变量表(Local Variables)</h5><ul><li><p>也称局部变量数组或本地变量表</p></li><li><p>定义一个<strong>数字数组</strong>，主要用于存储方法参数和定义在方法体内的局部变量(各类基本数据类型、对象引用(reference)、returnAddress类型)</p></li><li><p>局部变量表建立在线程的栈上，是线程私有的数据，因此不存在数据安全问题</p></li><li><p>局部变量表所需的容量大小是在<strong>编译期</strong>确定的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p></li><li><p>方法嵌套调用的次数由栈的大小决定。站越大，方法嵌套调用次数越多。</p></li><li><p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p></li><li><p>Slot:</p><ul><li>局部变量表，最基本的存储单元是Slot(变量槽)</li><li>32位以内的类型只占用一个slot(包括returnAddress类型)；64位的类型(long和double)占用两个slot<blockquote><p>byte、short、char在存储前被转换为int，boolean也被转换为int(0为false，1为true)</p></blockquote></li><li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可访问到局部变量表中指定的局部变量值</li><li>局部变量按照声明的顺序被复制到局部变量表的每一个Slot上</li><li>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列</li></ul><p>Demo:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVariablesTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();</span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9.6</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">        test.add(a, b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;a + b = &quot;</span> + (a + b));</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/JVM_jububianliangbiao.jpg" alt=""></p><ul><li>栈帧中的局部变量表中的槽位是可以重复利用的。如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很可能会服用过期局部变量的槽位，从而节省资源</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        b = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上述方法有四个变量，但是局部变量表的槽位只有三个。变量b在出了括号后，过了其作用域。因此之后声明的变量c占了之前b的slot的位置。这样就节省了资源。<br><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/JVM_jububianliangbiao2.jpg" alt=""></p></li></ul><p>变量的分类：</p><ul><li>按照数据类型分：1. 基本数据类型 2. 引用数据类型</li><li>按照在类中声明的位置分：<ol><li>成员变量：在使用前，都经历过默认初始化赋值<ul><li>类变量：linking的prepare阶段：给类变量默认赋值 —&gt; initial阶段：给类变量显式赋值即静态代码块赋值</li><li>实例变量：随着对象的创建，会在对空间中分配实例变量空间，并进行默认赋值</li></ul></li><li>局部变量：在使用前，必须进行显式赋值。否则编译不通过</li></ol></li></ul><ol><li>在栈帧中，与性能调优关系最密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。如果局部变量表中的变量不存在了，指向堆空间的指针也就不存在了，那么堆中垃圾就需要被回收</li><li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</li></ol><h5 id="操作数栈-Operand-Stack">操作数栈(Operand Stack)</h5><ul><li>每个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈，也可以成为表达式栈。</li><li>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</li><li>如果被调用的方法带有返回值，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器下一条需要执行的字节码指令。</li><li>一个方法刚开始执行时，栈帧被创建，随之这个方法的操作数栈也被创建，但为空。且最大深度在编译期就定义好了。</li><li>操作数栈<strong>并非采用访问索引的方式来进行数据访问</strong>，只能通过push和pop来操作，因为它是个<strong>栈</strong>，但是它是由数组实现的。</li><li>Java虚拟机的届时引擎是基于栈的执行引擎，其中栈指的就是操作数栈。</li></ul><h4 id="栈顶缓存技术-ToS-Top-of-Stack-Cashing">栈顶缓存技术(ToS, Top-of-Stack Cashing)</h4><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈操作，使得需要更多的指令分派次数和内存读写此时。<br>HotSpot JVM提出栈顶缓存技术(ToS, Top-of-Stack Cashing)，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率</strong>。</p><h4 id="动态链接">动态链接</h4><ul><li>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中<strong>该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现<strong>动态链接(Dynamic Linking)</strong>。比如invokedynamic指令</li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(Symbolic Reference)保存在class文件的常量池里。比如：描述一个方法调用另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong>。<br><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/JVM_dataDynamicLinking.jpg" alt=""></li></ul><h4 id="方法的调用">方法的调用</h4><p>在JVM中，将<strong>符号引用</strong>转换为调用方法的<strong>直接引用</strong>与方法的绑定机制相关。</p><ul><li>静态链接：<br>当一个字节码文件被装进JVM内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程，称之为静态链接。</li><li>动态链接：<br>如果<strong>被调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期间将方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此称之为动态链接。</li></ul><hr><p>对应的方法的绑定机制为：早期绑定(Early Binding)和晚期绑定(Late Binding)。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><ul><li>早期绑定：<br>就是指被调用的<strong>目标方法如果在编译期可知，且运行时保持不变</strong>时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此就可以使用静态链接的方式将符号引用转换为直接引用。</li><li>晚期绑定：<br>如果<strong>被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称为晚期绑定。</li></ul><h4 id="虚方法与非虚方法">虚方法与非虚方法</h4><ul><li>非虚方法：<ul><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。</li><li>静态方法、私有方法、final方法、实例构造器、父类方法等</li><li>其他方法称为虚方法</li></ul></li><li>子类对象的多态性的使用前提：1. 类的继承关系 2. 方法的重写</li><li>虚拟机中提供了一下几条方法调用指令：<ul><li>普通调用指令：<ol><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ol></li><li>动态调用指令：<br>5. invokedynamic：动态解析出需要调用的方法，然后执行</li><li>前四条指令固化在虚拟机内部，方法的调用执行不可认为干预，而invokedynamic指令则支持由用户确定方法版本，其中invokestatic指令和invokespecial指令调用的方法称为虚方法，其余的（final修饰的除外）称为虚方法。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2020/07/08/Java_Basic/"/>
      <url>/2020/07/08/Java_Basic/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>重新看看Java基础<br>顺便随便记一些基础的东西。。😃</p></blockquote><hr><h2 id="数据类型">数据类型</h2><p>基本类型：4种整型、两种浮点类型、1中用于表示Unicode编码的字符型char和boolean型</p><ol><li>整型：int、short、long、byte</li><li>浮点型：float、double<blockquote><p>注意：浮点型存在舍入误差，有些小数无法精确表示，如果在数值计算时不允许有误差，可以考虑使用BigDecimal类</p></blockquote></li><li>char类型：用单引号括起来</li><li>boolean：两个值：true和false<blockquote><p>在c++中，可以使用数值0表示布尔值false，非0相当于布尔值true；但Java中不行，编译不能通过</p></blockquote></li></ol><h2 id="final">final</h2><ol><li>关键字final指示常量。</li><li>final表示这个变量只能被赋值一次。一旦被赋值后，就不能改变。</li><li>常量名一般使用全大写。</li><li>类常量可以使用<code>static final</code>来设置，定义位于main方法外，同一个类中的方法都可以使用。</li></ol><h2 id="枚举类型">枚举类型</h2><h2 id="Scanner类">Scanner类</h2><p>从键盘输入数据。</p><ol><li>导包：<code>import java.util.Scanner</code></li><li>创建对象：<code>Scanner sc = new Scanner(System.in)</code></li><li>使用：参数类型 变量名 = sc.成员方法名<code>   从键盘获取一个int：</code>int num = sc.nextInt()<code>    从键盘获取一个String：</code>String str = sc.next()`</li></ol><h2 id="ArrayList">ArrayList</h2><ol><li>创建：<code>ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();</code>。E表示泛型。</li><li><code>System.out.print(list)</code>打印的是list的内容，不是地址。</li><li>public boolean add(E e)：向集合添加元素，参数类型与创建集合的泛型一致。</li><li>public int size()：获取list长度。</li><li>public E remove(int index)：从集合删除索引为index的元素，返回被删除的元素。</li><li>public E get(int index)：获取下标为index的元素，并返回该元素。</li><li>泛型只能为引用类型，不能为基本类型。必须使用基本类型的包装类。</li></ol><table><thead><tr><th style="text-align:center">基本类型</th><th style="text-align:center">包装类</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">Byte</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">Integer</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">Short</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">Long</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">Float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">Double</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">Character</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">Boolean</td></tr></tbody></table><h2 id="String">String</h2><ol><li><p>字符串的构造方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;第一个字符串:&quot;</span> + str1);   <span class="comment">// 第一个字符串:</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] c = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二个字符串：&quot;</span> + str2);   <span class="comment">// 第二个字符串：ABC</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] b = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b);</span><br><span class="line">        System.out.println(<span class="string">&quot;第三个字符串：&quot;</span> + str3);   <span class="comment">// 第三个字符串：abc</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;第四个字符串：&quot;</span> + str4);   <span class="comment">// 第四个字符串：Hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串常量池<br>程序中直接用双引号表示的字符串，就在字符串池中。<br>字符串常量池存在堆中。因为引号表示的字符串，是不能更改的，相当于一个常量。而通过字符数组（或者字节数组）创建的字符串的内容，根据字符数组的改变而改变，它存的地址是数组地址。</p><blockquote><p>对于基本类型来说，== 是进行<em><strong>数值</strong></em>的比较；<br>对于引用类型来说，== 是进行<em><strong>地址值</strong></em>的比较。</p></blockquote> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStringPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] c = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line"></span><br><span class="line">        System.out.println(str1 == str2);   <span class="comment">//true</span></span><br><span class="line">        System.out.println(str1 == str3);   <span class="comment">//false</span></span><br><span class="line">        System.out.println(str3 == str2);   <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串常用方法</p></li></ol><ul><li><p>equals<br><code>public boolean equals(object obj)</code>：参数可以是任意对象，只有参数为字符串并且内容想到才返回true，否则返回false。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStringEquals</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;LeLe&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;LeLe&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] c = &#123;<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;lele&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(str1.equals(str2));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(str2.equals(str3));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(str1.equals(str3));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(str1.equals(str4));  <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>equalsIgnoreCase<br><code>public boolean equalsIgnoreCase(String str)</code>：忽略大小写，比较内容。<br>上面的例子中：<br><code>System.out.println(str1.equalsIgnoreCase(str4));    // true</code></p></li><li><p>length<br><code>str1.length()</code>：获取字符串字符个数。</p></li><li><p>concat<br><code>public String concat(String str)</code>：将当前字符串和参数字符串拼接，并返回新的字符串。</p></li><li><p>charAt<br><code>public char charAt(int index)</code>：获取指定索引位置的单个字符。索引从0开始。</p></li><li><p>indexOf<br><code>public int indexOf(String str)</code>：查找参数字符串在本字符串当中首次出现的索引位置，如果没有，返回-1。<br><strong>上面四个方法的示例如下：</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStringGet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;LeLe&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;str1的长度为：&quot;</span> + str1.length());    <span class="comment">// str1的长度为：4</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;str1 + str2为：&quot;</span> + str1.concat(str2));    <span class="comment">// str1 + str2为：LeLeHello</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;str2的第3个字符为：&quot;</span> + str2.charAt(<span class="number">1</span>));    <span class="comment">// str2的第3个字符为：e</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Le在str1中首次出现的索引为:&quot;</span> + str1.indexOf(<span class="string">&quot;Le&quot;</span>));   <span class="comment">// Le在str1中首次出现的索引为:0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>substring<br><code>public String substring(int index):</code>：截取从参数位置一直到字符串结尾。返回新字符串。<br><code>public String substring(int begin, int end)</code>：截取从begin到end中间的字符串。<strong>左闭右开[begin,end)</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSubString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello,LeLe&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(str1.substring(<span class="number">6</span>));  <span class="comment">// LeLe</span></span><br><span class="line">        System.out.println(str1.substring(<span class="number">0</span>,<span class="number">5</span>));    <span class="comment">// Hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>toCharArray<br><code>public char[] toCharArray()</code>：将当前字符串拆分成字符数组作为返回值。</p></li><li><p>getBytes<br><code>public byte[] getBytes()</code>：获取当前字符串底层的字节数组。</p></li><li><p>replace<br><code>public String replace(CharSequence oldString,CharSequence newString)</code>：将所有出现的老字符串替换成新的字符串，返回替换之后的新的字符串。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStringConvert</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;LeLe&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] c = str1.toCharArray();</span><br><span class="line">        System.out.println(c[<span class="number">1</span>]);   <span class="comment">// e</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] b = str1.getBytes();</span><br><span class="line">        System.out.println(b[<span class="number">2</span>]);   <span class="comment">// 76</span></span><br><span class="line"></span><br><span class="line">        System.out.println(str1.replace(<span class="string">&quot;Le&quot;</span>, <span class="string">&quot;Ba&quot;</span>));</span><br><span class="line">        <span class="comment">// BaBa</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>split<br><code>public String[] split(String regex)</code>：按照参数的规则，将字符串切分成若干部分。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStringSplit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello,LeLe,HaHa,Zhang San&quot;</span>;</span><br><span class="line">        String[] array1 = str1.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array1.length; i++) &#123;</span><br><span class="line">            System.out.println(array1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Hello</span></span><br><span class="line">        <span class="comment">// LeLe</span></span><br><span class="line">        <span class="comment">// HaHa</span></span><br><span class="line">        <span class="comment">// Zhang San</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：split方法的参数其实是一个<strong>正则表达式</strong>。需要注意转义。如按照英文句点&quot;.“来切分，必须写” \\. &quot;</p></blockquote></li></ul><ol start="4"><li>拼接：<ul><li>可以直接使用 “+”号 将两个字符串进行拼接；</li><li>字符串与非字符串用“+”号拼接时，非字符会被转成字符串，输出中常用</li><li>多个字符串拼接可以使用join方法：<code>String s = String.join(&quot;/&quot;,&quot;good&quot;,&quot;bad&quot;,&quot;haha&quot;) // good/bad/haha</code></li></ul></li><li>不可变字符串：String类没有提供修改字符串的方法，在Java中，字符串相当于存放在一个公共的存储池中，字符串变量指向存储池中相应的位置，编译期可以让字符串共享。当字符串变量不使用后，Java会进行垃圾回收。</li><li>空串与null：空串是长度为0，内容为空的字符串，判断字符串是否为空：<code>if(str.length() == 0)</code>或者<code>if(str.equals(&quot;&quot;))</code>；null表示没有任何对象与该变量关联，判断一个字符串是否为null：<code>if(str == null)</code></li><li>字符串的构建：由较短的字符串构建字符串时，采用字符串连接的方式效率比较地下。每次连接字符串，都会创建一个新的String对象，耗时耗空间。因此可以使用StringBuilder类。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> String <span class="title function_">implicit</span><span class="params">(String[] fields)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            res += fields[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">explicit</span><span class="params">(String[] fields)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            res.append(fields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面两个方法各自实现了字符串的拼接，我们通过编译，得到字节码，如下图：<br><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/datastringBuilderTest01.jpg" alt=""><br>字节码的8-35行构成一个循环体，循环体内new了一个StringBuilder对象，也就是说每次循环都会创建一个新的StringBuilder对象。<br><img src="https://lqy-blog-pic.oss-cn-shanghai.aliyuncs.com/blogImg/datastringBuilderTest02.jpg" alt=""><br>而第二个方法，它只创建了一个StringBuilder对象。</p><h2 id="switch语句">switch语句</h2><ol><li>用法：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(choice) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>switch语句将从与选项值匹配的case标签处开始执行，直到碰到break语句，或者一直执行到switch语句的结束处。如果没有匹配的case，并有default语句，就执行default语句</li></ol><blockquote><p><strong>注意</strong>：如果case结尾没有break，程序会继续执行下一个case分支语句</p></blockquote><ol start="3"><li>case的标签可以是：char、byte、short、int的常量表达式，也可以为枚举或者字符串字面量</li><li>switch使用枚举时,不必在每个标签中指明枚举名：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Size</span> <span class="variable">sz</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="keyword">switch</span>(sz) &#123;</span><br><span class="line">    <span class="keyword">case</span> SMALL: <span class="comment">// no need to use Size.SMALL</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大数值">大数值</h2><ol><li>java.math包中的：BigInteger和BigDecimal。这两个类可以处理包含任意长度数字序列的数值，前者实现了任意精度的整数运算，后者则实现了任意精度的浮点数计算。</li><li>可以使用valueOf方法将普通数值转换为大数值：<code>BigInteger num = BigInteger.valueOf(100)</code></li><li>大数值的运算不能使用算数运算符，需要使用大数值类中的add、subtract、multiply、divide、mod方法</li><li>大数值的divide方法需要给出舍入方式，RoundingMode.HALF_UP为四舍五入</li></ol><h2 id="Arrays-sort">Arrays.sort()</h2><ol><li>默认为升序排序</li><li>采用了双基准快排(DualPivotQuicksort)。快排采用分治的思想，用一个pivot将原数组分成两个子数组，然后递归。双基准快排则是采用两个pivot，将原数组分成三部分（x &lt; pivot1 ; pivot1 &lt;= x &lt;= pivot2 ; x &gt; pivot3）,然后递归。</li><li>Arrays.sort()采用了很多排序方法，不同的情况则使用不同的排序方法。我们假设原数组长度为length<ul><li>length &lt;= 47 ：使用插入排序</li><li>47 &lt; length &lt;= 286 ：使用快速排序</li><li>length &gt; 286 并且 数组高度结构化(基本有序) ：归并排序</li><li>length &gt; 286 并且 基本无序或逆序 ： 快速排序</li></ul></li><li>双基准快排的细节：<ul><li>在选取pivot时，首先通过位运算，获取数组长度的1/7左右</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inexpensive approximation of length / 7</span></span><br><span class="line"><span class="type">int</span> <span class="variable">seventh</span> <span class="operator">=</span> (length &gt;&gt; <span class="number">3</span>) + (length &gt;&gt; <span class="number">6</span>) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>然后选取数组的中间位置e3,以及e3左右1/7、2/7的位置，分别为e1、e2和e4、e5</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Sort five evenly spaced elements around (and including) the</span></span><br><span class="line"><span class="comment"> * center element in the range. These elements will be used for</span></span><br><span class="line"><span class="comment"> * pivot selection as described below. The choice for spacing</span></span><br><span class="line"><span class="comment"> * these elements was empirically determined to work well on</span></span><br><span class="line"><span class="comment"> * a wide variety of inputs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">e3</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// The midpoint</span></span><br><span class="line"><span class="type">int</span> <span class="variable">e2</span> <span class="operator">=</span> e3 - seventh;</span><br><span class="line"><span class="type">int</span> <span class="variable">e1</span> <span class="operator">=</span> e2 - seventh;</span><br><span class="line"><span class="type">int</span> <span class="variable">e4</span> <span class="operator">=</span> e3 + seventh;</span><br><span class="line"><span class="type">int</span> <span class="variable">e5</span> <span class="operator">=</span> e4 + seventh;</span><br></pre></td></tr></table></figure><ul><li>然后对5个索引进行排序，这里用的是插入排序。排完后放回5个位置中</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sort these elements using insertion sort</span></span><br><span class="line"><span class="keyword">if</span> (a[e2] &lt; a[e1]) &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[e2]; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (a[e3] &lt; a[e2]) &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[e3]; a[e3] = a[e2]; a[e2] = t;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[e4] &lt; a[e3]) &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[e4]; a[e4] = a[e3]; a[e3] = t;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; a[e2]) &#123; a[e3] = a[e2]; a[e2] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[e5] &lt; a[e4]) &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[e5]; a[e5] = a[e4]; a[e4] = t;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; a[e3]) &#123; a[e4] = a[e3]; a[e3] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; a[e2]) &#123; a[e3] = a[e2]; a[e2] = t;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Pointers</span></span><br><span class="line"><span class="type">int</span> <span class="variable">less</span>  <span class="operator">=</span> left;  <span class="comment">// The index of the first element of center part</span></span><br><span class="line"><span class="type">int</span> <span class="variable">great</span> <span class="operator">=</span> right; <span class="comment">// The index before the first element of right part</span></span><br></pre></td></tr></table></figure><ul><li>如果5个元素都不相同，则e2为pivot1，e4为pivot3，然后继续双基准快排</li><li>如果5个元素存在相同的，则以e3为pivot进行普通快排</li></ul></li></ol><h2 id=""></h2><h2 id="HashMap（待补充）">HashMap（待补充）</h2><ol><li>底层？<ul><li>初始大小16，默认负载因子0.75（可自定义），12时扩容，扩容一倍即32</li><li>HashMap存的是Node节点，Node节点里包含key和value</li><li>HashMap由数组+单向链表</li></ul></li></ol><h2 id="Java内存结构概述">Java内存结构概述</h2><ol><li>栈(Stack): 存放方法中的局部变量。一旦超出作用域，java会自动释放它的内存空间。</li><li>堆(Heap): 凡是new出来的东东（对象、数组等等），都存放在堆中。<br>堆中的东西都有一个内存地址值（16进制），且都有一个默认初始值。规则如下：<br>int默认为0；double默认为0.0；字符默认为’\u0000’；布尔默认为false；引用类型默认为null。<br>实体不再被使用后，会在不确定的时间内被垃圾回收器回收。</li><li>方法区(Method Area)：包含class和static变量。</li><li>本地方法栈(Native Method Stack)：与操作系统相关。</li><li>寄存器(pc Register)：CPU相关。CPU访问寄存器执行速度远大于在主存上的执行速度。</li></ol><h2 id="面向对象三大特征">面向对象三大特征</h2><ol><li><p>封装：将实现的细节隐藏，对外界不可见。需要的时候直接调用即可，不需要知道实现细节。<br>（1） 方法就是一种封装<br>（2） 关键字private也是一种封装：使用private修饰后，只能在类的内部进行访问。在本类范围外则不能直接访问，不能对其进行修改。间接访问static成员变量，可以定义一组getter/setter方法。</p></li><li><p>继承：将共性提取到父类中。继承是多态的前提。<br>Java是<strong>单继承</strong>的。可以<strong>多级继承</strong>。</p></li><li><p>多态：</p></li></ol><h2 id="this关键字">this关键字</h2><p>方法的局部变量和类的成员变量重名时，会就近使用方法的局部变量。如果要访问类的成员变量，需要使用this。格式：this.成员变量名。</p><blockquote><p>ps：谁调用的方法，谁就是this。也就是当前的对象。</p></blockquote><h2 id="构造方法">构造方法</h2><p>构造方法是用来创建对象的方法。一般通过new关键字来创建对象时调用的。格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 类名称(参数类型 参数名称, ...)&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>构造方法的名称必须和类名称完全一样。</li><li>构造方法无返回值。</li><li>如果无构造方法，默认一个无参构造方法，方法体啥都不做。</li><li>构造方法可以重载（方法名相同，参数列表不同）。</li></ol><h2 id="static">static</h2><ol><li>使用static关键字修饰的成员变量，不再属于对象自己，而是属于类的。所有的对象共享同一份。</li><li>使用static关键字修饰的成员方法，就是静态方法，它不再属于对象，而是属于类的。</li><li>如果没有static关键字，必须先创建对象，然后通过对象来使用。<br>如果有static关键字，可以直接通过类名称来使用。<br>无论是成员变量还是成员方法，如果有了static关键字修饰，都推荐使用类名称进行使用。</li><li>静态代码块：当第一次用到本类时，静态代码快执行唯一的一次。<br>静态内容总是优先于非静态，所以静态代码快比构造方法先执行。<br>一般用来一次性对静态成员变量进行赋值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名称&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 静态代码块的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>静态不能直接访问非静态。因为内存中是先有的静态内容，后有的非静态内容。</li><li>静态方法中不能使用this。this代表当前对象。</li><li>静态变量存在内存中的方法区里的静态区中。根据类名称访问静态成员变量的时候，和对象（存在内存的堆中）没关系，只和类有关系。</li></ol></blockquote><p>Demo01</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">idCounter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String room;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = ++idCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStaticField</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        Student.room = <span class="string">&quot;Room 101&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span> + one.getId() + <span class="string">&quot;,name:&quot;</span> + one.getName()</span><br><span class="line">                + <span class="string">&quot;,age:&quot;</span> + one.getAge() + <span class="string">&quot;,room:&quot;</span> + Student.room);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">two</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;呆子&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span> + two.getId() + <span class="string">&quot;,name:&quot;</span> + two.getName()</span><br><span class="line">                + <span class="string">&quot;,age:&quot;</span> + two.getAge() + <span class="string">&quot;,room:&quot;</span> + Student.room);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output:</span></span><br><span class="line">    <span class="comment">//  id:1,name:张三,age:20,room:Room 101</span></span><br><span class="line">    <span class="comment">//  id:2,name:呆子,age:10,room:Room 101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo02</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">numStatic</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一个普通的成员方法。&quot;</span>);</span><br><span class="line">        <span class="comment">// 成员方法可以访问成员变量，也可以访问静态变量</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(numStatic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodStatic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个static方法。&quot;</span>);</span><br><span class="line">        <span class="comment">// 静态方法只能访问静态变量</span></span><br><span class="line">        System.out.println(numStatic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01StaticField</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        obj.method();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态方法可以使用对象名来调用，也可以直接通过类名称来调用</span></span><br><span class="line">        obj.methodStatic(); <span class="comment">// 不推荐，这种写法编译后仍会被翻译成“类名称.静态方法名”</span></span><br><span class="line">        MyClass.methodStatic();  <span class="comment">// 推荐</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重写">重写</h2><ol><li>重写：在继承关系中，方法名一样，参数一样。<br>重载：方法名一样，参数不一样。</li><li>@override写在方法前，检测是否是有效的正确的重写。</li></ol><h2 id="父子类构造方法的访问">父子类构造方法的访问</h2><ol><li>子类构造方法中，默认一个<code>super();</code>调用，必须先调用父类构造，再调用子类构造。</li><li>子类构造可以通过super关键字来调用父类重载构造。</li><li>super的父类构造调用必须是子类构造方法中的第一个语句，且只能有一个super调用。</li></ol><h2 id="super关键字">super关键字</h2><ol><li>在子类成员方法中访问父类的成员变量。<code>super.xxx</code></li><li>在子类的成员方法中访问父类的成员方法。<code>super.xxx()</code></li><li>在子类的构造方法中访问父类的构造方法。<code>super()</code></li></ol><h2 id="this关键字-2">this关键字</h2><ol><li>在本类的成员方法中，访问本类的成员变量。<code>this.xxx</code></li><li>在本类的成员方法中，访问本类的另一个成员方法。<code>this.xxx()</code></li><li>在本类的构造方法中，访问本类的另一个构造方法。<code>this(...)</code></li></ol><blockquote><p>注意：在第三种用法中，<code>this(...)</code>调用必须也是构造方法的第一个且唯一的语句。super和this两种构造调用，不能同时使用。</p></blockquote><h2 id="抽象类">抽象类</h2><ol><li>抽象类不能创建对象。</li><li>抽象类可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</li><li>抽象类不一定包含抽象方法，有抽象方法一定是抽象类。</li><li>抽象类的子类，必须重写抽象父类中所有的抽象方法。</li></ol><h2 id="接口">接口</h2><ul><li>接口没有静态代码块或者构造方法。</li><li>一个类的直接父类是唯一的，单一个类可以同时实现多个接口。</li><li>如果实现类所实现的多个接口中，存在重复的抽象方法，只需要覆盖重写一次即可。</li><li>如果实现类没有覆盖重写所有接口的所有抽象方法，那么实现类必须为一个抽象类。</li><li>如果实现类所实现的多个接口中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</li><li>一个类如果父类中的方法，和接口中的默认方法产生冲突，优先用父类当中的方法。</li></ul><h3 id="成员变量">成员变量</h3><p>格式： <code>[public] [static] [final] 数据类型 常量名称 = 数据值;</code></p><blockquote><p>常量必须进行赋值，一旦赋值，不能改变。<br>常量命名建议全大写，用下划线分隔。</p></blockquote><h3 id="接口中的抽象方法">接口中的抽象方法</h3><p>格式：  <code>[public] [abstract] 返回值类型 方法名称(参数列表);</code></p><blockquote><p>实现类必须覆盖重写接口所有的抽象方法，除非实现类也是抽象类。</p></blockquote><h3 id="接口的默认方法">接口的默认方法</h3><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="keyword">default</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>接口中的默认方法，可以解决接口升级的问题。如果接口需要添加一个新的抽象方法，但不能影响以及运行的实现类，则可以使用默认方法。</li><li>接口的默认方法，可以通过接口实现类的对象直接调用。</li><li>接口的默认方法，也可以被接口实现类进行覆盖重写。</li></ol></blockquote><h3 id="接口的静态方法">接口的静态方法</h3><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>静态方法不能通过接口实现类的对象来调用，必须通过接口名称来调用。<br>格式：接口名称.静态方法名(参数);</p></blockquote><h3 id="私有方法">私有方法</h3><p>（Java 9之后）格式：</p><ol><li>普通私有方法：<code>public 返回值类型 方法名称(参数列表) &#123; 方法体 &#125;</code></li><li>静态私有方法：<code>public static 返回值类型 方法名称(参数列表) &#123; 方法体 &#125;</code></li></ol><blockquote><p>private的方法只有接口自己使用。</p></blockquote><h2 id="Iterator迭代器">Iterator迭代器</h2><p>对集合进行遍历。两个常用方法：</p><ol><li>boolean hasNext():如果仍然有元素可以迭代，则返回true；判断集合是否还有下一个元素，有则返回true，无则返回false。</li><li>E next():返回迭代的下一个元素；取出集合中的下一个元素。<br>Iterator是一个接口，无法直接用，需要使用Iterator接口的实现类对象。<br>Collection接口中的iterator()方法，返回的就是迭代器的实现类对象<br><code>Iterator&lt;E&gt; iterator()</code> 返回在此collection的元素上进行迭代的迭代器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoIterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;马云&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for遍历">for遍历</h2><p>使用的Iterator迭代器，形式上是for。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:list) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型">泛型</h2><p>未知数据类型，当创建对象或者具体使用的时候，再确定泛型的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericClass</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> E name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(E name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFanxing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GenericClass&lt;Integer&gt; gc = <span class="keyword">new</span> <span class="title class_">GenericClass</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        gc.setName(<span class="number">6</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">gcName</span> <span class="operator">=</span> gc.getName();</span><br><span class="line">        System.out.println(gcName); <span class="comment">// 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射">反射</h2><ul><li>反射机制：将类的各个组成部分封装为其他<strong>对象</strong>。</li><li>java代码经历的三个阶段：<ul><li><p>Source源代码阶段(存在硬盘)：源码(xxx.java),编译后，字节码文件(xxx.class)。字节码文件存放成员变量、构造方法、成员方法等等。</p></li><li><p>Class类对象阶段：通过类加载器(ClassLoader)将字节码文件加载到内存中去。<br>在内存中如何表述字节码文件的内容？Class类对象。<br>Class类对象包括用来描述成员变量、构造方法、成员方法的若干对象。<br>如成员变量，使用<code>Field[] fields</code>这样一个数组来表示所有的成员变量。<br>如构造方法，使用<code>Constructor[] cons</code>来表示所有的构造器。<br>成员方法，使用<code>Method[] methods</code>来表示所有成员方法。<br>之后可以通过Class类对象的行为，来new对象啊。。等等</p></li><li><p>Runtime运行时阶段:xxx对象，new xxx()。</p></li></ul></li></ul><h3 id="获取Class类对象的方式">获取Class类对象的方式</h3><ol><li><p>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象。</p><ul><li>多用于配置文件，将类名定义在配置文件中。读取文件，加载类。</li></ul></li><li><p>类名.class：通过类名的属性class获取。</p><ul><li>多用于参数的传递。</li></ul></li><li><p>对象.getClass()：getClass()方法在Object类中定义。</p><ul><li>多用于对象的获取字节码的方式。</li></ul><p>Demo：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 1. Class.forName(&quot;全类名&quot;)</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.demo.person.Person&quot;</span>);</span><br><span class="line">        System.out.println(cls1);   <span class="comment">// class com.demo.person.Person</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 2. 类名.class</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls2</span> <span class="operator">=</span> Person.class;</span><br><span class="line">        System.out.println(cls2);   <span class="comment">// class com.demo.person.Person</span></span><br><span class="line">        <span class="comment">// 3. 对象.getClass();</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls3</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">        System.out.println(cls3);   <span class="comment">// class com.demo.person.Person</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// ==比较三个对象</span></span><br><span class="line">        System.out.println(cls1==cls2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(cls1==cls3); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>结论：同一个字节码文件(*.class)在一次程序运行过程中，只被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</li></ul><h3 id="Class对象的功能">Class对象的功能</h3><ul><li>获取功能：<ol><li><p>获取成员变量</p><ul><li>Field[] getFields()：获取所有<strong>public</strong>修饰的成员变量</li><li>Field getField(String name)：获取指定名称的<strong>public</strong>修饰的成员变量</li><li>Field[] getDeclaredFields():获取所有的成员变量，不考虑修饰符</li><li>Field getDeclaredFields(String name)</li><li>Field操作：<ol><li>设置值：<code>void set(object obj, boject value)</code></li><li>获取值：<code>get(object obj)</code></li><li>忽略访问权限修饰符的安全检查(暴力反射)：setAccessible(true)</li></ol></li></ul><p>person类：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String public_a;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> protected_b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> private_d;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, public_a=&#x27;&quot;</span> + public_a + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, protected_b=&quot;</span> + protected_b +</span><br><span class="line">                <span class="string">&quot;, c=&quot;</span> + c +</span><br><span class="line">                <span class="string">&quot;, private_d=&quot;</span> + private_d +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eating...&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 0. 获取person.Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">personClass</span> <span class="operator">=</span> Person.class;</span><br><span class="line">        <span class="comment">// 1. Field[] getFields()</span></span><br><span class="line">        Field[] fields = personClass.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);  <span class="comment">// public int com.demo.classDemo.Person.public_a</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. Field getField(String name)</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">a</span> <span class="operator">=</span> personClass.getField(<span class="string">&quot;public_a&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取成员变量a的值</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> a.get(p);</span><br><span class="line">        System.out.println(value);  <span class="comment">// null</span></span><br><span class="line">        <span class="comment">// 设置值</span></span><br><span class="line">        a.set(p, <span class="string">&quot;张三&quot;</span>); <span class="comment">// Person&#123;name=&#x27;null&#x27;, age=0, public_a=&#x27;张三&#x27;, protected_b=0, c=0, private_d=0&#125;</span></span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.Field[] getDeclaredFields()</span></span><br><span class="line">        Field[] declaredFields = personClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field declaredField : declaredFields)&#123;</span><br><span class="line">            System.out.println(declaredField);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        private java.lang.String com.demo.classDemo.Person.name</span></span><br><span class="line"><span class="comment">        private int com.demo.classDemo.Person.age</span></span><br><span class="line"><span class="comment">        ...共6个...</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 4. Field getDeclaredFields(String name)</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">d</span> <span class="operator">=</span> personClass.getDeclaredField(<span class="string">&quot;private_d&quot;</span>);</span><br><span class="line">        <span class="comment">// 忽略访问权限修饰符的安全检查，否则会报错</span></span><br><span class="line">        d.setAccessible(<span class="literal">true</span>);  <span class="comment">// 暴力反射</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value2</span> <span class="operator">=</span> d.get(p);</span><br><span class="line">        System.out.println(value2); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取构造方法</p><ul><li>Constructor&lt;?&gt;[] getConstructors()</li><li>Constructor&lt;T&gt; getConstructor(类&lt;?&gt;… parameterTypes)</li><li>Constructor&lt;T&gt; getDeclaredConstructors()</li><li>Constructor<?>[] getDeclaredConstructor(类<?>… parameterTypes)</li><li>Constructor:构造方法<ul><li>创建对象：<code>T newInstance(object... initargs)</code></li></ul></li></ul><p>Demo：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">personClass</span> <span class="operator">=</span> Person.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Constructor&lt;?&gt;[] getConstructors()</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> personClass.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        System.out.println(constructor1);  <span class="comment">// public com.demo.classDemo.Person(java.lang.String,int)</span></span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> constructor1.newInstance(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        System.out.println(person); <span class="comment">// Person&#123;name=&#x27;张三&#x27;, age=18, public_a=&#x27;null&#x27;, protected_b=0, c=0, private_d=0&#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取成员方法</p><ul><li>Method[] getMethods()</li><li>Method getMethod(String name, 类&lt;?&gt;… parameterTypes)</li><li>Method[] getDeclaredMethods()</li><li>Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes)</li><li>Method:方法对象<ul><li>执行方法:<code>object invoke(object obj, object...args)</code></li><li>获取方法名称:<code>String getName</code></li></ul></li></ul><p>Demo:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">personClass</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定名称的方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">eat_method</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        eat_method.invoke(p);   <span class="comment">// eating...</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">eat_method2</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;eat&quot;</span>, String.class);</span><br><span class="line">        eat_method2.invoke(p,<span class="string">&quot;apple&quot;</span>);  <span class="comment">// eating...apple</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有public修饰的方法</span></span><br><span class="line">        Method[] methods = personClass.getMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method method:methods)&#123;</span><br><span class="line">            System.out.println(method); <span class="comment">// 除了Person的方法，还有Object里的方法</span></span><br><span class="line">        <span class="comment">//method.setAccessible(true);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取类名</p><ul><li>String getName()</li></ul></li></ol></li></ul><h3 id="案例">案例</h3><ul><li>需求:可以创建任意类的对象，并且执行其中任意的方法。</li><li>实现：<ol><li>配置文件</li><li>反射</li></ol></li><li>步骤：<ol><li>将需要创建的对象的全类名和需要执行的方法定义在配置文件中</li><li>在程序中加载读取配置文件</li><li>使用反射技术来加载类文件进内存</li><li>创建对象</li><li>执行方法<br>配置文件（pro.properties）：注意：配置文件放在src目录下<br><code>className=com.demo.classDemo.Person</code><br><code>methodName=eat</code></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            前提：不能改变改类的任何代码，可以创建任意的对象，可以执行任意方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 1. 加载配置文件</span></span><br><span class="line">        <span class="comment">// 1.1 创建Properties对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 1.2 加载配置文件，转换为一个集合</span></span><br><span class="line">        <span class="comment">// 1.2.1 获取class目录下的配置文件</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ReflectTest.class.getClassLoader();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;pro.properties&quot;</span>);</span><br><span class="line">        pro.load(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取配置文件中定义的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.加载该类进内存</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">        <span class="comment">// 4.创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        <span class="comment">//5.获取方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//6.执行方法</span></span><br><span class="line">        method.invoke(obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解">注解</h2><ul><li><p>概念：说明程序的。给计算机看的。</p></li><li><p>使用：<code>@注解名称</code></p></li><li><p>分类：</p><ol><li>生成javadoc文档</li><li>编译检查（如<code>@Override</code>）</li><li>代码分析（用反射）</li></ol></li><li><p>JDK中预定义的一些注解</p><ul><li><code>@Override</code>:检测被该注解标注的方法是否继承自父类（接口）的</li><li><code>@Deprecated</code>：该注解标注的内容表示已过时</li><li><code>@SuppressWarnings(&quot;all&quot;)</code>：压制警告</li></ul></li><li><p>自定义注解</p><ul><li>格式：<ul><li>元注解</li><li><code>public @interface 注解名称&#123; 属性列表; &#125;</code></li></ul></li><li>本质：注解本质上是一个接口，该接口默认继承Annotation接口<br><code>public interface Myanno extends java.lang.annotation.Annotation &#123;&#125;</code></li><li>属性：接口中的抽象方法<ul><li>要求：<ol><li>属性的返回值类型有以下取值<ul><li>基本数据类型</li><li>字符串</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul></li><li>定义了属性，在使用时需要给属性赋值。<ul><li>定义属性时可以使用<strong>default</strong>设置默认值。</li><li>If只有一个属性需要赋值，并且属性的名称是<strong>value</strong>，则<strong>value</strong>可以省略。</li><li>数组赋值时，值使用{ }。如果数组中只有一个值，可省略{ }。</li></ul></li></ol></li></ul></li><li>元注解：用于描述注解的注解。<ul><li><code>@Target</code>：描述注解能够作用的位置<ul><li>ElementType取值：<ul><li>TYPE：可以作用于类上</li><li>METHOD：可以作用于方法上</li><li>FIELD：可以作用于成员变量上</li></ul></li></ul></li><li><code>@Retention</code>：描述注解被保留的阶段<ul><li><code>@Retention(RetentionPolicy.RUNTIME)</code>：当前被描述的注解，会保留到Class字节码文件中，并被JVM读取到。</li></ul></li><li><code>@Documented</code>：描述注解是否被抽取到API文档中</li><li><code>@Inherited</code>：描述注解是否被子类继承</li></ul></li></ul></li><li><p>在程序使用（解析）注解：获取注解中定义的属性值</p><ol><li>获取注解定义的位置（类、方法等等）的对象。（Class、Method、Field）</li><li>获取指定的注解。<code>getAnnotation(Class)</code></li><li>使用注解中的抽象方法获取配置的属性值。</li></ol><p>注解：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 描述需要执行的类名和方法名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span> <span class="comment">// 作用在类上面</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Pro &#123;</span><br><span class="line">    </span><br><span class="line">    String <span class="title function_">className</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">methodName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pro(className = &quot;com.demo.annotation.China&quot;,methodName = &quot;show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        前提：不能改变改类的任何代码，可以创建任意的对象，可以执行任意方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 1. 解析注解</span></span><br><span class="line">        <span class="comment">// 1.1 获取该类的字节码文件对象</span></span><br><span class="line">        Class&lt;ReflectTest&gt; reflectTestClass = ReflectTest.class;</span><br><span class="line">        <span class="comment">// 2. 获取上面的注解对象</span></span><br><span class="line">        <span class="comment">// 在内存中生成了一个该注解接口的子类实现对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public class ProImpl implements Pro&#123;</span></span><br><span class="line"><span class="comment">                public String className()&#123;</span></span><br><span class="line"><span class="comment">                    return &quot;com.demo.annotation.China&quot;;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                public String methodName()&#123;</span></span><br><span class="line"><span class="comment">                    return &quot;show&quot;;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Pro</span> <span class="variable">annotation</span> <span class="operator">=</span> reflectTestClass.getAnnotation(Pro.class);</span><br><span class="line">        <span class="comment">// 3. 调用注解对象中定义的抽象方法，获取返回值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> annotation.className();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> annotation.methodName();</span><br><span class="line">        System.out.println(className);  <span class="comment">// com.demo.annotation.China</span></span><br><span class="line">        System.out.println(methodName); <span class="comment">// show</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
